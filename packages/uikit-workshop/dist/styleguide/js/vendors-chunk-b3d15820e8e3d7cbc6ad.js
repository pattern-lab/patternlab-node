(window.webpackJsonp=window.webpackJsonp||[]).push([["vendors"],{"./node_modules/@reach/visually-hidden/es/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js");\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\nvar style = {\n  border: 0,\n  clip: "rect(0 0 0 0)",\n  height: "1px",\n  width: "1px",\n  margin: "-1px",\n  padding: 0,\n  overflow: "hidden",\n  position: "absolute"\n};\n/* harmony default export */ __webpack_exports__["default"] = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0__["default"].createElement("div", _extends({\n    style: style\n  }, props));\n});\n\n//# sourceURL=webpack:///./node_modules/@reach/visually-hidden/es/index.js?')},"./node_modules/@skatejs/renderer-preact/dist/es/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var skatejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! skatejs */ "./node_modules/skatejs/dist/es/index.js");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.mjs");\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if ("value" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/** @jsx h */\n\n\n\n // TODO make this a Symbol() when it\'s supported.\n\nvar preactNodeName = \'__preactNodeName\';\nvar oldVnode = void 0;\n\nfunction newVnode(vnode) {\n  var fn = vnode.nodeName;\n\n  if (fn && fn.prototype instanceof HTMLElement) {\n    if (!fn[preactNodeName]) {\n      var prefix = fn.name;\n      customElements.define(fn[preactNodeName] = Object(skatejs__WEBPACK_IMPORTED_MODULE_0__["name"])(prefix), function (_fn) {\n        _inherits(_class, _fn);\n\n        function _class() {\n          _classCallCheck(this, _class);\n\n          return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n        }\n\n        return _class;\n      }(fn));\n    }\n\n    vnode.nodeName = fn[preactNodeName];\n  }\n\n  return vnode;\n}\n\nfunction setupPreact() {\n  oldVnode = preact__WEBPACK_IMPORTED_MODULE_1__["default"].options.vnode;\n  preact__WEBPACK_IMPORTED_MODULE_1__["default"].options.vnode = newVnode;\n}\n\nfunction teardownPreact() {\n  preact__WEBPACK_IMPORTED_MODULE_1__["default"].options.vnode = oldVnode;\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (function () {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return function (_Base) {\n    _inherits(_class2, _Base);\n\n    function _class2() {\n      _classCallCheck(this, _class2);\n\n      return _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));\n    }\n\n    _createClass(_class2, [{\n      key: \'renderer\',\n      value: function renderer(root, call) {\n        setupPreact();\n        this._renderRoot = root;\n        this._preactDom = Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(call(), root, this._preactDom || root.childNodes[0]);\n        teardownPreact();\n      }\n    }, {\n      key: \'disconnectedCallback\',\n      value: function disconnectedCallback() {\n        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'disconnectedCallback\', this) && _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'disconnectedCallback\', this).call(this); // Render null to unmount. See https://github.com/skatejs/skatejs/pull/1432#discussion_r183381359\n\n        this._preactDom = Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(null, this._renderRoot, this._preactDom);\n        this._renderRoot = null;\n      }\n    }, {\n      key: \'props\',\n      get: function get() {\n        // We override props so that we can satisfy most use\n        // cases for children by using a slot.\n        return _extends({}, _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'props\', this), {\n          children: Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(\'slot\', null)\n        });\n      }\n    }]);\n\n    return _class2;\n  }(Base);\n});\n\n//# sourceURL=webpack:///./node_modules/@skatejs/renderer-preact/dist/es/index.js?')},"./node_modules/@webcomponents/custom-elements/src/native-shim.js":function(module,exports){eval("/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n(function () {\n  if ( // No Reflect, no classes, no need for shim because native custom elements\n  // require ES2015 classes or Reflect.\n  window.Reflect === undefined || window.customElements === undefined || // The webcomponentsjs custom elements polyfill doesn't require\n  // ES2015-compatible construction (`super()` or `Reflect.construct`).\n  window.customElements.polyfillWrapFlushCallback) {\n    return;\n  }\n\n  var BuiltInHTMLElement = HTMLElement;\n\n  window.HTMLElement =\n  /** @this {!Object} */\n  function HTMLElement() {\n    return Reflect.construct(BuiltInHTMLElement, [],\n    /** @type {!Function} */\n    this.constructor);\n  };\n\n  HTMLElement.prototype = BuiltInHTMLElement.prototype;\n  HTMLElement.prototype.constructor = HTMLElement;\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();\n\n//# sourceURL=webpack:///./node_modules/@webcomponents/custom-elements/src/native-shim.js?")},"./node_modules/@webcomponents/shadydom/src/shadydom.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shady-data.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nvar ShadyData =\n/*#__PURE__*/\nfunction () {\n  function ShadyData() {\n    _classCallCheck(this, ShadyData);\n  }\n\n  _createClass(ShadyData, [{\n    key: \"toJSON\",\n\n    /** @override */\n    value: function toJSON() {\n      return {};\n    }\n  }]);\n\n  return ShadyData;\n}();\nfunction ensureShadyDataForNode(node) {\n  if (!node.__shady) {\n    node.__shady = new ShadyData();\n  }\n\n  return node.__shady;\n}\nfunction shadyDataForNode(node) {\n  return node && node.__shady;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/utils.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/** @type {!Object} */\n\nvar settings = window['ShadyDOM'] || {};\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\nvar desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');\nsettings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);\nsettings.inUse = settings['force'] || !settings.hasNativeShadowDOM;\nsettings.noPatch = settings['noPatch'] || false;\nsettings.preferPerformance = settings['preferPerformance'];\nvar IS_IE = navigator.userAgent.match('Trident');\nsettings.IS_IE = IS_IE;\nvar canUpgrade = function canUpgrade() {\n  return !settings.IS_IE;\n};\nvar utils_isTrackingLogicalChildNodes = function isTrackingLogicalChildNodes(node) {\n  var nodeData = shadyDataForNode(node);\n  return nodeData && nodeData.firstChild !== undefined;\n};\nvar utils_isShadyRoot = function isShadyRoot(obj) {\n  return Boolean(obj._localName === 'ShadyRoot');\n};\nvar utils_hasShadowRootWithSlot = function hasShadowRootWithSlot(node) {\n  var nodeData = shadyDataForNode(node);\n  var root = nodeData && nodeData.root;\n  return root && root._hasInsertionPoint();\n};\nvar utils_p = Element.prototype;\nvar matches = utils_p.matches || utils_p.matchesSelector || utils_p.mozMatchesSelector || utils_p.msMatchesSelector || utils_p.oMatchesSelector || utils_p.webkitMatchesSelector;\nvar matchesSelector = function matchesSelector(element, selector) {\n  return matches.call(element, selector);\n};\nvar mixin = function mixin(target, source) {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n\n  return target;\n}; // NOTE, prefer MutationObserver over Promise for microtask timing\n// for consistency x-platform.\n\nvar twiddle = document.createTextNode('');\nvar utils_content = 0;\nvar queue = [];\nnew MutationObserver(function () {\n  while (queue.length) {\n    // catch errors in user code...\n    try {\n      queue.shift()();\n    } catch (e) {\n      // enqueue another record and throw\n      twiddle.textContent = utils_content++;\n      throw e;\n    }\n  }\n}).observe(twiddle, {\n  characterData: true\n}); // use MutationObserver to get microtask async timing.\n\nvar microtask = function microtask(callback) {\n  queue.push(callback);\n  twiddle.textContent = utils_content++;\n};\nvar hasDocumentContains = Boolean(document.contains);\nvar utils_contains = function contains(container, node) {\n  while (node) {\n    if (node == container) {\n      return true;\n    }\n\n    node = node[SHADY_PREFIX + 'parentNode'];\n  }\n\n  return false;\n};\n\nvar getNodeHTMLCollectionName = function getNodeHTMLCollectionName(node) {\n  return node.getAttribute('id') || node.getAttribute('name');\n};\n\nvar isValidHTMLCollectionName = function isValidHTMLCollectionName(name) {\n  return name !== 'length' && isNaN(name);\n};\n\nvar createPolyfilledHTMLCollection = function createPolyfilledHTMLCollection(nodes) {\n  // Note: loop in reverse so that the first named item matches the named property\n  for (var l = nodes.length - 1; l >= 0; l--) {\n    var node = nodes[l];\n    var name = getNodeHTMLCollectionName(node);\n\n    if (name && isValidHTMLCollectionName(name)) {\n      nodes[name] = node;\n    }\n  }\n\n  nodes.item = function (index) {\n    return nodes[index];\n  };\n\n  nodes.namedItem = function (name) {\n    if (isValidHTMLCollectionName(name) && nodes[name]) {\n      return nodes[name];\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _node = _step.value;\n        var nodeName = getNodeHTMLCollectionName(_node);\n\n        if (nodeName == name) {\n          return _node;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return nodes;\n};\nvar NATIVE_PREFIX = '__shady_native_';\nvar SHADY_PREFIX = '__shady_';\nvar nativeChildNodesArray = function nativeChildNodesArray(parent) {\n  var result = [];\n\n  for (var n = parent[NATIVE_PREFIX + 'firstChild']; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n    result.push(n);\n  }\n\n  return result;\n};\nvar childNodesArray = function childNodesArray(parent) {\n  var result = [];\n\n  for (var n = parent[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n    result.push(n);\n  }\n\n  return result;\n};\n/**\n * Patch a group of accessors on an object only if it exists or if the `force`\n * argument is true.\n * @param {!Object} proto\n * @param {!Object} descriptors\n * @param {string=} prefix\n * @param {Array=} disallowedPatches\n */\n\nvar patchProperties = function patchProperties(proto, descriptors) {\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var disallowedPatches = arguments.length > 3 ? arguments[3] : undefined;\n\n  for (var _p in descriptors) {\n    var newDescriptor = descriptors[_p];\n\n    if (disallowedPatches && disallowedPatches.indexOf(_p) >= 0) {\n      continue;\n    }\n\n    newDescriptor.configurable = true;\n    var name = prefix + _p; // NOTE: we prefer writing directly because some browsers\n    // have descriptors that are writable but not configurable (e.g.\n    // `appendChild` on older browsers)\n\n    if (newDescriptor.value) {\n      proto[name] = newDescriptor.value;\n    } else {\n      // NOTE: this can throw if 'force' is used so catch the error.\n      try {\n        Object.defineProperty(proto, name, newDescriptor);\n      } catch (e) {// this error is harmless so we just trap it.\n      }\n    }\n  }\n};\n/** @type {!function(new:HTMLElement)} */\n\nvar NativeHTMLElement = window['customElements'] && window['customElements']['nativeHTMLElement'] || HTMLElement; // note, this is not a perfect polyfill since it doesn't include symbols\n\n/** @return {!Object<!ObjectPropertyDescriptor>} */\n\nvar getOwnPropertyDescriptors = function getOwnPropertyDescriptors(obj) {\n  var descriptors = {};\n  Object.getOwnPropertyNames(obj).forEach(function (name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n  });\n  return descriptors;\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/flush.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n // render enqueuer/flusher\n\nvar flushList = [];\nvar scheduled;\nfunction enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    microtask(flush);\n  }\n\n  flushList.push(callback);\n}\nfunction flush() {\n  scheduled = false;\n  var didFlush = Boolean(flushList.length);\n\n  while (flushList.length) {\n    flushList.shift()();\n  }\n\n  return didFlush;\n}\nflush['list'] = flushList;\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/observe-changes.js\nfunction observe_changes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction observe_changes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction observe_changes_createClass(Constructor, protoProps, staticProps) { if (protoProps) observe_changes_defineProperties(Constructor.prototype, protoProps); if (staticProps) observe_changes_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar observe_changes_AsyncObserver =\n/*#__PURE__*/\nfunction () {\n  function AsyncObserver() {\n    observe_changes_classCallCheck(this, AsyncObserver);\n\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  observe_changes_createClass(AsyncObserver, [{\n    key: \"schedule\",\n    value: function schedule() {\n      var _this = this;\n\n      if (!this._scheduled) {\n        this._scheduled = true;\n        microtask(function () {\n          _this.flush();\n        });\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._scheduled) {\n        this._scheduled = false;\n        var mutations = this.takeRecords();\n\n        if (mutations.length) {\n          this.callbacks.forEach(function (cb) {\n            cb(mutations);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"takeRecords\",\n    value: function takeRecords() {\n      if (this.addedNodes.length || this.removedNodes.length) {\n        var mutations = [{\n          addedNodes: this.addedNodes,\n          removedNodes: this.removedNodes\n        }];\n        this.addedNodes = [];\n        this.removedNodes = [];\n        return mutations;\n      }\n\n      return [];\n    }\n  }]);\n\n  return AsyncObserver;\n}(); // TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\n\n\nvar observe_changes_observeChildren = function observeChildren(node, callback) {\n  var sd = ensureShadyDataForNode(node);\n\n  if (!sd.observer) {\n    sd.observer = new observe_changes_AsyncObserver();\n  }\n\n  sd.observer.callbacks.add(callback);\n  var observer = sd.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords: function takeRecords() {\n      return observer.takeRecords();\n    }\n  };\n};\nvar observe_changes_unobserveChildren = function unobserveChildren(handle) {\n  var observer = handle && handle._observer;\n\n  if (observer) {\n    observer.callbacks.delete(handle._callback);\n\n    if (!observer.callbacks.size) {\n      ensureShadyDataForNode(handle._node).observer = null;\n    }\n  }\n};\nfunction filterMutations(mutations, target) {\n  /** @const {Node} */\n  var targetRootNode = target.getRootNode();\n  return mutations.map(function (mutation) {\n    /** @const {boolean} */\n    var mutationInScope = targetRootNode === mutation.target.getRootNode();\n\n    if (mutationInScope && mutation.addedNodes) {\n      var nodes = Array.from(mutation.addedNodes).filter(function (n) {\n        return targetRootNode === n.getRootNode();\n      });\n\n      if (nodes.length) {\n        mutation = Object.create(mutation);\n        Object.defineProperty(mutation, 'addedNodes', {\n          value: nodes,\n          configurable: true\n        });\n        return mutation;\n      }\n    } else if (mutationInScope) {\n      return mutation;\n    }\n  }).filter(function (m) {\n    return m;\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/innerHTML.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n\n    case '<':\n      return '&lt;';\n\n    case '>':\n      return '&gt;';\n\n    case '\"':\n      return '&quot;';\n\n    case \"\\xA0\":\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  var set = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n\n  return set;\n} // http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\n\nvar voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\nvar plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @param {Function=} callback\n */\n\nfunction getOuterHTML(node, parentNode, callback) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      {\n        var tagName = node.localName;\n        var s = '<' + tagName;\n        var attrs = node.attributes;\n\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n\n        s += '>';\n\n        if (voidElements[tagName]) {\n          return s;\n        }\n\n        return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n      }\n\n    case Node.TEXT_NODE:\n      {\n        var data =\n        /** @type {Text} */\n        node.data;\n\n        if (parentNode && plaintextParents[parentNode.localName]) {\n          return data;\n        }\n\n        return escapeData(data);\n      }\n\n    case Node.COMMENT_NODE:\n      {\n        return '\x3c!--' +\n        /** @type {Comment} */\n        node.data + '--\x3e';\n      }\n\n    default:\n      {\n        window.console.error(node);\n        throw new Error('not implemented');\n      }\n  }\n}\n/**\n * @param {Node} node\n * @param {Function=} callback\n */\n\nfunction getInnerHTML(node, callback) {\n  if (node.localName === 'template') {\n    node =\n    /** @type {HTMLTemplateElement} */\n    node.content;\n  }\n\n  var s = '';\n  var c$ = callback ? callback(node) : node.childNodes;\n\n  for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\n    s += getOuterHTML(child, node, callback);\n  }\n\n  return s;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-native.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar hasDescriptors = settings.hasDescriptors;\nvar patch_native_NATIVE_PREFIX = NATIVE_PREFIX; // Object on which raw native methods are stored.\n// e.g. `nativeMethods.querySelector.call(node, selector)`\n// same as `node.querySelector(selector)`\n\nvar nativeMethods = {\n  /** @this {Element} */\n  querySelector: function querySelector(selector) {\n    return this[patch_native_NATIVE_PREFIX + 'querySelector'](selector);\n  },\n\n  /** @this {Element} */\n  querySelectorAll: function querySelectorAll(selector) {\n    return this[patch_native_NATIVE_PREFIX + 'querySelectorAll'](selector);\n  }\n}; // Object on which raw native accessors are available via `accessorName(node)`.\n// e.g. `nativeTree.firstChild(node)`\n// same as `node.firstChild`\n\nvar nativeTree = {};\n\nvar installNativeAccessor = function installNativeAccessor(name) {\n  nativeTree[name] = function (node) {\n    return node[patch_native_NATIVE_PREFIX + name];\n  };\n};\n\nvar installNativeMethod = function installNativeMethod(name, fn) {\n  if (!nativeMethods[name]) {\n    nativeMethods[name] = fn;\n  }\n};\n\nvar patch_native_defineNativeAccessors = function defineNativeAccessors(proto, descriptors) {\n  patchProperties(proto, descriptors, patch_native_NATIVE_PREFIX); // make native accessors available to users\n\n  for (var prop in descriptors) {\n    installNativeAccessor(prop);\n  }\n};\n\nvar copyProperties = function copyProperties(proto) {\n  var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  for (var i = 0; i < list.length; i++) {\n    var name = list[i];\n    var descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\n    if (descriptor) {\n      Object.defineProperty(proto, patch_native_NATIVE_PREFIX + name, descriptor); // make native methods/accessors available to users\n\n      if (descriptor.value) {\n        installNativeMethod(name, descriptor.value);\n      } else {\n        installNativeAccessor(name);\n      }\n    }\n  }\n};\n/** @type {!TreeWalker} */\n\n\nvar nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\n/** @type {!TreeWalker} */\n\nvar elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);\n/** @type {!Document} */\n\nvar inertDoc = document.implementation.createHTMLDocument('inert');\n\nvar clearNode = function clearNode(node) {\n  var firstChild;\n\n  while (firstChild = node[patch_native_NATIVE_PREFIX + 'firstChild']) {\n    node[patch_native_NATIVE_PREFIX + 'removeChild'](firstChild);\n  }\n};\n\nvar ParentNodeAccessors = ['firstElementChild', 'lastElementChild', 'children', 'childElementCount'];\nvar ParentNodeMethods = ['querySelector', 'querySelectorAll' // 'append', 'prepend'\n];\nvar patch_native_addNativePrefixedProperties = function addNativePrefixedProperties() {\n  // EventTarget\n  var eventProps = ['dispatchEvent', 'addEventListener', 'removeEventListener'];\n\n  if (window.EventTarget) {\n    copyProperties(window.EventTarget.prototype, eventProps);\n  } else {\n    copyProperties(Node.prototype, eventProps);\n    copyProperties(Window.prototype, eventProps);\n  } // Node\n\n\n  if (hasDescriptors) {\n    copyProperties(Node.prototype, ['parentNode', 'firstChild', 'lastChild', 'previousSibling', 'nextSibling', 'childNodes', 'parentElement', 'textContent']);\n  } else {\n    patch_native_defineNativeAccessors(Node.prototype, {\n      parentNode: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.parentNode();\n        }\n      },\n      firstChild: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.firstChild();\n        }\n      },\n      lastChild: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.lastChild();\n        }\n      },\n      previousSibling: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.previousSibling();\n        }\n      },\n      nextSibling: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.nextSibling();\n        }\n      },\n      // TODO(sorvell): make this a NodeList or whatever\n      childNodes: {\n        /** @this {Node} */\n        get: function get() {\n          var nodes = [];\n          nodeWalker.currentNode = this;\n          var n = nodeWalker.firstChild();\n\n          while (n) {\n            nodes.push(n);\n            n = nodeWalker.nextSibling();\n          }\n\n          return nodes;\n        }\n      },\n      parentElement: {\n        /** @this {Node} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.parentNode();\n        }\n      },\n      textContent: {\n        /** @this {Node} */\n        get: function get() {\n          /* eslint-disable no-case-declarations */\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              // TODO(sorvell): This cannot be a single TreeWalker that's reused\n              // at least for Safari 9, but it's unclear why.\n              var textWalker = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, false);\n              var content = '',\n                  n;\n\n              while (n = textWalker.nextNode()) {\n                // TODO(sorvell): can't use textContent since we patch it on Node.prototype!\n                // However, should probably patch it only on element.\n                content += n.nodeValue;\n              }\n\n              return content;\n\n            default:\n              return this.nodeValue;\n          }\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n\n        /** @this {Node} */\n        set: function set(value) {\n          if (typeof value === 'undefined' || value === null) {\n            value = '';\n          }\n\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              clearNode(this); // Document fragments must have no childnodes if setting a blank string\n\n              if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n                // Note: old Chrome versions require 2nd argument here\n                this[patch_native_NATIVE_PREFIX + 'insertBefore'](document.createTextNode(value), undefined);\n              }\n\n              break;\n\n            default:\n              // TODO(sorvell): can't do this if patch nodeValue.\n              this.nodeValue = value;\n              break;\n          }\n        }\n      }\n    });\n  }\n\n  copyProperties(Node.prototype, ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'cloneNode', 'contains']); // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement\n\n  copyProperties(HTMLElement.prototype, ['parentElement', 'contains']);\n  var ParentNodeWalkerDescriptors = {\n    firstElementChild: {\n      /** @this {ParentNode} */\n      get: function get() {\n        elementWalker.currentNode = this;\n        return elementWalker.firstChild();\n      }\n    },\n    lastElementChild: {\n      /** @this {ParentNode} */\n      get: function get() {\n        elementWalker.currentNode = this;\n        return elementWalker.lastChild();\n      }\n    },\n    children: {\n      /** @this {ParentNode} */\n      get: function get() {\n        var nodes = [];\n        elementWalker.currentNode = this;\n        var n = elementWalker.firstChild();\n\n        while (n) {\n          nodes.push(n);\n          n = elementWalker.nextSibling();\n        }\n\n        return createPolyfilledHTMLCollection(nodes);\n      }\n    },\n    childElementCount: {\n      /** @this {ParentNode} */\n      get: function get() {\n        if (this.children) {\n          return this.children.length;\n        }\n\n        return 0;\n      }\n    }\n  }; // Element\n\n  if (hasDescriptors) {\n    copyProperties(Element.prototype, ParentNodeAccessors);\n    copyProperties(Element.prototype, ['previousElementSibling', 'nextElementSibling', 'innerHTML', 'className']); // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement\n\n    copyProperties(HTMLElement.prototype, ['children', 'innerHTML', 'className']);\n  } else {\n    patch_native_defineNativeAccessors(Element.prototype, ParentNodeWalkerDescriptors);\n    patch_native_defineNativeAccessors(Element.prototype, {\n      previousElementSibling: {\n        /** @this {Element} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.previousSibling();\n        }\n      },\n      nextElementSibling: {\n        /** @this {Element} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.nextSibling();\n        }\n      },\n      innerHTML: {\n        /** @this {Element} */\n        get: function get() {\n          return getInnerHTML(this, nativeChildNodesArray);\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n\n        /** @this {Element} */\n        set: function set(value) {\n          var content = this.localName === 'template' ?\n          /** @type {HTMLTemplateElement} */\n          this.content : this;\n          clearNode(content);\n          var containerName = this.localName || 'div';\n          var htmlContainer;\n\n          if (!this.namespaceURI || this.namespaceURI === inertDoc.namespaceURI) {\n            htmlContainer = inertDoc.createElement(containerName);\n          } else {\n            htmlContainer = inertDoc.createElementNS(this.namespaceURI, containerName);\n          }\n\n          htmlContainer.innerHTML = value;\n          var newContent = this.localName === 'template' ?\n          /** @type {HTMLTemplateElement} */\n          htmlContainer.content : htmlContainer;\n          var firstChild;\n\n          while (firstChild = newContent[patch_native_NATIVE_PREFIX + 'firstChild']) {\n            // Note: old Chrome versions require 2nd argument here\n            content[patch_native_NATIVE_PREFIX + 'insertBefore'](firstChild, undefined);\n          }\n        }\n      },\n      className: {\n        /** @this {Element} */\n        get: function get() {\n          return this.getAttribute('class') || '';\n        },\n\n        /** @this {Element} */\n        set: function set(value) {\n          this.setAttribute('class', value);\n        }\n      }\n    });\n  }\n\n  copyProperties(Element.prototype, ['setAttribute', 'getAttribute', 'hasAttribute', 'removeAttribute', // on older Safari, these are on Element.\n  'focus', 'blur']);\n  copyProperties(Element.prototype, ParentNodeMethods); // HTMLElement\n\n  copyProperties(HTMLElement.prototype, ['focus', 'blur']); // HTMLTemplateElement\n\n  if (window.HTMLTemplateElement) {\n    copyProperties(window.HTMLTemplateElement.prototype, ['innerHTML']);\n  } // DocumentFragment\n\n\n  if (hasDescriptors) {\n    // NOTE, IE 11 does not have on DocumentFragment\n    // firstElementChild\n    // lastElementChild\n    copyProperties(DocumentFragment.prototype, ParentNodeAccessors);\n  } else {\n    patch_native_defineNativeAccessors(DocumentFragment.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(DocumentFragment.prototype, ParentNodeMethods); // Document\n\n  if (hasDescriptors) {\n    copyProperties(Document.prototype, ParentNodeAccessors);\n    copyProperties(Document.prototype, ['activeElement']);\n  } else {\n    patch_native_defineNativeAccessors(Document.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(Document.prototype, ['importNode', 'getElementById']);\n  copyProperties(Document.prototype, ParentNodeMethods);\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-instances.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar InsideDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get childNodes() {\n    return this[SHADY_PREFIX + 'childNodes'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    return this[SHADY_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    return this[SHADY_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get childElementCount() {\n    return this[SHADY_PREFIX + 'childElementCount'];\n  },\n\n  /** @this {Node} */\n  get children() {\n    return this[SHADY_PREFIX + 'children'];\n  },\n\n  /** @this {Node} */\n  get firstElementChild() {\n    return this[SHADY_PREFIX + 'firstElementChild'];\n  },\n\n  /** @this {Node} */\n  get lastElementChild() {\n    return this[SHADY_PREFIX + 'lastElementChild'];\n  },\n\n  /** @this {Node} */\n  get shadowRoot() {\n    return this[SHADY_PREFIX + 'shadowRoot'];\n  }\n\n});\nvar TextContentInnerHTMLDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get textContent() {\n    return this[SHADY_PREFIX + 'textContent'];\n  },\n\n  /** @this {Node} */\n  set textContent(value) {\n    this[SHADY_PREFIX + 'textContent'] = value;\n  },\n\n  /** @this {Node} */\n  get innerHTML() {\n    return this[SHADY_PREFIX + 'innerHTML'];\n  },\n\n  /** @this {Node} */\n  set innerHTML(value) {\n    return this[SHADY_PREFIX + 'innerHTML'] = value;\n  }\n\n});\nvar OutsideDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentElement() {\n    return this[SHADY_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get parentNode() {\n    return this[SHADY_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    return this[SHADY_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    return this[SHADY_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get nextElementSibling() {\n    return this[SHADY_PREFIX + 'nextElementSibling'];\n  },\n\n  /** @this {Node} */\n  get previousElementSibling() {\n    return this[SHADY_PREFIX + 'previousElementSibling'];\n  },\n\n  /** @this {Node} */\n  get className() {\n    return this[SHADY_PREFIX + 'className'];\n  },\n\n  /** @this {Node} */\n  set className(value) {\n    return this[SHADY_PREFIX + 'className'] = value;\n  }\n\n});\n\nfor (var patch_instances_prop in InsideDescriptors) {\n  InsideDescriptors[patch_instances_prop].enumerable = false;\n}\n\nfor (var _prop in TextContentInnerHTMLDescriptors) {\n  TextContentInnerHTMLDescriptors[_prop].enumerable = false;\n}\n\nfor (var _prop2 in OutsideDescriptors) {\n  OutsideDescriptors[_prop2].enumerable = false;\n}\n\nvar noInstancePatching = settings.hasDescriptors || settings.noPatch; // ensure an element has patched \"outside\" accessors; no-op when not needed\n\nvar patchOutsideElementAccessors = noInstancePatching ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__outsideAccessors) {\n    sd.__outsideAccessors = true;\n    patchProperties(element, OutsideDescriptors);\n  }\n}; // ensure an element has patched \"inside\" accessors; no-op when not needed\n\nvar patchInsideElementAccessors = noInstancePatching ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__insideAccessors) {\n    sd.__insideAccessors = true;\n    patchProperties(element, InsideDescriptors); // NOTE: There are compatibility issues with patches for `textContent`\n    // and `innerHTML` between CE and SD. Since SD patches are applied\n    // via `ShadyDOM.patch` and CE patches are applied as the tree is walked,\n    // SD patches overwrite CE patches.\n    // * When SD is in patching mode, SD calls through to native\n    // methods not patched by CE (since SD is at the bottom) and CE does not\n    // upgrade, connect, or disconnect elements. Therefore do *not patch*\n    // these accessors in this case.\n    // * When SD is in `noPatch` mode, the SD patches call through to\n    // \"native\" methods that are patched by CE (since CE is at the bottom).\n    // Therefore continue to patch in this case.\n    // If customElements is not loaded, then these accessors should be\n    // patched so they work correctly.\n\n    if (!window['customElements'] || settings.noPatch) {\n      patchProperties(element, TextContentInnerHTMLDescriptors);\n    }\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-events.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/*\nMake this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`\nhttps://github.com/webcomponents/shadydom/issues/173\n*/\n\nvar\n/** string */\neventWrappersName = \"__eventWrappers\".concat(Date.now());\n/** @type {?function(!Event): boolean} */\n\nvar composedGetter = function () {\n  var composedProp = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');\n  return composedProp ? function (ev) {\n    return composedProp.get.call(ev);\n  } : null;\n}();\n\nvar supportsEventOptions = function () {\n  var supported = false;\n  var eventOptions = {\n    get capture() {\n      supported = true;\n    }\n\n  };\n\n  var listener = function listener() {}; // NOTE: These will be unpatched at this point.\n\n\n  window.addEventListener('test', listener, eventOptions);\n  window.removeEventListener('test', listener, eventOptions);\n  return supported;\n}();\n\nvar parseEventOptions = function parseEventOptions(optionsOrCapture) {\n  var capture, once, passive, shadyTarget;\n\n  if (optionsOrCapture && _typeof(optionsOrCapture) === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n    shadyTarget = optionsOrCapture.__shadyTarget;\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n\n  return {\n    shadyTarget: shadyTarget,\n    capture: capture,\n    once: once,\n    passive: passive,\n    nativeEventOptions: supportsEventOptions ? optionsOrCapture : capture\n  };\n}; // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\n\nvar alwaysComposed = {\n  'blur': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'click': true,\n  'dblclick': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'wheel': true,\n  'beforeinput': true,\n  'input': true,\n  'keydown': true,\n  'keyup': true,\n  'compositionstart': true,\n  'compositionupdate': true,\n  'compositionend': true,\n  'touchstart': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchcancel': true,\n  'pointerover': true,\n  'pointerenter': true,\n  'pointerdown': true,\n  'pointermove': true,\n  'pointerup': true,\n  'pointercancel': true,\n  'pointerout': true,\n  'pointerleave': true,\n  'gotpointercapture': true,\n  'lostpointercapture': true,\n  'dragstart': true,\n  'drag': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'drop': true,\n  'dragend': true,\n  'DOMActivate': true,\n  'DOMFocusIn': true,\n  'DOMFocusOut': true,\n  'keypress': true\n};\nvar unpatchedEvents = {\n  'DOMAttrModified': true,\n  'DOMAttributeNameChanged': true,\n  'DOMCharacterDataModified': true,\n  'DOMElementNameChanged': true,\n  'DOMNodeInserted': true,\n  'DOMNodeInsertedIntoDocument': true,\n  'DOMNodeRemoved': true,\n  'DOMNodeRemovedFromDocument': true,\n  'DOMSubtreeModified': true\n  /**\n   * Some EventTarget subclasses are not Node subclasses, and you cannot call\n   * `getRootNode()` on them.\n   *\n   * @param {!(Node|EventTarget)} eventTarget\n   * @return {!(Node|EventTarget)}\n   */\n\n};\n\nfunction getRootNodeWithFallback(eventTarget) {\n  if (eventTarget instanceof Node) {\n    return eventTarget[SHADY_PREFIX + 'getRootNode']();\n  } else {\n    return eventTarget;\n  }\n}\n\nfunction pathComposer(startNode, composed) {\n  var composedPath = [];\n  var current = startNode;\n  var startRoot = getRootNodeWithFallback(startNode);\n\n  while (current) {\n    composedPath.push(current);\n\n    if (current[SHADY_PREFIX + 'assignedSlot']) {\n      current = current[SHADY_PREFIX + 'assignedSlot'];\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n      current = current.host;\n    } else {\n      current = current[SHADY_PREFIX + 'parentNode'];\n    }\n  } // event composedPath includes window when startNode's ownerRoot is document\n\n\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n\n  return composedPath;\n}\n\nvar patch_events_composedPath = function composedPath(event) {\n  if (!event.__composedPath) {\n    event.__composedPath = pathComposer(event.target, true);\n  }\n\n  return event.__composedPath;\n};\n\nfunction retarget(refNode, path) {\n  if (!utils_isShadyRoot) {\n    return refNode;\n  } // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n\n\n  var refNodePath = pathComposer(refNode, true);\n  var p$ = path;\n\n  for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = getRootNodeWithFallback(ancestor);\n\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n\n    if (!utils_isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nvar EventPatches = {\n  /**\n   * @this {Event}\n   */\n  get composed() {\n    if (this.__composed === undefined) {\n      // if there's an original `composed` getter on the Event prototype, use that\n      if (composedGetter) {\n        // TODO(web-padawan): see https://github.com/webcomponents/shadydom/issues/275\n        this.__composed = this.type === 'focusin' || this.type === 'focusout' || composedGetter(this); // If the event is trusted, or `isTrusted` is not supported, check the list of always composed events\n      } else if (this.isTrusted !== false) {\n        this.__composed = alwaysComposed[this.type];\n      }\n    }\n\n    return (\n      /** @type {!Event} */\n      this.__composed || false\n    );\n  },\n\n  /**\n   * @this {Event}\n   */\n  composedPath: function composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this['__target'], this.composed);\n    }\n\n    return (\n      /** @type {!Event} */\n      this.__composedPath\n    );\n  },\n\n  /**\n   * @this {Event}\n   */\n  get target() {\n    return retarget(this.currentTarget || this['__previousCurrentTarget'], this.composedPath());\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\n  /**\n   * @this {Event}\n   */\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n    } // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\n\n    return retarget(this.currentTarget || this['__previousCurrentTarget'],\n    /** @type {!Event} */\n    this.__relatedTargetComposedPath);\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopPropagation: function stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  }\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  var klazz = function klazz(type, options) {\n    var event = new Base(type, options);\n    event.__composed = options && Boolean(options['composed']);\n    return event;\n  }; // put constructor properties on subclass\n\n\n  klazz.__proto__ = Base;\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nvar nonBubblingEventsToRetarget = {\n  'focus': true,\n  'blur': true\n};\n/**\n * Check if the event has been retargeted by comparing original `target`, and calculated `target`\n * @param {Event} event\n * @return {boolean} True if the original target and calculated target are the same\n */\n\nfunction hasRetargeted(event) {\n  return event['__target'] !== event.target || event.__relatedTarget !== event.relatedTarget;\n}\n/**\n *\n * @param {Event} event\n * @param {Node} node\n * @param {string} phase\n */\n\n\nfunction fireHandlers(event, node, phase) {\n  var hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];\n\n  if (hs) {\n    for (var i = 0, fn; fn = hs[i]; i++) {\n      if (hasRetargeted(event) && event.target === event.relatedTarget) {\n        return;\n      }\n\n      fn.call(node, event);\n\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction retargetNonBubblingEvent(e) {\n  var path = e.composedPath();\n  var node; // override `currentTarget` to let patched `target` calculate correctly\n\n  Object.defineProperty(e, 'currentTarget', {\n    get: function get() {\n      return node;\n    },\n    configurable: true\n  });\n\n  for (var i = path.length - 1; i >= 0; i--) {\n    node = path[i]; // capture phase fires all capture handlers\n\n    fireHandlers(e, node, 'capture');\n\n    if (e.__propagationStopped) {\n      return;\n    }\n  } // set the event phase to `AT_TARGET` as in spec\n\n\n  Object.defineProperty(e, 'eventPhase', {\n    get: function get() {\n      return Event.AT_TARGET;\n    }\n  }); // the event only needs to be fired when owner roots change when iterating the event path\n  // keep track of the last seen owner root\n\n  var lastFiredRoot;\n\n  for (var _i = 0; _i < path.length; _i++) {\n    node = path[_i];\n    var nodeData = shadyDataForNode(node);\n    var root = nodeData && nodeData.root;\n\n    if (_i === 0 || root && root === lastFiredRoot) {\n      fireHandlers(e, node, 'bubble'); // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\n      if (node !== window) {\n        lastFiredRoot = node[SHADY_PREFIX + 'getRootNode']();\n      }\n\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction listenerSettingsEqual(savedListener, node, type, capture, once, passive) {\n  var savedNode = savedListener.node,\n      savedType = savedListener.type,\n      savedCapture = savedListener.capture,\n      savedOnce = savedListener.once,\n      savedPassive = savedListener.passive;\n  return node === savedNode && type === savedType && capture === savedCapture && once === savedOnce && passive === savedPassive;\n}\n\nfunction findListener(wrappers, node, type, capture, once, passive) {\n  for (var i = 0; i < wrappers.length; i++) {\n    if (listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run\n * Try/Catch accessing eventWrappers to work around\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074\n */\n\nfunction getEventWrappers(eventLike) {\n  var wrappers = null;\n\n  try {\n    wrappers = eventLike[eventWrappersName];\n  } catch (e) {} // eslint-disable-line no-empty\n\n\n  return wrappers;\n}\n\nfunction targetNeedsPathCheck(node) {\n  return utils_isShadyRoot(node) || node.localName === 'slot';\n}\n/**\n * @this {EventTarget}\n */\n\n\nfunction patch_events_addEventListener(type, fnOrObj, optionsOrCapture) {\n  var _parseEventOptions = parseEventOptions(optionsOrCapture),\n      capture = _parseEventOptions.capture,\n      once = _parseEventOptions.once,\n      passive = _parseEventOptions.passive,\n      shadyTarget = _parseEventOptions.shadyTarget,\n      nativeEventOptions = _parseEventOptions.nativeEventOptions;\n\n  if (!fnOrObj) {\n    return;\n  }\n\n  var handlerType = _typeof(fnOrObj); // bail if `fnOrObj` is not a function, not an object\n\n\n  if (handlerType !== 'function' && handlerType !== 'object') {\n    return;\n  } // bail if `fnOrObj` is an object without a `handleEvent` method\n\n\n  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {\n    return;\n  }\n\n  if (unpatchedEvents[type]) {\n    return this[NATIVE_PREFIX + 'addEventListener'](type, fnOrObj, nativeEventOptions);\n  } // hack to let ShadyRoots have event listeners\n  // event listener will be on host, but `currentTarget`\n  // will be set to shadyroot for event listener\n\n\n  var target = shadyTarget || this;\n  var wrappers = fnOrObj[eventWrappersName];\n\n  if (wrappers) {\n    // The callback `fn` might be used for multiple nodes/events. Since we generate\n    // a wrapper function, we need to keep track of it when we remove the listener.\n    // It's more efficient to store the node/type/options information as Array in\n    // `fn` itself rather than the node (we assume that the same callback is used\n    // for few nodes at most, whereas a node will likely have many event listeners).\n    // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n    // Stop if the wrapper function has already been created.\n    if (findListener(wrappers, target, type, capture, once, passive) > -1) {\n      return;\n    }\n  } else {\n    fnOrObj[eventWrappersName] = [];\n  }\n  /**\n   * @this {HTMLElement}\n   * @param {Event} e\n   */\n\n\n  var wrapperFn = function wrapperFn(e) {\n    // Support `once` option.\n    if (once) {\n      this[SHADY_PREFIX + 'removeEventListener'](type, fnOrObj, optionsOrCapture);\n    }\n\n    if (!e['__target']) {\n      patchEvent(e);\n    }\n\n    var lastCurrentTargetDesc;\n\n    if (target !== this) {\n      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot\n      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(e, 'currentTarget');\n      Object.defineProperty(e, 'currentTarget', {\n        get: function get() {\n          return target;\n        },\n        configurable: true\n      });\n    }\n\n    e['__previousCurrentTarget'] = e['currentTarget']; // Always check if a shadowRoot or slot is in the current event path.\n    // If it is not, the event was generated on either the host of the shadowRoot\n    // or a children of the host.\n\n    if (targetNeedsPathCheck(target) && e.composedPath().indexOf(target) == -1) {\n      return;\n    } // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\n\n    if (e.composed || e.composedPath().indexOf(target) > -1) {\n      if (hasRetargeted(e) && e.target === e.relatedTarget) {\n        if (e.eventPhase === Event.BUBBLING_PHASE) {\n          e.stopImmediatePropagation();\n        }\n\n        return;\n      } // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase\n\n\n      if (e.eventPhase !== Event.CAPTURING_PHASE && !e.bubbles && e.target !== target && !(target instanceof Window)) {\n        return;\n      }\n\n      var ret = handlerType === 'function' ? fnOrObj.call(target, e) : fnOrObj.handleEvent && fnOrObj.handleEvent(e);\n\n      if (target !== this) {\n        // replace the \"correct\" `currentTarget`\n        if (lastCurrentTargetDesc) {\n          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);\n          lastCurrentTargetDesc = null;\n        } else {\n          delete e['currentTarget'];\n        }\n      }\n\n      return ret;\n    }\n  }; // Store the wrapper information.\n\n\n  fnOrObj[eventWrappersName].push({\n    // note: use target here which is either a shadowRoot\n    // (when the host element is proxy'ing the event) or this element\n    node: target,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn\n  });\n\n  if (nonBubblingEventsToRetarget[type]) {\n    this.__handlers = this.__handlers || {};\n    this.__handlers[type] = this.__handlers[type] || {\n      'capture': [],\n      'bubble': []\n    };\n\n    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n  } else {\n    this[NATIVE_PREFIX + 'addEventListener'](type, wrapperFn, nativeEventOptions);\n  }\n}\n/**\n * @this {EventTarget}\n */\n\nfunction patch_events_removeEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  var _parseEventOptions2 = parseEventOptions(optionsOrCapture),\n      capture = _parseEventOptions2.capture,\n      once = _parseEventOptions2.once,\n      passive = _parseEventOptions2.passive,\n      shadyTarget = _parseEventOptions2.shadyTarget,\n      nativeEventOptions = _parseEventOptions2.nativeEventOptions;\n\n  if (unpatchedEvents[type]) {\n    return this[NATIVE_PREFIX + 'removeEventListener'](type, fnOrObj, nativeEventOptions);\n  }\n\n  var target = shadyTarget || this; // Search the wrapped function.\n\n  var wrapperFn = undefined;\n  var wrappers = getEventWrappers(fnOrObj);\n\n  if (wrappers) {\n    var idx = findListener(wrappers, target, type, capture, once, passive);\n\n    if (idx > -1) {\n      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn; // Cleanup.\n\n      if (!wrappers.length) {\n        fnOrObj[eventWrappersName] = undefined;\n      }\n    }\n  }\n\n  this[NATIVE_PREFIX + 'removeEventListener'](type, wrapperFn || fnOrObj, nativeEventOptions);\n\n  if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {\n    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\n    var _idx = arr.indexOf(wrapperFn);\n\n    if (_idx > -1) {\n      arr.splice(_idx, 1);\n    }\n  }\n}\n\nfunction activateFocusEventOverrides() {\n  for (var ev in nonBubblingEventsToRetarget) {\n    window[NATIVE_PREFIX + 'addEventListener'](ev, function (e) {\n      if (!e['__target']) {\n        patchEvent(e);\n        retargetNonBubblingEvent(e);\n      }\n    }, true);\n  }\n}\n\nvar EventPatchesDescriptors = getOwnPropertyDescriptors(EventPatches);\nvar SHADY_PROTO = '__shady_patchedProto';\nvar SHADY_SOURCE_PROTO = '__shady_sourceProto';\n\nfunction patchEvent(event) {\n  event['__target'] = event.target;\n  event.__relatedTarget = event.relatedTarget; // attempt to patch prototype (via cache)\n\n  if (settings.hasDescriptors) {\n    var proto = Object.getPrototypeOf(event);\n\n    if (!Object.hasOwnProperty(proto, SHADY_PROTO)) {\n      var patchedProto = Object.create(proto);\n      patchedProto[SHADY_SOURCE_PROTO] = proto;\n      patchProperties(patchedProto, EventPatchesDescriptors);\n      proto[SHADY_PROTO] = patchedProto;\n    }\n\n    event.__proto__ = proto[SHADY_PROTO]; // and fallback to patching instance\n  } else {\n    patchProperties(event, EventPatchesDescriptors);\n  }\n}\n\nvar PatchedEvent = mixinComposedFlag(Event);\nvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\nvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\nfunction patchEvents() {\n  activateFocusEventOverrides();\n  window.Event = PatchedEvent;\n  window.CustomEvent = PatchedCustomEvent;\n  window.MouseEvent = PatchedMouseEvent;\n}\nfunction patchClick() {\n  // Fix up `Element.prototype.click()` if `isTrusted` is supported, but `composed` isn't\n  if (!composedGetter && Object.getOwnPropertyDescriptor(Event.prototype, 'isTrusted')) {\n    /** @this {Element} */\n    var composedClickFn = function composedClickFn() {\n      var ev = new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      this[SHADY_PREFIX + 'dispatchEvent'](ev);\n    };\n\n    if (Element.prototype.click) {\n      Element.prototype.click = composedClickFn;\n    } else if (HTMLElement.prototype.click) {\n      HTMLElement.prototype.click = composedClickFn;\n    }\n  }\n}\nvar eventPropertyNames = Object.getOwnPropertyNames(Document.prototype).filter(function (name) {\n  return name.substring(0, 2) === 'on';\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/array-splice.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  var rowCount = oldEnd - oldStart + 1;\n  var columnCount = currentEnd - currentStart + 1;\n  var distances = new Array(rowCount); // \"Addition\" rows. Initialize null column.\n\n  for (var i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (var j = 0; j < columnCount; j++) {\n    distances[0][j] = j;\n  }\n\n  for (var _i = 1; _i < rowCount; _i++) {\n    for (var _j = 1; _j < columnCount; _j++) {\n      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {\n        var north = distances[_i - 1][_j] + 1;\n        var west = distances[_i][_j - 1] + 1;\n        distances[_i][_j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  var i = distances.length - 1;\n  var j = distances[0].length - 1;\n  var current = distances[i][j];\n  var edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    var northWest = distances[i - 1][j - 1];\n    var west = distances[i - 1][j];\n    var north = distances[i][j - 1];\n    var min = void 0;\n    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\n\n\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  var prefixCount = 0;\n  var suffixCount = 0;\n  var splice;\n  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n\n  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  splice = undefined;\n  var splices = [];\n  var index = currentStart;\n  var oldIndex = oldStart;\n\n  for (var i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (var i = 0; i < searchLength; i++) {\n    if (!equals(current[i], old[i])) return i;\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  var index1 = current.length;\n  var index2 = old.length;\n  var count = 0;\n\n  while (count < searchLength && equals(current[--index1], old[--index2])) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\nfunction calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/link-nodes.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\nfunction linkNode(node, container, containerData, ref_node) {\n  patchOutsideElementAccessors(node);\n  ref_node = ref_node || null;\n  var nodeData = ensureShadyDataForNode(node);\n  var ref_nodeData = ref_node ? ensureShadyDataForNode(ref_node) : null; // update ref_node.previousSibling <-> node\n\n  nodeData.previousSibling = ref_node ? ref_nodeData.previousSibling : container[SHADY_PREFIX + 'lastChild'];\n  var psd = shadyDataForNode(nodeData.previousSibling);\n\n  if (psd) {\n    psd.nextSibling = node;\n  } // update node <-> ref_node\n\n\n  var nsd = shadyDataForNode(nodeData.nextSibling = ref_node);\n\n  if (nsd) {\n    nsd.previousSibling = node;\n  } // update node <-> container\n\n\n  nodeData.parentNode = container;\n\n  if (ref_node) {\n    if (ref_node === containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } else {\n    containerData.lastChild = node;\n\n    if (!containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } // remove caching of childNodes\n\n\n  containerData.childNodes = null;\n}\n\nvar link_nodes_recordInsertBefore = function recordInsertBefore(node, container, ref_node) {\n  patchInsideElementAccessors(container);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (containerData.firstChild !== undefined) {\n    containerData.childNodes = null;\n  } // handle document fragments\n\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // Note, documentFragments should not have logical DOM so there's\n    // no need update that. It is possible to append a ShadowRoot, but we're\n    // choosing not to support that.\n    var first = node[NATIVE_PREFIX + 'firstChild'];\n\n    for (var n = first; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n      linkNode(n, container, containerData, ref_node);\n    }\n  } else {\n    linkNode(node, container, containerData, ref_node);\n  }\n};\nvar link_nodes_recordRemoveChild = function recordRemoveChild(node, container) {\n  var nodeData = ensureShadyDataForNode(node);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (node === containerData.firstChild) {\n    containerData.firstChild = nodeData.nextSibling;\n  }\n\n  if (node === containerData.lastChild) {\n    containerData.lastChild = nodeData.previousSibling;\n  }\n\n  var p = nodeData.previousSibling;\n  var n = nodeData.nextSibling;\n\n  if (p) {\n    ensureShadyDataForNode(p).nextSibling = n;\n  }\n\n  if (n) {\n    ensureShadyDataForNode(n).previousSibling = p;\n  } // When an element is removed, logical data is no longer tracked.\n  // Explicitly set `undefined` here to indicate this. This is disginguished\n  // from `null` which is set if info is null.\n\n\n  nodeData.parentNode = nodeData.previousSibling = nodeData.nextSibling = undefined;\n\n  if (containerData.childNodes !== undefined) {\n    // remove caching of childNodes\n    containerData.childNodes = null;\n  }\n};\n/**\n * @param  {!Node|DocumentFragment} node\n * @param  {!Node|DocumentFragment=} adoptedParent\n */\n\nvar link_nodes_recordChildNodes = function recordChildNodes(node, adoptedParent) {\n  var nodeData = ensureShadyDataForNode(node);\n\n  if (!adoptedParent && nodeData.firstChild !== undefined) {\n    return;\n  } // remove caching of childNodes\n\n\n  nodeData.childNodes = null;\n  var first = nodeData.firstChild = node[NATIVE_PREFIX + 'firstChild'];\n  nodeData.lastChild = node[NATIVE_PREFIX + 'lastChild'];\n  patchInsideElementAccessors(node);\n\n  for (var n = first, previous; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n    var sd = ensureShadyDataForNode(n);\n    sd.parentNode = adoptedParent || node;\n    sd.nextSibling = n[NATIVE_PREFIX + 'nextSibling'];\n    sd.previousSibling = previous || null;\n    previous = n;\n    patchOutsideElementAccessors(n);\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/style-scoping.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar style_scoping_scopingShim = null;\nfunction getScopingShim() {\n  if (!style_scoping_scopingShim) {\n    style_scoping_scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];\n  }\n\n  return style_scoping_scopingShim || null;\n}\n/**\n * @param {!Node} node\n * @param {string} attr\n * @param {string} value\n */\n\nfunction scopeClassAttribute(node, attr, value) {\n  var scopingShim = getScopingShim();\n\n  if (scopingShim && attr === 'class') {\n    scopingShim['setElementClass'](node, value);\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n */\n\nfunction addShadyScoping(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['scopeNode'](node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} currentScopeName\n */\n\nfunction removeShadyScoping(node, currentScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['unscopeNode'](node, currentScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @param {string} oldScopeName\n */\n\nfunction replaceShadyScoping(node, newScopeName, oldScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  if (oldScopeName) {\n    removeShadyScoping(node, oldScopeName);\n  }\n\n  addShadyScoping(node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @return {boolean}\n */\n\nfunction currentScopeIsCorrect(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return true;\n  }\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // NOTE: as an optimization, only check that all the top-level children\n    // have the correct scope.\n    var correctScope = true;\n\n    for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n      correctScope = correctScope && currentScopeIsCorrect(n, newScopeName);\n    }\n\n    return correctScope;\n  }\n\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n\n  var currentScope = scopingShim['currentScopeForNode'](node);\n  return currentScope === newScopeName;\n}\n/**\n * @param {!Node} node\n * @return {string}\n */\n\nfunction currentScopeForNode(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return '';\n  }\n\n  return scopingShim['currentScopeForNode'](node);\n}\n/**\n * Walk over a node's tree and apply visitorFn to each element node\n *\n * @param {Node} node\n * @param {function(!Node):void} visitorFn\n */\n\nfunction treeVisitor(node, visitorFn) {\n  if (!node) {\n    return;\n  } // this check is necessary if `node` is a Document Fragment\n\n\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    visitorFn(node);\n  }\n\n  for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      treeVisitor(n, visitorFn);\n    }\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Node.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\nvar doc = window.document;\nvar preferPerformance = settings.preferPerformance;\nvar nativeIsConnectedAccessors =\n/** @type {ObjectPropertyDescriptor} */\nObject.getOwnPropertyDescriptor(Node.prototype, 'isConnected');\nvar nativeIsConnected = nativeIsConnectedAccessors && nativeIsConnectedAccessors.get;\nfunction Node_clearNode(node) {\n  var firstChild;\n\n  while (firstChild = node[SHADY_PREFIX + 'firstChild']) {\n    node[SHADY_PREFIX + 'removeChild'](firstChild);\n  }\n}\n\nfunction removeOwnerShadyRoot(node) {\n  // optimization: only reset the tree if node is actually in a root\n  if (hasCachedOwnerRoot(node)) {\n    for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n      removeOwnerShadyRoot(n);\n    }\n  }\n\n  var nodeData = shadyDataForNode(node);\n\n  if (nodeData) {\n    nodeData.ownerShadyRoot = undefined;\n  }\n}\n\nfunction hasCachedOwnerRoot(node) {\n  var nodeData = shadyDataForNode(node);\n  return Boolean(nodeData && nodeData.ownerShadyRoot !== undefined);\n}\n/**\n * Finds the first flattened node that is composed in the node's parent.\n * If the given node is a slot, then the first flattened node is returned\n * if it exists, otherwise advance to the node's nextSibling.\n * @param {Node} node within which to find first composed node\n * @returns {Node} first composed node\n */\n\n\nfunction firstComposedNode(node) {\n  var composed = node;\n\n  if (node && node.localName === 'slot') {\n    var nodeData = shadyDataForNode(node);\n    var flattened = nodeData && nodeData.flattenedNodes;\n    composed = flattened && flattened.length ? flattened[0] : firstComposedNode(node[SHADY_PREFIX + 'nextSibling']);\n  }\n\n  return composed;\n}\n/**\n * @param {Node} node\n * @param {Node=} addedNode\n * @param {Node=} removedNode\n */\n\n\nfunction scheduleObserver(node, addedNode, removedNode) {\n  var nodeData = shadyDataForNode(node);\n  var observer = nodeData && nodeData.observer;\n\n  if (observer) {\n    if (addedNode) {\n      observer.addedNodes.push(addedNode);\n    }\n\n    if (removedNode) {\n      observer.removedNodes.push(removedNode);\n    }\n\n    observer.schedule();\n  }\n}\n\nvar NodePatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentNode() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.parentNode;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.firstChild;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.lastChild;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.nextSibling;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.previousSibling;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get childNodes() {\n    var childNodes;\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var nodeData = shadyDataForNode(this);\n\n      if (!nodeData.childNodes) {\n        nodeData.childNodes = [];\n\n        for (var n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n          nodeData.childNodes.push(n);\n        }\n      }\n\n      childNodes = nodeData.childNodes;\n    } else {\n      childNodes = this[NATIVE_PREFIX + 'childNodes'];\n    }\n\n    childNodes.item = function (index) {\n      return childNodes[index];\n    };\n\n    return childNodes;\n  },\n\n  /** @this {Node} */\n  get parentElement() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.parentNode;\n\n    if (l && l.nodeType !== Node.ELEMENT_NODE) {\n      l = null;\n    }\n\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get isConnected() {\n    if (nativeIsConnected && nativeIsConnected.call(this)) {\n      return true;\n    }\n\n    if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n      return false;\n    } // Fast path for distributed nodes.\n\n\n    var ownerDocument = this.ownerDocument;\n\n    if (hasDocumentContains) {\n      if (ownerDocument[NATIVE_PREFIX + 'contains'](this)) {\n        return true;\n      }\n    } else if (ownerDocument.documentElement && ownerDocument.documentElement[NATIVE_PREFIX + 'contains'](this)) {\n      return true;\n    } // Slow path for non-distributed nodes.\n\n\n    var node = this;\n\n    while (node && !(node instanceof Document)) {\n      node = node[SHADY_PREFIX + 'parentNode'] || (utils_isShadyRoot(node) ?\n      /** @type {ShadowRoot} */\n      node.host : undefined);\n    }\n\n    return !!(node && node instanceof Document);\n  },\n\n  /** @this {Node} */\n  get textContent() {\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var tc = [];\n\n      for (var n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        if (n.nodeType !== Node.COMMENT_NODE) {\n          tc.push(n[SHADY_PREFIX + 'textContent']);\n        }\n      }\n\n      return tc.join('');\n    } else {\n      return this[NATIVE_PREFIX + 'textContent'];\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {string} value\n   */\n  set textContent(value) {\n    if (typeof value === 'undefined' || value === null) {\n      value = '';\n    }\n\n    switch (this.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        if (!utils_isTrackingLogicalChildNodes(this) && settings.hasDescriptors) {\n          // may be removing a nested slot but fast path if we know we are not.\n          var firstChild = this[SHADY_PREFIX + 'firstChild'];\n\n          if (firstChild != this[SHADY_PREFIX + 'lastChild'] || firstChild && firstChild.nodeType != Node.TEXT_NODE) {\n            Node_clearNode(this);\n          }\n\n          this[NATIVE_PREFIX + 'textContent'] = value;\n        } else {\n          Node_clearNode(this); // Document fragments must have no childNodes if setting a blank string\n\n          if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n            this[SHADY_PREFIX + 'insertBefore'](document.createTextNode(value));\n          }\n        }\n\n        break;\n\n      default:\n        // Note, be wary of patching `nodeValue`.\n        this.nodeValue = value;\n        break;\n    }\n  },\n\n  // Patched `insertBefore`. Note that all mutations that add nodes are routed\n  // here. When a <slot> is added or a node is added to a host with a shadowRoot\n  // with a slot, a standard dom `insert` call is aborted and `_asyncRender`\n  // is called on the relevant shadowRoot. In all other cases, a standard dom\n  // `insert` can be made, but the location and ref_node may need to be changed.\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  insertBefore: function insertBefore(node, ref_node) {\n    // optimization: assume native insertBefore is ok if the nodes are not in the document.\n    if (this.ownerDocument !== doc && node.ownerDocument !== doc) {\n      this[NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      return node;\n    }\n\n    if (node === this) {\n      throw Error(\"Failed to execute 'appendChild' on 'Node': The new child element contains the parent.\");\n    }\n\n    if (ref_node) {\n      var refData = shadyDataForNode(ref_node);\n      var p = refData && refData.parentNode;\n\n      if (p !== undefined && p !== this || p === undefined && ref_node[NATIVE_PREFIX + 'parentNode'] !== this) {\n        throw Error(\"Failed to execute 'insertBefore' on 'Node': The node \" + \"before which the new node is to be inserted is not a child of this node.\");\n      }\n    }\n\n    if (ref_node === node) {\n      return node;\n    }\n    /** @type {!Array<!HTMLSlotElement>} */\n\n\n    var slotsAdded = [];\n    var ownerRoot = attach_shadow_ownerShadyRootForNode(this);\n    /** @type {string} */\n\n    var newScopeName = ownerRoot ? ownerRoot.host.localName : currentScopeForNode(this);\n    /** @type {string} */\n\n    var oldScopeName; // remove from existing location\n\n    var parentNode = node[SHADY_PREFIX + 'parentNode'];\n\n    if (parentNode) {\n      oldScopeName = currentScopeForNode(node);\n      var skipUnscoping = // Don't remove scoping if we're inserting into another shadowRoot;\n      // this would be unnecessary since it will be re-scoped below\n      Boolean(ownerRoot) || // Don't remove scoping if we're being moved between non-shadowRoot\n      // locations (the likely case is when moving pre-scoped nodes in a template)\n      !attach_shadow_ownerShadyRootForNode(node) || // Under preferPerformance, don't remove scoping when moving back into\n      // a document fragment that was previously scoped; the assumption is\n      // that the user should only move correctly-scoped DOM back into it\n      preferPerformance && this['__noInsertionPoint'] !== undefined;\n      parentNode[SHADY_PREFIX + 'removeChild'](node, skipUnscoping);\n    } // add to new parent\n\n\n    var allowNativeInsert = true;\n    var needsScoping = (!preferPerformance || // Under preferPerformance, only re-scope if we're not coming from a\n    // pre-scoped doc fragment or back into a pre-scoped doc fragment\n    node['__noInsertionPoint'] === undefined && this['__noInsertionPoint'] === undefined) && !currentScopeIsCorrect(node, newScopeName);\n    var needsSlotFinding = ownerRoot && !node['__noInsertionPoint'] && (!preferPerformance || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\n    if (needsSlotFinding || needsScoping) {\n      // NOTE: avoid node.removeChild as this *can* trigger another patched\n      // method (e.g. custom elements) and we want only the shady method to run.\n      // The following table describes what style scoping actions should happen as a result of this insertion.\n      // document -> shadowRoot: replace\n      // shadowRoot -> shadowRoot: replace\n      // shadowRoot -> shadowRoot of same type: do nothing\n      // shadowRoot -> document: allow unscoping\n      // document -> document: do nothing\n      // The \"same type of shadowRoot\" and \"document to document cases rely on `currentScopeIsCorrect` returning true\n      if (needsScoping) {\n        // in a document or disconnected tree, replace scoping if necessary\n        oldScopeName = oldScopeName || currentScopeForNode(node);\n      }\n\n      treeVisitor(node, function (node) {\n        if (needsSlotFinding && node.localName === 'slot') {\n          slotsAdded.push(\n          /** @type {!HTMLSlotElement} */\n          node);\n        }\n\n        if (needsScoping) {\n          replaceShadyScoping(node, newScopeName, oldScopeName);\n        }\n      });\n    } // if a slot is added, must render containing root.\n\n\n    if (slotsAdded.length) {\n      ownerRoot._addSlots(slotsAdded);\n\n      ownerRoot._asyncRender();\n    }\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      link_nodes_recordInsertBefore(node, this, ref_node); // when inserting into a host with a shadowRoot with slot, use\n      // `shadowRoot._asyncRender()` via `attach-shadow` module\n\n      var parentData = shadyDataForNode(this);\n\n      if (utils_hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n\n        allowNativeInsert = false; // when inserting into a host with shadowRoot with NO slot, do nothing\n        // as the node should not be added to composed dome anywhere.\n      } else if (parentData.root) {\n        allowNativeInsert = false;\n      }\n    }\n\n    if (allowNativeInsert) {\n      // if adding to a shadyRoot, add to host instead\n      var container = utils_isShadyRoot(this) ?\n      /** @type {ShadowRoot} */\n      this.host : this; // if ref_node, get the ref_node that's actually in composed dom.\n\n      if (ref_node) {\n        ref_node = firstComposedNode(ref_node);\n        container[NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      } else {\n        container[NATIVE_PREFIX + 'appendChild'](node);\n      } // Since ownerDocument is not patched, it can be incorrect after this call\n      // if the node is physically appended via distribution. This can result\n      // in the custom elements polyfill not upgrading the node if it's in an inert doc.\n      // We correct this by calling `adoptNode`.\n\n    } else if (node.ownerDocument !== this.ownerDocument) {\n      this.ownerDocument.adoptNode(node);\n    }\n\n    scheduleObserver(this, node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   */\n  appendChild: function appendChild(node) {\n    // if this is a shadowRoot and the shadowRoot is passed as `node`\n    // then an optimized append has already been performed, so do nothing.\n    if (!(this == node && utils_isShadyRoot(node))) {\n      return this[SHADY_PREFIX + 'insertBefore'](node);\n    }\n  },\n\n  /**\n   * Patched `removeChild`. Note that all dom \"removals\" are routed here.\n   * Removes the given `node` from the element's `children`.\n   * This method also performs dom composition.\n   * @this {Node}\n   * @param {Node} node\n   * @param {boolean=} skipUnscoping\n   */\n  removeChild: function removeChild(node) {\n    var skipUnscoping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.ownerDocument !== doc) {\n      return this[NATIVE_PREFIX + 'removeChild'](node);\n    }\n\n    if (node[SHADY_PREFIX + 'parentNode'] !== this) {\n      throw Error('The node to be removed is not a child of this node: ' + node);\n    }\n\n    var preventNativeRemove;\n    var ownerRoot = attach_shadow_ownerShadyRootForNode(node);\n\n    var removingInsertionPoint = ownerRoot && ownerRoot._removeContainedSlots(node);\n\n    var parentData = shadyDataForNode(this);\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      link_nodes_recordRemoveChild(node, this);\n\n      if (utils_hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n\n        preventNativeRemove = true;\n      }\n    } // unscope a node leaving a ShadowRoot if ShadyCSS is present, and this node\n    // is not going to be rescoped in `insertBefore`\n\n\n    if (getScopingShim() && !skipUnscoping && ownerRoot && node.nodeType !== Node.TEXT_NODE) {\n      var oldScopeName = currentScopeForNode(node);\n      treeVisitor(node, function (node) {\n        removeShadyScoping(node, oldScopeName);\n      });\n    }\n\n    removeOwnerShadyRoot(node); // if removing slot, must render containing root\n\n    if (ownerRoot) {\n      var changeSlotContent = this && this.localName === 'slot';\n\n      if (changeSlotContent) {\n        preventNativeRemove = true;\n      }\n\n      if (removingInsertionPoint || changeSlotContent) {\n        ownerRoot._asyncRender();\n      }\n    }\n\n    if (!preventNativeRemove) {\n      // if removing from a shadyRoot, remove from host instead\n      var container = utils_isShadyRoot(this) ?\n      /** @type {ShadowRoot} */\n      this.host : this; // not guaranteed to physically be in container; e.g.\n      // (1) if parent has a shadyRoot, element may or may not at distributed\n      // location (could be undistributed)\n      // (2) if parent is a slot, element may not ben in composed dom\n\n      if (!(parentData.root || node.localName === 'slot') || container === node[NATIVE_PREFIX + 'parentNode']) {\n        container[NATIVE_PREFIX + 'removeChild'](node);\n      }\n    }\n\n    scheduleObserver(this, null, node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  replaceChild: function replaceChild(node, ref_node) {\n    this[SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    this[SHADY_PREFIX + 'removeChild'](ref_node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {boolean=} deep\n   */\n  cloneNode: function cloneNode(deep) {\n    if (this.localName == 'template') {\n      return this[NATIVE_PREFIX + 'cloneNode'](deep);\n    } else {\n      var n = this[NATIVE_PREFIX + 'cloneNode'](false); // Attribute nodes historically had childNodes, but they have later\n      // been removed from the spec.\n      // Make sure we do not do a deep clone on them for old browsers (IE11)\n\n      if (deep && n.nodeType !== Node.ATTRIBUTE_NODE) {\n        for (var c = this[SHADY_PREFIX + 'firstChild'], nc; c; c = c[SHADY_PREFIX + 'nextSibling']) {\n          nc = c[SHADY_PREFIX + 'cloneNode'](true);\n          n[SHADY_PREFIX + 'appendChild'](nc);\n        }\n      }\n\n      return n;\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {Object=} options\n   */\n  // TODO(sorvell): implement `options` e.g. `{ composed: boolean }`\n  getRootNode: function getRootNode(options) {\n    // eslint-disable-line no-unused-vars\n    if (!this || !this.nodeType) {\n      return;\n    }\n\n    var nodeData = ensureShadyDataForNode(this);\n    var root = nodeData.ownerShadyRoot;\n\n    if (root === undefined) {\n      if (utils_isShadyRoot(this)) {\n        root = this;\n        nodeData.ownerShadyRoot = root;\n      } else {\n        var parent = this[SHADY_PREFIX + 'parentNode'];\n        root = parent ? parent[SHADY_PREFIX + 'getRootNode'](options) : this; // memo-ize result for performance but only memo-ize\n        // result if node is in the document. This avoids a problem where a root\n        // can be cached while an element is inside a fragment.\n        // If this happens and we cache the result, the value can become stale\n        // because for perf we avoid processing the subtree of added fragments.\n\n        if (document.documentElement[NATIVE_PREFIX + 'contains'](this)) {\n          nodeData.ownerShadyRoot = root;\n        }\n      }\n    }\n\n    return root;\n  },\n\n  /** @this {Node} */\n  contains: function contains(node) {\n    return utils_contains(this, node);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ParentNode.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * @param {Node} node\n * @param {Function} matcher\n * @param {Function=} halter\n */\n\nfunction query(node, matcher, halter) {\n  var list = [];\n  queryChildNodes(node, matcher, halter, list);\n  return list;\n}\n\nfunction queryChildNodes(parent, matcher, halter, list) {\n  for (var n = parent[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n    if (n.nodeType === Node.ELEMENT_NODE && queryElement(n, matcher, halter, list)) {\n      return true;\n    }\n  }\n}\n\nfunction queryElement(node, matcher, halter, list) {\n  var result = matcher(node);\n\n  if (result) {\n    list.push(node);\n  }\n\n  if (halter && halter(result)) {\n    return result;\n  }\n\n  queryChildNodes(node, matcher, halter, list);\n} // Needed on Element, DocumentFragment, Document\n\n\nvar ParentNodePatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get firstElementChild() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.firstChild !== undefined) {\n      var n = this[SHADY_PREFIX + 'firstChild'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'nextSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'firstElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get lastElementChild() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.lastChild !== undefined) {\n      var n = this[SHADY_PREFIX + 'lastChild'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'previousSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'lastElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get children() {\n    if (!utils_isTrackingLogicalChildNodes(this)) {\n      return this[NATIVE_PREFIX + 'children'];\n    }\n\n    return createPolyfilledHTMLCollection(Array.prototype.filter.call(childNodesArray(this), function (n) {\n      return n.nodeType === Node.ELEMENT_NODE;\n    }));\n  },\n\n  /** @this {Element} */\n  get childElementCount() {\n    var children = this[SHADY_PREFIX + 'children'];\n\n    if (children) {\n      return children.length;\n    }\n\n    return 0;\n  }\n\n});\nvar QueryPatches = getOwnPropertyDescriptors({\n  // TODO(sorvell): consider doing native QSA and filtering results.\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   */\n  querySelector: function querySelector(selector) {\n    // match selector and halt on first result.\n    var result = query(this, function (n) {\n      return matchesSelector(n, selector);\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  },\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   * @param  {boolean} useNative\n   */\n  // TODO(sorvell): `useNative` option relies on native querySelectorAll and\n  // misses distributed nodes, see\n  // https://github.com/webcomponents/shadydom/pull/210#issuecomment-361435503\n  querySelectorAll: function querySelectorAll(selector, useNative) {\n    if (useNative) {\n      var o = Array.prototype.slice.call(this[NATIVE_PREFIX + 'querySelectorAll'](selector));\n      var root = this[SHADY_PREFIX + 'getRootNode']();\n      return o.filter(function (e) {\n        return e[SHADY_PREFIX + 'getRootNode']() == root;\n      });\n    }\n\n    return query(this, function (n) {\n      return matchesSelector(n, selector);\n    });\n  }\n}); // In preferPerformance mode, create a custom `ParentNodeDocumentOrFragment`\n// that optionally does not mixin querySelector/All; this is a performance\n// optimization. In noPatch, we need to keep the query patches here in order to\n// ensure the query API is available on the wrapper\n\nvar ParentNodeDocumentOrFragmentPatches = settings.preferPerformance && !settings.noPatch ? Object.assign({}, ParentNodePatches) : ParentNodePatches;\nObject.assign(ParentNodePatches, QueryPatches);\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrFragment.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar DocumentOrFragmentPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {Element}\n   * @param {string} id\n   */\n  getElementById: function getElementById(id) {\n    if (id === '') {\n      return null;\n    }\n\n    var result = query(this, function (n) {\n      return n.id == id;\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrShadowRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nfunction getDocumentActiveElement() {\n  if (settings.hasDescriptors) {\n    return document[NATIVE_PREFIX + 'activeElement'];\n  } else {\n    return document.activeElement;\n  }\n}\n\nvar DocumentOrShadowRootPatches = getOwnPropertyDescriptors({\n  /** @this {Document|ShadowRoot} */\n  get activeElement() {\n    var active = getDocumentActiveElement(); // In IE11, activeElement might be an empty object if the document is\n    // contained in an iframe.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/\n\n    if (!active || !active.nodeType) {\n      return null;\n    }\n\n    var isShadyRoot = !!utils_isShadyRoot(this);\n\n    if (this !== document) {\n      // If this node isn't a document or shady root, then it doesn't have\n      // an active element.\n      if (!isShadyRoot) {\n        return null;\n      } // If this shady root's host is the active element or the active\n      // element is not a descendant of the host (in the composed tree),\n      // then it doesn't have an active element.\n\n\n      if (this.host === active || !this.host[NATIVE_PREFIX + 'contains'](active)) {\n        return null;\n      }\n    } // This node is either the document or a shady root of which the active\n    // element is a (composed) descendant of its host; iterate upwards to\n    // find the active element's most shallow host within it.\n\n\n    var activeRoot = attach_shadow_ownerShadyRootForNode(active);\n\n    while (activeRoot && activeRoot !== this) {\n      active = activeRoot.host;\n      activeRoot = attach_shadow_ownerShadyRootForNode(active);\n    }\n\n    if (this === document) {\n      // This node is the document, so activeRoot should be null.\n      return activeRoot ? null : active;\n    } else {\n      // This node is a non-document shady root, and it should be\n      // activeRoot.\n      return activeRoot === this ? active : null;\n    }\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ElementOrShadowRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/** @type {!Document} */\n\nvar ElementOrShadowRoot_inertDoc = document.implementation.createHTMLDocument('inert');\nvar ElementOrShadowRootPatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get innerHTML() {\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var content = this.localName === 'template' ?\n      /** @type {HTMLTemplateElement} */\n      this.content : this;\n      return getInnerHTML(content, childNodesArray);\n    } else {\n      return this[NATIVE_PREFIX + 'innerHTML'];\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set innerHTML(value) {\n    if (this.localName === 'template') {\n      this[NATIVE_PREFIX + 'innerHTML'] = value;\n    } else {\n      Node_clearNode(this);\n      var containerName = this.localName || 'div';\n      var htmlContainer;\n\n      if (!this.namespaceURI || this.namespaceURI === ElementOrShadowRoot_inertDoc.namespaceURI) {\n        htmlContainer = ElementOrShadowRoot_inertDoc.createElement(containerName);\n      } else {\n        htmlContainer = ElementOrShadowRoot_inertDoc.createElementNS(this.namespaceURI, containerName);\n      }\n\n      if (settings.hasDescriptors) {\n        htmlContainer[NATIVE_PREFIX + 'innerHTML'] = value;\n      } else {\n        htmlContainer.innerHTML = value;\n      }\n\n      var firstChild;\n\n      while (firstChild = htmlContainer[SHADY_PREFIX + 'firstChild']) {\n        this[SHADY_PREFIX + 'insertBefore'](firstChild);\n      }\n    }\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ShadowRoot.js\nfunction ShadowRoot_typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { ShadowRoot_typeof = function _typeof(obj) { return typeof obj; }; } else { ShadowRoot_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return ShadowRoot_typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar ShadowRootPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener: function addEventListener(type, fn, optionsOrCapture) {\n    if (ShadowRoot_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    } // Note, `__shadyTarget` may already be set if an event was added on a <slot> child\n\n\n    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;\n    this.host[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);\n  },\n\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener: function removeEventListener(type, fn, optionsOrCapture) {\n    if (ShadowRoot_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    } // Note, `__shadyTarget` may already be set if an event was added on a <slot> child\n\n\n    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;\n    this.host[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-shadyRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n/**\n * @param {!Object} proto\n * @param {string=} prefix\n */\n\nvar patch_shadyRoot_patchShadyAccessors = function patchShadyAccessors(proto, prefix) {\n  patchProperties(proto, ShadowRootPatches, prefix);\n  patchProperties(proto, DocumentOrShadowRootPatches, prefix);\n  patchProperties(proto, ElementOrShadowRootPatches, prefix); // We ensure ParentNode accessors since these do not exist in Edge/IE on DocumentFragments.\n\n  patchProperties(proto, ParentNodePatches, prefix); // Ensure `shadowRoot` has basic descriptors when we cannot rely\n  // on them coming from DocumentFragment.\n  //\n  // Case 1, noPatching: Because we want noPatch ShadyRoots to have native property\n  // names so that they do not have to be wrapped...\n  // When we do *not* patch Node/DocumentFragment.prototype\n  // we must manually install those properties on ShadyRoot's prototype.\n  // Note, it's important to only install these in this mode so as not to stomp\n  // over CustomElements polyfill's patches on Node/DocumentFragment methods.\n\n  if (settings.noPatch && !prefix) {\n    patchProperties(proto, NodePatches, prefix);\n    patchProperties(proto, DocumentOrFragmentPatches, prefix); // Case 2, bad descriptors: Ensure accessors are on ShadowRoot.\n    // These descriptors are normally used for instance patching but because\n    // ShadyRoot can always be patched, just do it to the prototype.\n  } else if (!settings.hasDescriptors) {\n    patchProperties(proto, OutsideDescriptors);\n    patchProperties(proto, InsideDescriptors);\n    patchProperties(proto, TextContentInnerHTMLDescriptors);\n  }\n};\n\nvar patch_shadyRoot_patchShadyRoot = function patchShadyRoot(proto) {\n  proto.__proto__ = DocumentFragment.prototype; // patch both prefixed and not, even when noPatch == true.\n\n  patch_shadyRoot_patchShadyAccessors(proto, SHADY_PREFIX);\n  patch_shadyRoot_patchShadyAccessors(proto); // Ensure native properties are all safely wrapped since ShadowRoot is not an\n  // actual DocumentFragment instance.\n\n  Object.defineProperties(proto, {\n    nodeType: {\n      value: Node.DOCUMENT_FRAGMENT_NODE,\n      configurable: true\n    },\n    nodeName: {\n      value: '#document-fragment',\n      configurable: true\n    },\n    nodeValue: {\n      value: null,\n      configurable: true\n    }\n  }); // make undefined\n\n  ['localName', 'namespaceURI', 'prefix'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      value: undefined,\n      configurable: true\n    });\n  }); // defer properties to host\n\n  ['ownerDocument', 'baseURI', 'isConnected'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      /** @this {ShadowRoot} */\n      get: function get() {\n        return this.host[prop];\n      },\n      configurable: true\n    });\n  });\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/attach-shadow.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction attach_shadow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction attach_shadow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction attach_shadow_createClass(Constructor, protoProps, staticProps) { if (protoProps) attach_shadow_defineProperties(Constructor.prototype, protoProps); if (staticProps) attach_shadow_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n // Do not export this object. It must be passed as the first argument to the\n// ShadyRoot constructor in `attachShadow` to prevent the constructor from\n// throwing. This prevents the user from being able to manually construct a\n// ShadyRoot (i.e. `new ShadowRoot()`).\n\nvar ShadyRootConstructionToken = {};\nvar CATCHALL_NAME = '__catchall';\nvar SHADYROOT_NAME = 'ShadyRoot';\nvar MODE_CLOSED = 'closed';\nvar isRendering = settings['deferConnectionCallbacks'] && document.readyState === 'loading';\nvar rootRendered;\n\nfunction ancestorList(node) {\n  var ancestors = [];\n\n  do {\n    ancestors.unshift(node);\n  } while (node = node[SHADY_PREFIX + 'parentNode']);\n\n  return ancestors;\n}\n/**\n * @extends {ShadowRoot}\n */\n\n\nvar attach_shadow_ShadyRoot =\n/*#__PURE__*/\nfunction () {\n  function ShadyRoot(token, host, options) {\n    attach_shadow_classCallCheck(this, ShadyRoot);\n\n    if (token !== ShadyRootConstructionToken) {\n      throw new TypeError('Illegal constructor');\n    }\n    /** @type {boolean} */\n\n\n    this._renderPending;\n    /** @type {boolean} */\n\n    this._hasRendered;\n    /** @type {?Array<HTMLSlotElement>} */\n\n    this._slotList = null;\n    /** @type {?Object<string, Array<HTMLSlotElement>>} */\n\n    this._slotMap;\n    /** @type {?Array<HTMLSlotElement>} */\n\n    this._pendingSlots;\n\n    this._init(host, options);\n  }\n\n  attach_shadow_createClass(ShadyRoot, [{\n    key: \"_init\",\n    value: function _init(host, options) {\n      // NOTE: set a fake local name so this element can be\n      // distinguished from a DocumentFragment when patching.\n      // FF doesn't allow this to be `localName`\n\n      /** @type {string} */\n      this._localName = SHADYROOT_NAME; // root <=> host\n\n      this.host = host;\n      /** @type {!string|undefined} */\n\n      this.mode = options && options.mode;\n      link_nodes_recordChildNodes(this.host);\n      var hostData = ensureShadyDataForNode(this.host);\n      /** @type {!ShadyRoot} */\n\n      hostData.root = this;\n      hostData.publicRoot = this.mode !== MODE_CLOSED ? this : null; // setup root\n\n      var rootData = ensureShadyDataForNode(this);\n      rootData.firstChild = rootData.lastChild = rootData.parentNode = rootData.nextSibling = rootData.previousSibling = null; // NOTE: optimization flag, only require an asynchronous render\n      // to record parsed children if flag is not set.\n\n      if (settings['preferPerformance']) {\n        var n;\n\n        while (n = this.host[NATIVE_PREFIX + 'firstChild']) {\n          this.host[NATIVE_PREFIX + 'removeChild'](n);\n        }\n      } else {\n        this._asyncRender();\n      }\n    }\n  }, {\n    key: \"_asyncRender\",\n    value: function _asyncRender() {\n      var _this = this;\n\n      if (!this._renderPending) {\n        this._renderPending = true;\n        enqueue(function () {\n          return _this._render();\n        });\n      }\n    } // returns the oldest renderPending ancestor root.\n\n  }, {\n    key: \"_getPendingDistributionRoot\",\n    value: function _getPendingDistributionRoot() {\n      var renderRoot;\n      var root = this;\n\n      while (root) {\n        if (root._renderPending) {\n          renderRoot = root;\n        }\n\n        root = root._getDistributionParent();\n      }\n\n      return renderRoot;\n    } // Returns the shadyRoot `this.host` if `this.host`\n    // has children that require distribution.\n\n  }, {\n    key: \"_getDistributionParent\",\n    value: function _getDistributionParent() {\n      var root = this.host[SHADY_PREFIX + 'getRootNode']();\n\n      if (!utils_isShadyRoot(root)) {\n        return;\n      }\n\n      var nodeData = shadyDataForNode(this.host);\n\n      if (nodeData && nodeData.__childSlotCount > 0) {\n        return root;\n      }\n    } // Renders the top most render pending shadowRoot in the distribution tree.\n    // This is safe because when a distribution parent renders, all children render.\n\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      // If this root is not pending, it needs no rendering work. Any pending\n      // parent that needs to render wll cause this root to render.\n      var root = this._renderPending && this._getPendingDistributionRoot();\n\n      if (root) {\n        root._renderSelf();\n      }\n    }\n  }, {\n    key: \"_flushInitial\",\n    value: function _flushInitial() {\n      if (!this._hasRendered && this._renderPending) {\n        this._render();\n      }\n    }\n    /** @override */\n\n  }, {\n    key: \"_renderSelf\",\n    value: function _renderSelf() {\n      // track rendering state.\n      var wasRendering = isRendering;\n      isRendering = true;\n      this._renderPending = false;\n\n      if (this._slotList) {\n        this._distribute();\n\n        this._compose();\n      } // NOTE: optimization flag, only process parsed children\n      // if optimization flag is not set.\n      // on initial render remove any undistributed children.\n\n\n      if (!settings['preferPerformance'] && !this._hasRendered) {\n        for (var n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n          var data = shadyDataForNode(n);\n\n          if (n[NATIVE_PREFIX + 'parentNode'] === this.host && (n.localName === 'slot' || !data.assignedSlot)) {\n            this.host[NATIVE_PREFIX + 'removeChild'](n);\n          }\n        }\n      }\n\n      this._hasRendered = true;\n      isRendering = wasRendering;\n\n      if (rootRendered) {\n        rootRendered();\n      }\n    }\n  }, {\n    key: \"_distribute\",\n    value: function _distribute() {\n      this._validateSlots(); // capture # of previously assigned nodes to help determine if dirty.\n\n\n      for (var i = 0, slot; i < this._slotList.length; i++) {\n        slot = this._slotList[i];\n\n        this._clearSlotAssignedNodes(slot);\n      } // distribute host children.\n\n\n      for (var n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        this._distributeNodeToSlot(n);\n      } // fallback content, slotchange, and dirty roots\n\n\n      for (var _i = 0; _i < this._slotList.length; _i++) {\n        var _slot = this._slotList[_i];\n        var slotData = shadyDataForNode(_slot); // distribute fallback content\n\n        if (!slotData.assignedNodes.length) {\n          for (var _n = _slot[SHADY_PREFIX + 'firstChild']; _n; _n = _n[SHADY_PREFIX + 'nextSibling']) {\n            this._distributeNodeToSlot(_n, _slot);\n          }\n        }\n\n        var slotParentData = shadyDataForNode(_slot[SHADY_PREFIX + 'parentNode']);\n        var slotParentRoot = slotParentData && slotParentData.root;\n\n        if (slotParentRoot && (slotParentRoot._hasInsertionPoint() || slotParentRoot._renderPending)) {\n          slotParentRoot._renderSelf();\n        }\n\n        this._addAssignedToFlattenedNodes(slotData.flattenedNodes, slotData.assignedNodes);\n\n        var prevAssignedNodes = slotData._previouslyAssignedNodes;\n\n        if (prevAssignedNodes) {\n          for (var _i2 = 0; _i2 < prevAssignedNodes.length; _i2++) {\n            shadyDataForNode(prevAssignedNodes[_i2])._prevAssignedSlot = null;\n          }\n\n          slotData._previouslyAssignedNodes = null; // dirty if previously less assigned nodes than previously assigned.\n\n          if (prevAssignedNodes.length > slotData.assignedNodes.length) {\n            slotData.dirty = true;\n          }\n        }\n        /* Note: A slot is marked dirty whenever a node is newly assigned to it\n        or a node is assigned to a different slot (done in `_distributeNodeToSlot`)\n        or if the number of nodes assigned to the slot has decreased (done above);\n        */\n\n\n        if (slotData.dirty) {\n          slotData.dirty = false;\n\n          this._fireSlotChange(_slot);\n        }\n      }\n    }\n    /**\n     * Distributes given `node` to the appropriate slot based on its `slot`\n     * attribute. If `forcedSlot` is given, then the node is distributed to the\n     * `forcedSlot`.\n     * Note: slot to which the node is assigned will be marked dirty for firing\n     * `slotchange`.\n     * @param {Node} node\n     * @param {Node=} forcedSlot\n     *\n     */\n\n  }, {\n    key: \"_distributeNodeToSlot\",\n    value: function _distributeNodeToSlot(node, forcedSlot) {\n      var nodeData = ensureShadyDataForNode(node);\n      var oldSlot = nodeData._prevAssignedSlot;\n      nodeData._prevAssignedSlot = null;\n      var slot = forcedSlot;\n\n      if (!slot) {\n        var name = node[SHADY_PREFIX + 'slot'] || CATCHALL_NAME;\n        var list = this._slotMap[name];\n        slot = list && list[0];\n      }\n\n      if (slot) {\n        var slotData = ensureShadyDataForNode(slot);\n        slotData.assignedNodes.push(node);\n        nodeData.assignedSlot = slot;\n      } else {\n        nodeData.assignedSlot = undefined;\n      }\n\n      if (oldSlot !== nodeData.assignedSlot) {\n        if (nodeData.assignedSlot) {\n          ensureShadyDataForNode(nodeData.assignedSlot).dirty = true;\n        }\n      }\n    }\n    /**\n     * Clears the assignedNodes tracking data for a given `slot`. Note, the current\n     * assigned node data is tracked (via _previouslyAssignedNodes and\n     * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out\n     *  of date at this time because the assigned nodes may have already been\n     * distributed to another root. This is ok since this data is only used to\n     * track changes.\n     * @param {HTMLSlotElement} slot\n     */\n\n  }, {\n    key: \"_clearSlotAssignedNodes\",\n    value: function _clearSlotAssignedNodes(slot) {\n      var slotData = shadyDataForNode(slot);\n      var n$ = slotData.assignedNodes;\n      slotData.assignedNodes = [];\n      slotData.flattenedNodes = [];\n      slotData._previouslyAssignedNodes = n$;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var n = shadyDataForNode(n$[i]);\n          n._prevAssignedSlot = n.assignedSlot; // only clear if it was previously set to this slot;\n          // this helps ensure that if the node has otherwise been distributed\n          // ignore it.\n\n          if (n.assignedSlot === slot) {\n            n.assignedSlot = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addAssignedToFlattenedNodes\",\n    value: function _addAssignedToFlattenedNodes(flattened, assigned) {\n      for (var i = 0, n; i < assigned.length && (n = assigned[i]); i++) {\n        if (n.localName == 'slot') {\n          var nestedAssigned = shadyDataForNode(n).assignedNodes;\n\n          if (nestedAssigned && nestedAssigned.length) {\n            this._addAssignedToFlattenedNodes(flattened, nestedAssigned);\n          }\n        } else {\n          flattened.push(assigned[i]);\n        }\n      }\n    }\n  }, {\n    key: \"_fireSlotChange\",\n    value: function _fireSlotChange(slot) {\n      // NOTE: cannot bubble correctly here so not setting bubbles: true\n      // Safari tech preview does not bubble but chrome does\n      // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n      slot[NATIVE_PREFIX + 'dispatchEvent'](new Event('slotchange'));\n      var slotData = shadyDataForNode(slot);\n\n      if (slotData.assignedSlot) {\n        this._fireSlotChange(slotData.assignedSlot);\n      }\n    } // Reify dom such that it is at its correct rendering position\n    // based on logical distribution.\n    // NOTE: here we only compose parents of <slot> elements and not the\n    // shadowRoot into the host. The latter is performend via a fast path\n    // in the `logical-mutation`.insertBefore.\n\n  }, {\n    key: \"_compose\",\n    value: function _compose() {\n      var slots = this._slotList;\n      var composeList = [];\n\n      for (var i = 0; i < slots.length; i++) {\n        var parent = slots[i][SHADY_PREFIX + 'parentNode'];\n        /* compose node only if:\n          (1) parent does not have a shadowRoot since shadowRoot has already\n          composed into the host\n          (2) we're not already composing it\n          [consider (n^2) but rare better than Set]\n        */\n\n        var parentData = shadyDataForNode(parent);\n\n        if (!(parentData && parentData.root) && composeList.indexOf(parent) < 0) {\n          composeList.push(parent);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < composeList.length; _i3++) {\n        var node = composeList[_i3];\n        var targetNode = node === this ? this.host : node;\n\n        this._updateChildNodes(targetNode, this._composeNode(node));\n      }\n    } // Returns the list of nodes which should be rendered inside `node`.\n\n  }, {\n    key: \"_composeNode\",\n    value: function _composeNode(node) {\n      var children = [];\n\n      for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        // Note: if we see a slot here, the nodes are guaranteed to need to be\n        // composed here. This is because if there is redistribution, it has\n        // already been handled by this point.\n        if (this._isInsertionPoint(n)) {\n          var flattenedNodes = shadyDataForNode(n).flattenedNodes;\n\n          for (var j = 0; j < flattenedNodes.length; j++) {\n            var distributedNode = flattenedNodes[j];\n            children.push(distributedNode);\n          }\n        } else {\n          children.push(n);\n        }\n      }\n\n      return children;\n    }\n  }, {\n    key: \"_isInsertionPoint\",\n    value: function _isInsertionPoint(node) {\n      return node.localName == 'slot';\n    } // Ensures that the rendered node list inside `container` is `children`.\n\n  }, {\n    key: \"_updateChildNodes\",\n    value: function _updateChildNodes(container, children) {\n      var composed = nativeChildNodesArray(container);\n      var splices = calculateSplices(children, composed); // process removals\n\n      for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\n        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n          // check if the node is still where we expect it is before trying\n          // to remove it; this can happen if we move a node and\n          // then schedule its previous host for distribution resulting in\n          // the node being removed here.\n          if (n[NATIVE_PREFIX + 'parentNode'] === container) {\n            container[NATIVE_PREFIX + 'removeChild'](n);\n          } // TODO(sorvell): avoid the need for splicing here.\n\n\n          composed.splice(s.index + d, 1);\n        }\n\n        d -= s.addedCount;\n      } // process adds\n\n\n      for (var _i4 = 0, _s, next; _i4 < splices.length && (_s = splices[_i4]); _i4++) {\n        //eslint-disable-line no-redeclare\n        next = composed[_s.index];\n\n        for (var _j = _s.index, _n2; _j < _s.index + _s.addedCount; _j++) {\n          _n2 = children[_j];\n          container[NATIVE_PREFIX + 'insertBefore'](_n2, next);\n          composed.splice(_j, 0, _n2);\n        }\n      }\n    }\n  }, {\n    key: \"_ensureSlotData\",\n    value: function _ensureSlotData() {\n      this._pendingSlots = this._pendingSlots || [];\n      this._slotList = this._slotList || [];\n      this._slotMap = this._slotMap || {};\n    }\n  }, {\n    key: \"_addSlots\",\n    value: function _addSlots(slots) {\n      var _this$_pendingSlots;\n\n      this._ensureSlotData();\n\n      (_this$_pendingSlots = this._pendingSlots).push.apply(_this$_pendingSlots, _toConsumableArray(slots));\n    }\n  }, {\n    key: \"_validateSlots\",\n    value: function _validateSlots() {\n      if (this._pendingSlots && this._pendingSlots.length) {\n        this._mapSlots(this._pendingSlots);\n\n        this._pendingSlots = [];\n      }\n    }\n    /**\n     * Adds the given slots. Slots are maintained in an dom-ordered list.\n     * In addition a map of name to slot is updated.\n     */\n\n  }, {\n    key: \"_mapSlots\",\n    value: function _mapSlots(slots) {\n      var slotNamesToSort;\n\n      for (var i = 0; i < slots.length; i++) {\n        var slot = slots[i]; // ensure insertionPoints's and their parents have logical dom info.\n        // save logical tree info\n        // a. for shadyRoot\n        // b. for insertion points (fallback)\n        // c. for parents of insertion points\n\n        link_nodes_recordChildNodes(slot);\n        var slotParent = slot[SHADY_PREFIX + 'parentNode'];\n        link_nodes_recordChildNodes(slotParent);\n        var slotParentData = shadyDataForNode(slotParent);\n        slotParentData.__childSlotCount = (slotParentData.__childSlotCount || 0) + 1;\n\n        var name = this._nameForSlot(slot);\n\n        if (this._slotMap[name]) {\n          slotNamesToSort = slotNamesToSort || {};\n          slotNamesToSort[name] = true;\n\n          this._slotMap[name].push(slot);\n        } else {\n          this._slotMap[name] = [slot];\n        }\n\n        this._slotList.push(slot);\n      }\n\n      if (slotNamesToSort) {\n        for (var n in slotNamesToSort) {\n          this._slotMap[n] = this._sortSlots(this._slotMap[n]);\n        }\n      }\n    }\n  }, {\n    key: \"_nameForSlot\",\n    value: function _nameForSlot(slot) {\n      var name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;\n      slot.__slotName = name;\n      return name;\n    }\n    /**\n     * Slots are kept in an ordered list. Slots with the same name\n     * are sorted here by tree order.\n     */\n\n  }, {\n    key: \"_sortSlots\",\n    value: function _sortSlots(slots) {\n      // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,\n      // but the code here could be used to polyfill the preceeding/following info\n      // in `compareDocumentPosition`.\n      return slots.sort(function (a, b) {\n        var listA = ancestorList(a);\n        var listB = ancestorList(b);\n\n        for (var i = 0; i < listA.length; i++) {\n          var nA = listA[i];\n          var nB = listB[i];\n\n          if (nA !== nB) {\n            var c$ = childNodesArray(nA[SHADY_PREFIX + 'parentNode']);\n            return c$.indexOf(nA) - c$.indexOf(nB);\n          }\n        }\n      });\n    }\n    /**\n     * Removes from tracked slot data any slots contained within `container` and\n     * then updates the tracked data (_slotList and _slotMap).\n     * Any removed slots also have their `assignedNodes` removed from comopsed dom.\n     */\n\n  }, {\n    key: \"_removeContainedSlots\",\n    value: function _removeContainedSlots(container) {\n      if (!this._slotList) {\n        return;\n      }\n\n      this._validateSlots();\n\n      var didRemove;\n      var map = this._slotMap;\n\n      for (var n in map) {\n        var slots = map[n];\n\n        for (var i = 0; i < slots.length; i++) {\n          var slot = slots[i];\n\n          if (utils_contains(container, slot)) {\n            slots.splice(i, 1);\n\n            var x = this._slotList.indexOf(slot);\n\n            if (x >= 0) {\n              this._slotList.splice(x, 1);\n\n              var slotParentData = shadyDataForNode(slot[SHADY_PREFIX + 'parentNode']);\n\n              if (slotParentData && slotParentData.__childSlotCount) {\n                slotParentData.__childSlotCount--;\n              }\n            }\n\n            i--;\n\n            this._removeFlattenedNodes(slot);\n\n            didRemove = true;\n          }\n        }\n      }\n\n      return didRemove;\n    }\n  }, {\n    key: \"_updateSlotName\",\n    value: function _updateSlotName(slot) {\n      if (!this._slotList) {\n        return;\n      } // make sure slotMap is initialized with this slot\n\n\n      this._validateSlots();\n\n      var oldName = slot.__slotName;\n\n      var name = this._nameForSlot(slot);\n\n      if (name === oldName) {\n        return;\n      } // remove from existing tracking\n\n\n      var slots = this._slotMap[oldName];\n      var i = slots.indexOf(slot);\n\n      if (i >= 0) {\n        slots.splice(i, 1);\n      } // add to new location and sort if nedessary\n\n\n      var list = this._slotMap[name] || (this._slotMap[name] = []);\n      list.push(slot);\n\n      if (list.length > 1) {\n        this._slotMap[name] = this._sortSlots(list);\n      }\n    }\n  }, {\n    key: \"_removeFlattenedNodes\",\n    value: function _removeFlattenedNodes(slot) {\n      var data = shadyDataForNode(slot);\n      var n$ = data.flattenedNodes;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var node = n$[i];\n          var parent = node[NATIVE_PREFIX + 'parentNode'];\n\n          if (parent) {\n            parent[NATIVE_PREFIX + 'removeChild'](node);\n          }\n        }\n      }\n\n      data.flattenedNodes = [];\n      data.assignedNodes = [];\n    }\n  }, {\n    key: \"_hasInsertionPoint\",\n    value: function _hasInsertionPoint() {\n      this._validateSlots();\n\n      return Boolean(this._slotList && this._slotList.length);\n    }\n  }]);\n\n  return ShadyRoot;\n}();\n\npatch_shadyRoot_patchShadyRoot(attach_shadow_ShadyRoot.prototype);\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\n\nvar attach_shadow_attachShadow = function attachShadow(host, options) {\n  if (!host) {\n    throw new Error('Must provide a host.');\n  }\n\n  if (!options) {\n    throw new Error('Not enough arguments.');\n  }\n\n  var root; // Optimization for booting up a shadowRoot from a fragment rather than\n  // creating one.\n\n  if (options['shadyUpgradeFragment'] && canUpgrade()) {\n    root = options['shadyUpgradeFragment'];\n    root.__proto__ = ShadowRoot.prototype;\n\n    root._init(host, options);\n\n    link_nodes_recordChildNodes(root, root); // Note: qsa is native when used with noPatch.\n\n    /** @type {?NodeList<Element>} */\n\n    var slotsAdded = root['__noInsertionPoint'] ? null : root.querySelectorAll('slot'); // Reset scoping information so normal scoing rules apply after this.\n\n    root['__noInsertionPoint'] = undefined; // if a slot is added, must render containing root.\n\n    if (slotsAdded && slotsAdded.length) {\n      root._addSlots(slotsAdded);\n\n      root._asyncRender();\n    }\n    /** @type {ShadowRoot} */\n\n\n    root.host[NATIVE_PREFIX + 'appendChild'](root);\n  } else {\n    root = new attach_shadow_ShadyRoot(ShadyRootConstructionToken, host, options);\n  }\n\n  return root;\n}; // Mitigate connect/disconnect spam by wrapping custom element classes.\n\nif (window['customElements'] && settings.inUse && !settings['preferPerformance']) {\n  // process connect/disconnect after roots have rendered to avoid\n  // issues with reaction stack.\n  var connectMap = new Map();\n\n  rootRendered = function rootRendered() {\n    // allow elements to connect\n    // save map state (without needing polyfills on IE11)\n    var r = [];\n    connectMap.forEach(function (v, k) {\n      r.push([k, v]);\n    });\n    connectMap.clear();\n\n    for (var i = 0; i < r.length; i++) {\n      var e = r[i][0],\n          value = r[i][1];\n\n      if (value) {\n        e['__shadydom_connectedCallback']();\n      } else {\n        e['__shadydom_disconnectedCallback']();\n      }\n    }\n  }; // Document is in loading state and flag is set (deferConnectionCallbacks)\n  // so process connection stack when `readystatechange` fires.\n\n\n  if (isRendering) {\n    document.addEventListener('readystatechange', function () {\n      isRendering = false;\n      rootRendered();\n    }, {\n      once: true\n    });\n  }\n  /*\n   * (1) elements can only be connected/disconnected if they are in the expected\n   * state.\n   * (2) never run connect/disconnect during rendering to avoid reaction stack issues.\n   */\n\n\n  var ManageConnect = function ManageConnect(base, connected, disconnected) {\n    var counter = 0;\n    var connectFlag = \"__isConnected\".concat(counter++);\n\n    if (connected || disconnected) {\n      /** @this {!HTMLElement} */\n      base.prototype.connectedCallback = base.prototype['__shadydom_connectedCallback'] = function () {\n        // if rendering defer connected\n        // otherwise connect only if we haven't already\n        if (isRendering) {\n          connectMap.set(this, true);\n        } else if (!this[connectFlag]) {\n          this[connectFlag] = true;\n\n          if (connected) {\n            connected.call(this);\n          }\n        }\n      };\n      /** @this {!HTMLElement} */\n\n\n      base.prototype.disconnectedCallback = base.prototype['__shadydom_disconnectedCallback'] = function () {\n        // if rendering, cancel a pending connection and queue disconnect,\n        // otherwise disconnect only if a connection has been allowed\n        if (isRendering) {\n          // This is necessary only because calling removeChild\n          // on a node that requires distribution leaves it in the DOM tree\n          // until distribution.\n          // NOTE: remember this is checking the patched isConnected to determine\n          // if the node is in the logical tree.\n          if (!this.isConnected) {\n            connectMap.set(this, false);\n          }\n        } else if (this[connectFlag]) {\n          this[connectFlag] = false;\n\n          if (disconnected) {\n            disconnected.call(this);\n          }\n        }\n      };\n    }\n\n    return base;\n  };\n\n  var originalDefine = window['customElements']['define'];\n\n  var define = function define(name, constructor) {\n    var connected = constructor.prototype.connectedCallback;\n    var disconnected = constructor.prototype.disconnectedCallback;\n    originalDefine.call(window['customElements'], name, ManageConnect(constructor, connected, disconnected)); // unpatch connected/disconnected on class; custom elements tears this off\n    // so the patch is maintained, but if the user calls these methods for\n    // e.g. testing, they will be as expected.\n\n    constructor.prototype.connectedCallback = connected;\n    constructor.prototype.disconnectedCallback = disconnected;\n  }; // Note, it would be better to only patch the CustomElementRegistry.prototype,\n  // but ShadyCSS patches define directly.\n\n\n  window.customElements.define = define; // Still patch the registry directly since Safari 10 loses the patch\n  // unless this is done.\n\n  Object.defineProperty(window['CustomElementRegistry'].prototype, 'define', {\n    value: define,\n    configurable: true\n  });\n}\n/** @return {!ShadyRoot|undefined} */\n\n\nvar attach_shadow_ownerShadyRootForNode = function ownerShadyRootForNode(node) {\n  var root = node[SHADY_PREFIX + 'getRootNode']();\n\n  if (utils_isShadyRoot(root)) {\n    return root;\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/wrapper.js\nfunction wrapper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction wrapper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction wrapper_createClass(Constructor, protoProps, staticProps) { if (protoProps) wrapper_defineProperties(Constructor.prototype, protoProps); if (staticProps) wrapper_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/** @implements {IWrapper} */\n\nvar wrapper_Wrapper =\n/*#__PURE__*/\nfunction () {\n  /** @param {!Node} node */\n  function Wrapper(node) {\n    wrapper_classCallCheck(this, Wrapper);\n\n    this.node = node;\n  } // node\n\n\n  wrapper_createClass(Wrapper, [{\n    key: \"addEventListener\",\n    value: function addEventListener(name, fn, options) {\n      return this.node[SHADY_PREFIX + 'addEventListener'](name, fn, options);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name, fn, options) {\n      return this.node[SHADY_PREFIX + 'removeEventListener'](name, fn, options);\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.node[SHADY_PREFIX + 'appendChild'](node);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref_node) {\n      return this.node[SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      return this.node[SHADY_PREFIX + 'removeChild'](node);\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(node, ref_node) {\n      return this.node[SHADY_PREFIX + 'replaceChild'](node, ref_node);\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      return this.node[SHADY_PREFIX + 'cloneNode'](deep);\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode(options) {\n      return this.node[SHADY_PREFIX + 'getRootNode'](options);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      return this.node[SHADY_PREFIX + 'contains'](node);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      return this.node[SHADY_PREFIX + 'dispatchEvent'](event);\n    } // element\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      this.node[SHADY_PREFIX + 'setAttribute'](name, value);\n    } // NOTE: not needed, just here for balance\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      return this.node[NATIVE_PREFIX + 'getAttribute'](name);\n    } // NOTE: not needed, just here for balance\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(name) {\n      return this.node[NATIVE_PREFIX + 'hasAttribute'](name);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      this.node[SHADY_PREFIX + 'removeAttribute'](name);\n    }\n  }, {\n    key: \"attachShadow\",\n    value: function attachShadow(options) {\n      return this.node[SHADY_PREFIX + 'attachShadow'](options);\n    }\n    /** @return {!Node|undefined} */\n\n  }, {\n    key: \"focus\",\n    // NOTE: not needed, just here for balance\n\n    /** @override */\n    value: function focus() {\n      this.node[NATIVE_PREFIX + 'focus']();\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.node[SHADY_PREFIX + 'blur']();\n    } // document\n\n  }, {\n    key: \"importNode\",\n    value: function importNode(node, deep) {\n      if (this.node.nodeType === Node.DOCUMENT_NODE) {\n        return this.node[SHADY_PREFIX + 'importNode'](node, deep);\n      }\n    }\n  }, {\n    key: \"getElementById\",\n    value: function getElementById(id) {\n      if (this.node.nodeType === Node.DOCUMENT_NODE) {\n        return this.node[SHADY_PREFIX + 'getElementById'](id);\n      }\n    } // query\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return this.node[SHADY_PREFIX + 'querySelector'](selector);\n    }\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector, useNative) {\n      return this.node[SHADY_PREFIX + 'querySelectorAll'](selector, useNative);\n    } // slot\n\n  }, {\n    key: \"assignedNodes\",\n    value: function assignedNodes(options) {\n      if (this.node.localName === 'slot') {\n        return this.node[SHADY_PREFIX + 'assignedNodes'](options);\n      }\n    }\n  }, {\n    key: \"activeElement\",\n    get: function get() {\n      if (utils_isShadyRoot(this.node) || this.node.nodeType === Node.DOCUMENT_NODE) {\n        var e = this.node[SHADY_PREFIX + 'activeElement'];\n        return e;\n      }\n    }\n    /**\n     * Installed for compatibility with browsers (older Chrome/Safari) that do\n     * not have a configurable `activeElement` accessor. Enables noPatch and\n     * patch mode both to consistently use ShadyDOM.wrap(document)._activeElement.\n     * @override\n     * @return {!Node|undefined}\n     */\n\n  }, {\n    key: \"_activeElement\",\n    get: function get() {\n      return this.activeElement;\n    }\n  }, {\n    key: \"host\",\n    get: function get() {\n      if (utils_isShadyRoot(this.node)) {\n        return (\n          /** @type {!ShadowRoot} */\n          this.node.host\n        );\n      }\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'parentNode'];\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'firstChild'];\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'lastChild'];\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'nextSibling'];\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'previousSibling'];\n    }\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'childNodes'];\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'parentElement'];\n    }\n  }, {\n    key: \"firstElementChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'firstElementChild'];\n    }\n  }, {\n    key: \"lastElementChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'lastElementChild'];\n    }\n  }, {\n    key: \"nextElementSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'nextElementSibling'];\n    }\n  }, {\n    key: \"previousElementSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'previousElementSibling'];\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'children'];\n    }\n  }, {\n    key: \"childElementCount\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'childElementCount'];\n    }\n  }, {\n    key: \"shadowRoot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'shadowRoot'];\n    }\n  }, {\n    key: \"assignedSlot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'assignedSlot'];\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'isConnected'];\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'innerHTML'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'innerHTML'] = value;\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'textContent'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'textContent'] = value;\n    }\n  }, {\n    key: \"slot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'slot'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'slot'] = value;\n    }\n  }, {\n    key: \"className\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'className'];\n    },\n    set: function set(value) {\n      return this.node[SHADY_PREFIX + 'className'] = value;\n    }\n  }]);\n\n  return Wrapper;\n}();\n\neventPropertyNames.forEach(function (name) {\n  Object.defineProperty(wrapper_Wrapper.prototype, name, {\n    /** @this {Wrapper} */\n    get: function get() {\n      return this.node[SHADY_PREFIX + name];\n    },\n\n    /** @this {Wrapper} */\n    set: function set(value) {\n      this.node[SHADY_PREFIX + name] = value;\n    },\n    configurable: true\n  });\n});\n\nvar wrapperMap = new WeakMap();\nfunction wrap(obj) {\n  if (utils_isShadyRoot(obj) || obj instanceof wrapper_Wrapper) {\n    return obj;\n  }\n\n  var wrapper = wrapperMap.get(obj);\n\n  if (!wrapper) {\n    wrapper = new wrapper_Wrapper(obj);\n    wrapperMap.set(obj, wrapper);\n  }\n\n  return wrapper;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/EventTarget.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar EventTargetPatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  dispatchEvent: function dispatchEvent(event) {\n    flush();\n    return this[NATIVE_PREFIX + 'dispatchEvent'](event);\n  },\n  addEventListener: patch_events_addEventListener,\n  removeEventListener: patch_events_removeEventListener\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slotable.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar SlotablePatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get assignedSlot() {\n    // Force any parent's shadowRoot to flush so that distribution occurs\n    // and this node has an assignedSlot.\n    var parent = this[SHADY_PREFIX + 'parentNode'];\n    var ownerRoot = parent && parent[SHADY_PREFIX + 'shadowRoot'];\n\n    if (ownerRoot) {\n      ownerRoot._render();\n    }\n\n    var nodeData = shadyDataForNode(this);\n    return nodeData && nodeData.assignedSlot || null;\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Element.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\nvar Element_doc = window.document;\n/**\n * Should be called whenever an attribute changes. If the `slot` attribute\n * changes, provokes rendering if necessary. If a `<slot>` element's `name`\n * attribute changes, updates the root's slot map and renders.\n * @param {Node} node\n * @param {string} name\n */\n\nfunction distributeAttributeChange(node, name) {\n  if (name === 'slot') {\n    var parent = node[SHADY_PREFIX + 'parentNode'];\n\n    if (utils_hasShadowRootWithSlot(parent)) {\n      shadyDataForNode(parent).root._asyncRender();\n    }\n  } else if (node.localName === 'slot' && name === 'name') {\n    var root = attach_shadow_ownerShadyRootForNode(node);\n\n    if (root) {\n      root._updateSlotName(node);\n\n      root._asyncRender();\n    }\n  }\n}\n\nvar ElementPatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get previousElementSibling() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.previousSibling !== undefined) {\n      var n = this[SHADY_PREFIX + 'previousSibling'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'previousSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'previousElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get nextElementSibling() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.nextSibling !== undefined) {\n      var n = this[SHADY_PREFIX + 'nextSibling'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'nextSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'nextElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get slot() {\n    return this.getAttribute('slot');\n  },\n\n  /** @this {Element} */\n  set slot(value) {\n    this[SHADY_PREFIX + 'setAttribute']('slot', value);\n  },\n\n  // Note: Can be patched on element prototype on all browsers.\n  // Must be patched on instance on browsers that support native Shadow DOM\n  // but do not have builtin accessors (old Chrome).\n\n  /** @this {Element} */\n  get shadowRoot() {\n    var nodeData = shadyDataForNode(this);\n    return nodeData && nodeData.publicRoot || null;\n  },\n\n  /** @this {Element} */\n  get className() {\n    return this.getAttribute('class') || '';\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set className(value) {\n    this[SHADY_PREFIX + 'setAttribute']('class', value);\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   * @param {string} value\n   */\n  setAttribute: function setAttribute(attr, value) {\n    if (this.ownerDocument !== Element_doc) {\n      this[NATIVE_PREFIX + 'setAttribute'](attr, value);\n    } else if (!scopeClassAttribute(this, attr, value)) {\n      this[NATIVE_PREFIX + 'setAttribute'](attr, value);\n      distributeAttributeChange(this, attr);\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   */\n  removeAttribute: function removeAttribute(attr) {\n    this[NATIVE_PREFIX + 'removeAttribute'](attr);\n    distributeAttributeChange(this, attr);\n  },\n\n  /**\n   * @this {Element}\n   * @param {!{mode: string}} options\n   */\n  attachShadow: function attachShadow(options) {\n    return attach_shadow_attachShadow(this, options);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/HTMLElement.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar HTMLElementPatches = getOwnPropertyDescriptors({\n  /** @this {HTMLElement} */\n  blur: function blur() {\n    var nodeData = shadyDataForNode(this);\n    var root = nodeData && nodeData.root;\n    var shadowActive = root && root.activeElement;\n\n    if (shadowActive) {\n      shadowActive[SHADY_PREFIX + 'blur']();\n    } else {\n      this[NATIVE_PREFIX + 'blur']();\n    }\n  }\n});\neventPropertyNames.forEach(function (property) {\n  HTMLElementPatches[property] = {\n    /** @this {HTMLElement} */\n    set: function set(fn) {\n      var shadyData = ensureShadyDataForNode(this);\n      var eventName = property.substring(2);\n\n      if (!shadyData.__onCallbackListeners) {\n        shadyData.__onCallbackListeners = {};\n      }\n\n      shadyData.__onCallbackListeners[property] && this.removeEventListener(eventName, shadyData.__onCallbackListeners[property]);\n      this[SHADY_PREFIX + 'addEventListener'](eventName, fn);\n      shadyData.__onCallbackListeners[property] = fn;\n    },\n\n    /** @this {HTMLElement} */\n    get: function get() {\n      var shadyData = shadyDataForNode(this);\n      return shadyData && shadyData.__onCallbackListeners && shadyData.__onCallbackListeners[property];\n    },\n    configurable: true\n  };\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slot.js\nfunction Slot_typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { Slot_typeof = function _typeof(obj) { return typeof obj; }; } else { Slot_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return Slot_typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar SlotPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {HTMLSlotElement}\n   * @param {Object=} options\n   */\n  assignedNodes: function assignedNodes(options) {\n    if (this.localName === 'slot') {\n      // Force any containing shadowRoot to flush so that distribution occurs\n      // and this node has assignedNodes.\n      var root = this[SHADY_PREFIX + 'getRootNode']();\n\n      if (root && utils_isShadyRoot(root)) {\n        root._render();\n      }\n\n      var nodeData = shadyDataForNode(this);\n      return nodeData ? (options && options.flatten ? nodeData.flattenedNodes : nodeData.assignedNodes) || [] : [];\n    }\n  },\n\n  /**\n   * @this {HTMLSlotElement}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener: function addEventListener(type, fn, optionsOrCapture) {\n    // NOTE, check if this is a `slot` because these patches are installed on\n    // Element where browsers don't have `<slot>`\n    if (this.localName !== 'slot' || type === 'slotchange') {\n      patch_events_addEventListener.call(this, type, fn, optionsOrCapture);\n    } else {\n      if (Slot_typeof(optionsOrCapture) !== 'object') {\n        optionsOrCapture = {\n          capture: Boolean(optionsOrCapture)\n        };\n      }\n\n      var parent = this[SHADY_PREFIX + 'parentNode'];\n\n      if (!parent) {\n        throw new Error('ShadyDOM cannot attach event to slot unless it has a `parentNode`');\n      }\n\n      optionsOrCapture.__shadyTarget = this;\n      parent[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);\n    }\n  },\n\n  /**\n   * @this {HTMLSlotElement}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener: function removeEventListener(type, fn, optionsOrCapture) {\n    // NOTE, check if this is a `slot` because these patches are installed on\n    // Element where browsers don't have `<slot>`\n    if (this.localName !== 'slot' || type === 'slotchange') {\n      patch_events_removeEventListener.call(this, type, fn, optionsOrCapture);\n    } else {\n      if (Slot_typeof(optionsOrCapture) !== 'object') {\n        optionsOrCapture = {\n          capture: Boolean(optionsOrCapture)\n        };\n      }\n\n      var parent = this[SHADY_PREFIX + 'parentNode'];\n\n      if (!parent) {\n        throw new Error('ShadyDOM cannot attach event to slot unless it has a `parentNode`');\n      }\n\n      optionsOrCapture.__shadyTarget = this;\n      parent[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Document.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar Document_doc = window.document;\nvar DocumentPatches = getOwnPropertyDescriptors({\n  // note: Though not technically correct, we fast path `importNode`\n  // when called on a node not owned by the main document.\n  // This allows, for example, elements that cannot\n  // contain custom elements and are therefore not likely to contain shadowRoots\n  // to cloned natively. This is a fairly significant performance win.\n\n  /**\n   * @this {Document}\n   * @param {Node} node\n   * @param {boolean} deep\n   */\n  importNode: function importNode(node, deep) {\n    // A template element normally has no children with shadowRoots, so make\n    // sure we always make a deep copy to correctly construct the template.content\n    if (node.ownerDocument !== Document_doc || node.localName === 'template') {\n      return this[NATIVE_PREFIX + 'importNode'](node, deep);\n    }\n\n    var n = this[NATIVE_PREFIX + 'importNode'](node, false);\n\n    if (deep) {\n      for (var c = node[SHADY_PREFIX + 'firstChild'], nc; c; c = c[SHADY_PREFIX + 'nextSibling']) {\n        nc = this[SHADY_PREFIX + 'importNode'](c, true);\n        n[SHADY_PREFIX + 'appendChild'](nc);\n      }\n    }\n\n    return n;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Window.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar WindowPatches = getOwnPropertyDescriptors({\n  // NOTE: ensure these methods are bound to `window` so that `this` is correct\n  // when called directly from global context without a receiver; e.g.\n  // `addEventListener(...)`.\n  addEventListener: patch_events_addEventListener.bind(window),\n  removeEventListener: patch_events_removeEventListener.bind(window)\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-prototypes.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n // Some browsers (IE/Edge) have non-standard HTMLElement accessors.\n\nvar NonStandardHTMLElement = {};\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement')) {\n  NonStandardHTMLElement.parentElement = NodePatches.parentElement;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'contains')) {\n  NonStandardHTMLElement.contains = NodePatches.contains;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'children')) {\n  NonStandardHTMLElement.children = ParentNodePatches.children;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML')) {\n  NonStandardHTMLElement.innerHTML = ElementOrShadowRootPatches.innerHTML;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'className')) {\n  NonStandardHTMLElement.className = ElementPatches.className;\n} // Avoid patching `innerHTML` if it does not exist on Element (IE)\n// and we can patch accessors (hasDescriptors).\n\n\nvar ElementShouldHaveInnerHTML = !settings.hasDescriptors || 'innerHTML' in Element.prototype; // setup patching\n\nvar patchMap = {\n  EventTarget: [EventTargetPatches],\n  Node: [NodePatches, !window.EventTarget ? EventTargetPatches : null],\n  Text: [SlotablePatches],\n  Element: [ElementPatches, ParentNodePatches, SlotablePatches, ElementShouldHaveInnerHTML ? ElementOrShadowRootPatches : null, !window.HTMLSlotElement ? SlotPatches : null],\n  HTMLElement: [HTMLElementPatches, NonStandardHTMLElement],\n  HTMLSlotElement: [SlotPatches],\n  DocumentFragment: [ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches],\n  Document: [DocumentPatches, ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches, DocumentOrShadowRootPatches],\n  Window: [WindowPatches]\n};\n\nvar getPatchPrototype = function getPatchPrototype(name) {\n  return window[name] && window[name].prototype;\n}; // Note, must avoid patching accessors on prototypes when descriptors are not correct\n// because the CustomElements polyfill checks if these exist before patching instances.\n// CustomElements polyfill *only* cares about these accessors.\n\n\nvar disallowedNativePatches = settings.hasDescriptors ? null : ['innerHTML', 'textContent'];\n/** @param {string=} prefix */\n\nvar patch_prototypes_applyPatches = function applyPatches(prefix) {\n  var disallowed = prefix ? null : disallowedNativePatches;\n\n  var _loop = function _loop(p) {\n    var proto = getPatchPrototype(p);\n    patchMap[p].forEach(function (patch) {\n      return proto && patch && patchProperties(proto, patch, prefix, disallowed);\n    });\n  };\n\n  for (var p in patchMap) {\n    _loop(p);\n  }\n};\nvar patch_prototypes_addShadyPrefixedProperties = function addShadyPrefixedProperties() {\n  // perform shady patches\n  patch_prototypes_applyPatches(SHADY_PREFIX); // install `_activeElement` because some browsers (older Chrome/Safari) do not have\n  // a 'configurable' `activeElement` accesssor.\n\n  var descriptor = DocumentOrShadowRootPatches.activeElement;\n  Object.defineProperty(document, '_activeElement', descriptor); // On Window, we're patching `addEventListener` which is a weird auto-bound\n  // property that is not directly on the Window prototype.\n\n  patchProperties(Window.prototype, WindowPatches, SHADY_PREFIX);\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shadydom.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\n\n\n\n\n\n\n\n\n\nif (settings.inUse) {\n  var ShadyDOM = {\n    // TODO(sorvell): remove when Polymer does not depend on this.\n    'inUse': settings.inUse,\n    // NOTE: old browsers without prototype accessors (very old Chrome\n    // and Safari) need manually patched accessors to properly set\n    // `innerHTML` and `textContent` when an element is:\n    // (1) inside a shadowRoot\n    // (2) does not have special (slot) children itself\n    // (3) and setting the property needs to provoke distribution (because\n    // a nested slot is added/removed)\n    'patch': function patch(node) {\n      patchInsideElementAccessors(node);\n      patchOutsideElementAccessors(node);\n      return node;\n    },\n    'isShadyRoot': utils_isShadyRoot,\n    'enqueue': enqueue,\n    'flush': flush,\n    'flushInitial': function flushInitial(root) {\n      root._flushInitial();\n    },\n    'settings': settings,\n    'filterMutations': filterMutations,\n    'observeChildren': observe_changes_observeChildren,\n    'unobserveChildren': observe_changes_unobserveChildren,\n    // Set to true to defer native custom elements connection until the\n    // document has fully parsed. This enables custom elements that create\n    // shadowRoots to be defined while the document is loading. Elements\n    // customized as they are created by the parser will successfully\n    // render with this flag on.\n    'deferConnectionCallbacks': settings['deferConnectionCallbacks'],\n    // Set to true to speed up the polyfill slightly at the cost of correctness\n    // * does not patch querySelector/All on Document or DocumentFragment\n    // * does not wrap connected/disconnected callbacks to de-dup these\n    // when using native customElements\n    // * does not wait to process children of elements with shadowRoots\n    // meaning shadowRoots should not be created while an element is parsing\n    // (e.g. if a custom element that creates a shadowRoot is defined before\n    // a candidate element in the document below it.\n    'preferPerformance': settings['preferPerformance'],\n    // Integration point with ShadyCSS to disable styling MutationObserver,\n    // as ShadyDOM will now handle dynamic scoping.\n    'handlesDynamicScoping': true,\n    'wrap': settings.noPatch ? wrap : function (n) {\n      return n;\n    },\n    'Wrapper': wrapper_Wrapper,\n    'composedPath': patch_events_composedPath,\n    // Set to true to avoid patching regular platform property names. When set,\n    // Shadow DOM compatible behavior is only available when accessing DOM\n    // API using `ShadyDOM.wrap`, e.g. `ShadyDOM.wrap(element).shadowRoot`.\n    // This setting provides a small performance boost, but requires all DOM API\n    // access that requires Shadow DOM behavior to be proxied via `ShadyDOM.wrap`.\n    'noPatch': settings.noPatch,\n    'nativeMethods': nativeMethods,\n    'nativeTree': nativeTree\n  };\n  window['ShadyDOM'] = ShadyDOM; // Modifies native prototypes for Node, Element, etc. to\n  // make native platform behavior available at prefixed names, e.g.\n  // `utils.NATIVE_PREFIX + 'firstChild'` or `__shady_native_firstChild`.\n  // This allows the standard names to be safely patched while retaining the\n  // ability for native behavior to be used. This polyfill manipulates DOM\n  // by using this saved native behavior.\n  // Note, some browsers do not have proper element descriptors for\n  // accessors; in this case, native behavior for these accessors is simulated\n  // via a TreeWalker.\n\n  patch_native_addNativePrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to make ShadowDOM\n  // behavior available at prefixed names, e.g.\n  // `utils.SHADY_PREFIX + 'firstChild` or `__shady_firstChild`. This is done\n  // so this polyfill can perform Shadow DOM style DOM manipulation.\n  // Because patching normal platform property names is optional, these prefixed\n  // names are used internally.\n\n  patch_prototypes_addShadyPrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to patch\n  // regular platform property names to have Shadow DOM compatible API behavior.\n  // This applies the utils.SHADY_PREFIX behavior to normal names. For example,\n  // if `noPatch` is not set, then `el.__shady_firstChild` is equivalent to\n  // `el.firstChild`.\n  // NOTE, on older browsers (old Chrome/Safari) native accessors cannot be\n  // patched on prototypes (e.g. Node.prototype.firstChild cannot be modified).\n  // On these browsers, instance level patching is performed where needed; this\n  // instance patching is only done when `noPatch` is *not* set.\n\n  if (!settings.noPatch) {\n    patch_prototypes_applyPatches(); // Patch click event behavior only if we're patching\n\n    patchClick();\n  } // For simplicity, patch events unconditionally.\n  // Patches the event system to have Shadow DOM compatible behavior (e.g.\n  // event retargeting). When `noPatch` is set, retargeting is only available\n  // when adding event listeners and dispatching events via `ShadyDOM.wrap`\n  // (e.g. `ShadyDOM.wrap(element).addEventListener(...)`).\n\n\n  patchEvents();\n  window.ShadowRoot =\n  /** @type {function(new:ShadowRoot)} */\n  attach_shadow_ShadyRoot;\n}\n\n//# sourceURL=webpack:///./node_modules/@webcomponents/shadydom/src/shadydom.js_+_28_modules?")},"./node_modules/classnames/index.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n\n/* global define */\n(function () {\n  'use strict';\n\n  var hasOwn = {}.hasOwnProperty;\n\n  function classNames() {\n    var classes = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      var arg = arguments[i];\n      if (!arg) continue;\n\n      var argType = _typeof(arg);\n\n      if (argType === 'string' || argType === 'number') {\n        classes.push(arg);\n      } else if (Array.isArray(arg) && arg.length) {\n        var inner = classNames.apply(null, arg);\n\n        if (inner) {\n          classes.push(inner);\n        }\n      } else if (argType === 'object') {\n        for (var key in arg) {\n          if (hasOwn.call(arg, key) && arg[key]) {\n            classes.push(key);\n          }\n        }\n      }\n    }\n\n    return classes.join(' ');\n  }\n\n  if ( true && module.exports) {\n    classNames.default = classNames;\n    module.exports = classNames;\n  } else if ( true && _typeof(__webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) === 'object' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    // register as 'classnames', consistent with npm package name\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return classNames;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    window.classNames = classNames;\n  }\n})();\n\n//# sourceURL=webpack:///./node_modules/classnames/index.js?")},"./node_modules/css-loader/lib/css-base.js":function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media " + item[2] + "{" + content + "}";\n      } else {\n        return content;\n      }\n    }).join("");\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === "string") modules = [[null, modules, ""]];\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n      if (typeof id === "number") alreadyImportedModules[id] = true;\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      //  when a module is imported multiple times with different media queries.\n      //  I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n  return \'/*# \' + data + \' */\';\n}\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?')},"./node_modules/document-register-element/build/document-register-element.js":function(module,exports){eval('function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */\n!function (e, t) {\n  "use strict";\n\n  function n() {\n    var e = A.splice(0, A.length);\n\n    for (Ye = 0; e.length;) {\n      e.shift().call(null, e.shift());\n    }\n  }\n\n  function r(e, t) {\n    for (var n = 0, r = e.length; n < r; n++) {\n      T(e[n], t);\n    }\n  }\n\n  function o(e) {\n    for (var t, n = 0, r = e.length; n < r; n++) {\n      t = e[n], V(t, le[a(t)]);\n    }\n  }\n\n  function l(e) {\n    return function (t) {\n      ke(t) && (T(t, e), ae.length && r(t.querySelectorAll(ae), e));\n    };\n  }\n\n  function a(e) {\n    var t = Ze.call(e, "is"),\n        n = e.nodeName.toUpperCase(),\n        r = ue.call(oe, t ? te + t.toUpperCase() : ee + n);\n    return t && -1 < r && !i(n, t) ? -1 : r;\n  }\n\n  function i(e, t) {\n    return -1 < ae.indexOf(e + \'[is="\' + t + \'"]\');\n  }\n\n  function u(e) {\n    var t = e.currentTarget,\n        n = e.attrChange,\n        r = e.attrName,\n        o = e.target,\n        l = e[$] || 2,\n        a = e[Q] || 3;\n    !ot || o && o !== t || !t[Z] || "style" === r || e.prevValue === e.newValue && ("" !== e.newValue || n !== l && n !== a) || t[Z](r, n === l ? null : e.prevValue, n === a ? null : e.newValue);\n  }\n\n  function c(e) {\n    var t = l(e);\n    return function (e) {\n      A.push(t, e.target), Ye && clearTimeout(Ye), Ye = setTimeout(n, 1);\n    };\n  }\n\n  function s(e) {\n    rt && (rt = !1, e.currentTarget.removeEventListener(Y, s)), ae.length && r((e.target || y).querySelectorAll(ae), e.detail === q ? q : _), Re && d();\n  }\n\n  function m(e, t) {\n    var n = this;\n    ze.call(n, e, t), O.call(n, {\n      target: n\n    });\n  }\n\n  function f(e, t, n) {\n    var r = t.apply(e, n),\n        l = a(r);\n    return -1 < l && V(r, le[l]), n.pop() && ae.length && o(r.querySelectorAll(ae)), r;\n  }\n\n  function p(e, t) {\n    Fe(e, t), I ? I.observe(e, Qe) : (nt && (e.setAttribute = m, e[U] = D(e), e[k](J, O)), e[k](W, u)), e[K] && ot && (e.created = !0, e[K](), e.created = !1);\n  }\n\n  function d() {\n    for (var e, t = 0, n = _e.length; t < n; t++) {\n      e = _e[t], ie.contains(e) || (n--, _e.splice(t--, 1), T(e, q));\n    }\n  }\n\n  function h(e) {\n    throw new Error("A " + e + " type is already registered");\n  }\n\n  function T(e, t) {\n    var n,\n        r,\n        o = a(e);\n    -1 < o && (S(e, le[o]), o = 0, t !== _ || e[_] ? t !== q || e[q] || (e[_] = !1, e[q] = !0, r = "disconnected", o = 1) : (e[q] = !1, e[_] = !0, r = "connected", o = 1, Re && ue.call(_e, e) < 0 && _e.push(e)), o && (n = e[t + x] || e[r + x]) && n.call(e));\n  }\n\n  function L() {}\n\n  function M(e, t, n) {\n    var r = n && n[B] || "",\n        o = t.prototype,\n        l = Ie(o),\n        a = t.observedAttributes || pe,\n        i = {\n      prototype: l\n    };\n    Ue(l, K, {\n      value: function value() {\n        if (we) we = !1;else if (!this[ve]) {\n          this[ve] = !0, new t(this), o[K] && o[K].call(this);\n          var e = Ae[Ne.get(t)];\n          (!ge || e.create.length > 1) && H(this);\n        }\n      }\n    }), Ue(l, Z, {\n      value: function value(e) {\n        -1 < ue.call(a, e) && o[Z] && o[Z].apply(this, arguments);\n      }\n    }), o[G] && Ue(l, j, {\n      value: o[G]\n    }), o[z] && Ue(l, X, {\n      value: o[z]\n    }), r && (i[B] = r), e = e.toUpperCase(), Ae[e] = {\n      constructor: t,\n      create: r ? [r, De(e)] : [e]\n    }, Ne.set(t, e), y[R](e.toLowerCase(), i), g(e), Oe[e].r();\n  }\n\n  function E(e) {\n    var t = Ae[e.toUpperCase()];\n    return t && t.constructor;\n  }\n\n  function v(e) {\n    return "string" == typeof e ? e : e && e.is || "";\n  }\n\n  function H(e) {\n    for (var t, n = e[Z], r = n ? e.attributes : pe, o = r.length; o--;) {\n      t = r[o], n.call(e, t.name || t.nodeName, null, t.value || t.nodeValue);\n    }\n  }\n\n  function g(e) {\n    return e = e.toUpperCase(), e in Oe || (Oe[e] = {}, Oe[e].p = new Ce(function (t) {\n      Oe[e].r = t;\n    })), Oe[e].p;\n  }\n\n  function b() {\n    He && delete e.customElements, fe(e, "customElements", {\n      configurable: !0,\n      value: new L()\n    }), fe(e, "CustomElementRegistry", {\n      configurable: !0,\n      value: L\n    });\n\n    for (var t = w.get(/^HTML[A-Z]*[a-z]/), n = t.length; n--; function (t) {\n      var n = e[t];\n\n      if (n) {\n        e[t] = function (e) {\n          var t, r;\n          return e || (e = this), e[ve] || (we = !0, t = Ae[Ne.get(e.constructor)], r = ge && 1 === t.create.length, e = r ? Reflect.construct(n, pe, t.constructor) : y.createElement.apply(y, t.create), e[ve] = !0, we = !1, r || H(e)), e;\n        }, e[t].prototype = n.prototype;\n\n        try {\n          n.prototype.constructor = e[t];\n        } catch (r) {\n          Ee = !0, fe(n, ve, {\n            value: e[t]\n          });\n        }\n      }\n    }(t[n])) {\n      ;\n    }\n\n    y.createElement = function (e, t) {\n      var n = v(t);\n      return n ? $e.call(this, e, De(n)) : $e.call(this, e);\n    }, Je || (tt = !0, y[R](""));\n  }\n\n  var y = e.document,\n      C = e.Object,\n      w = function (e) {\n    var t,\n        n,\n        r,\n        o,\n        l = /^[A-Z]+[a-z]/,\n        a = function a(e) {\n      var t,\n          n = [];\n\n      for (t in u) {\n        e.test(t) && n.push(t);\n      }\n\n      return n;\n    },\n        i = function i(e, t) {\n      (t = t.toLowerCase()) in u || (u[e] = (u[e] || []).concat(t), u[t] = u[t.toUpperCase()] = e);\n    },\n        u = (C.create || C)(null),\n        c = {};\n\n    for (n in e) {\n      for (o in e[n]) {\n        for (r = e[n][o], u[o] = r, t = 0; t < r.length; t++) {\n          u[r[t].toLowerCase()] = u[r[t].toUpperCase()] = o;\n        }\n      }\n    }\n\n    return c.get = function (e) {\n      return "string" == typeof e ? u[e] || (l.test(e) ? [] : "") : a(e);\n    }, c.set = function (e, t) {\n      return l.test(e) ? i(e, t) : i(t, e), c;\n    }, c;\n  }({\n    collections: {\n      HTMLAllCollection: ["all"],\n      HTMLCollection: ["forms"],\n      HTMLFormControlsCollection: ["elements"],\n      HTMLOptionsCollection: ["options"]\n    },\n    elements: {\n      Element: ["element"],\n      HTMLAnchorElement: ["a"],\n      HTMLAppletElement: ["applet"],\n      HTMLAreaElement: ["area"],\n      HTMLAttachmentElement: ["attachment"],\n      HTMLAudioElement: ["audio"],\n      HTMLBRElement: ["br"],\n      HTMLBaseElement: ["base"],\n      HTMLBodyElement: ["body"],\n      HTMLButtonElement: ["button"],\n      HTMLCanvasElement: ["canvas"],\n      HTMLContentElement: ["content"],\n      HTMLDListElement: ["dl"],\n      HTMLDataElement: ["data"],\n      HTMLDataListElement: ["datalist"],\n      HTMLDetailsElement: ["details"],\n      HTMLDialogElement: ["dialog"],\n      HTMLDirectoryElement: ["dir"],\n      HTMLDivElement: ["div"],\n      HTMLDocument: ["document"],\n      HTMLElement: ["element", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "cite", "code", "command", "dd", "dfn", "dt", "em", "figcaption", "figure", "footer", "header", "i", "kbd", "mark", "nav", "noscript", "rp", "rt", "ruby", "s", "samp", "section", "small", "strong", "sub", "summary", "sup", "u", "var", "wbr"],\n      HTMLEmbedElement: ["embed"],\n      HTMLFieldSetElement: ["fieldset"],\n      HTMLFontElement: ["font"],\n      HTMLFormElement: ["form"],\n      HTMLFrameElement: ["frame"],\n      HTMLFrameSetElement: ["frameset"],\n      HTMLHRElement: ["hr"],\n      HTMLHeadElement: ["head"],\n      HTMLHeadingElement: ["h1", "h2", "h3", "h4", "h5", "h6"],\n      HTMLHtmlElement: ["html"],\n      HTMLIFrameElement: ["iframe"],\n      HTMLImageElement: ["img"],\n      HTMLInputElement: ["input"],\n      HTMLKeygenElement: ["keygen"],\n      HTMLLIElement: ["li"],\n      HTMLLabelElement: ["label"],\n      HTMLLegendElement: ["legend"],\n      HTMLLinkElement: ["link"],\n      HTMLMapElement: ["map"],\n      HTMLMarqueeElement: ["marquee"],\n      HTMLMediaElement: ["media"],\n      HTMLMenuElement: ["menu"],\n      HTMLMenuItemElement: ["menuitem"],\n      HTMLMetaElement: ["meta"],\n      HTMLMeterElement: ["meter"],\n      HTMLModElement: ["del", "ins"],\n      HTMLOListElement: ["ol"],\n      HTMLObjectElement: ["object"],\n      HTMLOptGroupElement: ["optgroup"],\n      HTMLOptionElement: ["option"],\n      HTMLOutputElement: ["output"],\n      HTMLParagraphElement: ["p"],\n      HTMLParamElement: ["param"],\n      HTMLPictureElement: ["picture"],\n      HTMLPreElement: ["pre"],\n      HTMLProgressElement: ["progress"],\n      HTMLQuoteElement: ["blockquote", "q", "quote"],\n      HTMLScriptElement: ["script"],\n      HTMLSelectElement: ["select"],\n      HTMLShadowElement: ["shadow"],\n      HTMLSlotElement: ["slot"],\n      HTMLSourceElement: ["source"],\n      HTMLSpanElement: ["span"],\n      HTMLStyleElement: ["style"],\n      HTMLTableCaptionElement: ["caption"],\n      HTMLTableCellElement: ["td", "th"],\n      HTMLTableColElement: ["col", "colgroup"],\n      HTMLTableElement: ["table"],\n      HTMLTableRowElement: ["tr"],\n      HTMLTableSectionElement: ["thead", "tbody", "tfoot"],\n      HTMLTemplateElement: ["template"],\n      HTMLTextAreaElement: ["textarea"],\n      HTMLTimeElement: ["time"],\n      HTMLTitleElement: ["title"],\n      HTMLTrackElement: ["track"],\n      HTMLUListElement: ["ul"],\n      HTMLUnknownElement: ["unknown", "vhgroupv", "vkeygen"],\n      HTMLVideoElement: ["video"]\n    },\n    nodes: {\n      Attr: ["node"],\n      Audio: ["audio"],\n      CDATASection: ["node"],\n      CharacterData: ["node"],\n      Comment: ["#comment"],\n      Document: ["#document"],\n      DocumentFragment: ["#document-fragment"],\n      DocumentType: ["node"],\n      HTMLDocument: ["#document"],\n      Image: ["img"],\n      Option: ["option"],\n      ProcessingInstruction: ["node"],\n      ShadowRoot: ["#shadow-root"],\n      Text: ["#text"],\n      XMLDocument: ["xml"]\n    }\n  });\n\n  "object" != _typeof(t) && (t = {\n    type: t || "auto"\n  });\n\n  var A,\n      O,\n      N,\n      D,\n      I,\n      F,\n      S,\n      V,\n      P,\n      R = "registerElement",\n      U = "__" + R + (1e5 * e.Math.random() >> 0),\n      k = "addEventListener",\n      _ = "attached",\n      x = "Callback",\n      q = "detached",\n      B = "extends",\n      Z = "attributeChanged" + x,\n      j = _ + x,\n      G = "connected" + x,\n      z = "disconnected" + x,\n      K = "created" + x,\n      X = q + x,\n      $ = "ADDITION",\n      Q = "REMOVAL",\n      W = "DOMAttrModified",\n      Y = "DOMContentLoaded",\n      J = "DOMSubtreeModified",\n      ee = "<",\n      te = "=",\n      ne = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,\n      re = ["ANNOTATION-XML", "COLOR-PROFILE", "FONT-FACE", "FONT-FACE-SRC", "FONT-FACE-URI", "FONT-FACE-FORMAT", "FONT-FACE-NAME", "MISSING-GLYPH"],\n      oe = [],\n      le = [],\n      ae = "",\n      ie = y.documentElement,\n      ue = oe.indexOf || function (e) {\n    for (var t = this.length; t-- && this[t] !== e;) {\n      ;\n    }\n\n    return t;\n  },\n      ce = C.prototype,\n      se = ce.hasOwnProperty,\n      me = ce.isPrototypeOf,\n      fe = C.defineProperty,\n      pe = [],\n      de = C.getOwnPropertyDescriptor,\n      he = C.getOwnPropertyNames,\n      Te = C.getPrototypeOf,\n      Le = C.setPrototypeOf,\n      Me = !!C.__proto__,\n      Ee = !1,\n      ve = "__dreCEv1",\n      He = e.customElements,\n      ge = !/^force/.test(t.type) && !!(He && He.define && He.get && He.whenDefined),\n      be = C.create || C,\n      ye = e.Map || function () {\n    var e,\n        t = [],\n        n = [];\n    return {\n      get: function get(e) {\n        return n[ue.call(t, e)];\n      },\n      set: function set(r, o) {\n        e = ue.call(t, r), e < 0 ? n[t.push(r) - 1] = o : n[e] = o;\n      }\n    };\n  },\n      Ce = e.Promise || function (e) {\n    function t(e) {\n      for (r = !0; n.length;) {\n        n.shift()(e);\n      }\n    }\n\n    var n = [],\n        r = !1,\n        o = {\n      "catch": function _catch() {\n        return o;\n      },\n      then: function then(e) {\n        return n.push(e), r && setTimeout(t, 1), o;\n      }\n    };\n    return e(t), o;\n  },\n      we = !1,\n      Ae = be(null),\n      Oe = be(null),\n      Ne = new ye(),\n      De = function De(e) {\n    return e.toLowerCase();\n  },\n      Ie = C.create || function it(e) {\n    return e ? (it.prototype = e, new it()) : this;\n  },\n      Fe = Le || (Me ? function (e, t) {\n    return e.__proto__ = t, e;\n  } : he && de ? function () {\n    function e(e, t) {\n      for (var n, r = he(t), o = 0, l = r.length; o < l; o++) {\n        n = r[o], se.call(e, n) || fe(e, n, de(t, n));\n      }\n    }\n\n    return function (t, n) {\n      do {\n        e(t, n);\n      } while ((n = Te(n)) && !me.call(n, t));\n\n      return t;\n    };\n  }() : function (e, t) {\n    for (var n in t) {\n      e[n] = t[n];\n    }\n\n    return e;\n  }),\n      Se = e.MutationObserver || e.WebKitMutationObserver,\n      Ve = e.HTMLAnchorElement,\n      Pe = (e.HTMLElement || e.Element || e.Node).prototype,\n      Re = !me.call(Pe, ie),\n      Ue = Re ? function (e, t, n) {\n    return e[t] = n.value, e;\n  } : fe,\n      ke = Re ? function (e) {\n    return 1 === e.nodeType;\n  } : function (e) {\n    return me.call(Pe, e);\n  },\n      _e = Re && [],\n      xe = Pe.attachShadow,\n      qe = Pe.cloneNode,\n      Be = Pe.dispatchEvent,\n      Ze = Pe.getAttribute,\n      je = Pe.hasAttribute,\n      Ge = Pe.removeAttribute,\n      ze = Pe.setAttribute,\n      Ke = y.createElement,\n      Xe = y.importNode,\n      $e = Ke,\n      Qe = Se && {\n    attributes: !0,\n    characterData: !0,\n    attributeOldValue: !0\n  },\n      We = Se || function (e) {\n    nt = !1, ie.removeEventListener(W, We);\n  },\n      Ye = 0,\n      Je = R in y && !/^force-all/.test(t.type),\n      et = !0,\n      tt = !1,\n      nt = !0,\n      rt = !0,\n      ot = !0;\n\n  if (Se && (P = y.createElement("div"), P.innerHTML = "<div><div></div></div>", new Se(function (e, t) {\n    if (e[0] && "childList" == e[0].type && !e[0].removedNodes[0].childNodes.length) {\n      P = de(Pe, "innerHTML");\n      var n = P && P.set;\n      n && fe(Pe, "innerHTML", {\n        set: function set(e) {\n          for (; this.lastChild;) {\n            this.removeChild(this.lastChild);\n          }\n\n          n.call(this, e);\n        }\n      });\n    }\n\n    t.disconnect(), P = null;\n  }).observe(P, {\n    childList: !0,\n    subtree: !0\n  }), P.innerHTML = ""), Je || (Le || Me ? (S = function S(e, t) {\n    me.call(t, e) || p(e, t);\n  }, V = p) : (S = function S(e, t) {\n    e[U] || (e[U] = C(!0), p(e, t));\n  }, V = S), Re ? (nt = !1, function () {\n    var e = de(Pe, k),\n        t = e.value,\n        n = function n(e) {\n      var t = new CustomEvent(W, {\n        bubbles: !0\n      });\n      t.attrName = e, t.prevValue = Ze.call(this, e), t.newValue = null, t[Q] = t.attrChange = 2, Ge.call(this, e), Be.call(this, t);\n    },\n        r = function r(e, t) {\n      var n = je.call(this, e),\n          r = n && Ze.call(this, e),\n          o = new CustomEvent(W, {\n        bubbles: !0\n      });\n      ze.call(this, e, t), o.attrName = e, o.prevValue = n ? r : null, o.newValue = t, n ? o.MODIFICATION = o.attrChange = 1 : o[$] = o.attrChange = 0, Be.call(this, o);\n    },\n        o = function o(e) {\n      var t,\n          n = e.currentTarget,\n          r = n[U],\n          o = e.propertyName;\n      r.hasOwnProperty(o) && (r = r[o], t = new CustomEvent(W, {\n        bubbles: !0\n      }), t.attrName = r.name, t.prevValue = r.value || null, t.newValue = r.value = n[o] || null, null == t.prevValue ? t[$] = t.attrChange = 0 : t.MODIFICATION = t.attrChange = 1, Be.call(n, t));\n    };\n\n    e.value = function (e, l, a) {\n      e === W && this[Z] && this.setAttribute !== r && (this[U] = {\n        className: {\n          name: "class",\n          value: this.className\n        }\n      }, this.setAttribute = r, this.removeAttribute = n, t.call(this, "propertychange", o)), t.call(this, e, l, a);\n    }, fe(Pe, k, e);\n  }()) : Se || (ie[k](W, We), ie.setAttribute(U, 1), ie.removeAttribute(U), nt && (O = function O(e) {\n    var t,\n        n,\n        r,\n        o = this;\n\n    if (o === e.target) {\n      t = o[U], o[U] = n = D(o);\n\n      for (r in n) {\n        if (!(r in t)) return N(0, o, r, t[r], n[r], $);\n        if (n[r] !== t[r]) return N(1, o, r, t[r], n[r], "MODIFICATION");\n      }\n\n      for (r in t) {\n        if (!(r in n)) return N(2, o, r, t[r], n[r], Q);\n      }\n    }\n  }, N = function N(e, t, n, r, o, l) {\n    var a = {\n      attrChange: e,\n      currentTarget: t,\n      attrName: n,\n      prevValue: r,\n      newValue: o\n    };\n    a[l] = e, u(a);\n  }, D = function D(e) {\n    for (var t, n, r = {}, o = e.attributes, l = 0, a = o.length; l < a; l++) {\n      t = o[l], "setAttribute" !== (n = t.name) && (r[n] = t.value);\n    }\n\n    return r;\n  })), y[R] = function (e, t) {\n    if (n = e.toUpperCase(), et && (et = !1, Se ? (I = function (e, t) {\n      function n(e, t) {\n        for (var n = 0, r = e.length; n < r; t(e[n++])) {\n          ;\n        }\n      }\n\n      return new Se(function (r) {\n        for (var o, l, a, i = 0, u = r.length; i < u; i++) {\n          o = r[i], "childList" === o.type ? (n(o.addedNodes, e), n(o.removedNodes, t)) : (l = o.target, ot && l[Z] && "style" !== o.attributeName && (a = Ze.call(l, o.attributeName)) !== o.oldValue && l[Z](o.attributeName, o.oldValue, a));\n        }\n      });\n    }(l(_), l(q)), F = function F(e) {\n      return I.observe(e, {\n        childList: !0,\n        subtree: !0\n      }), e;\n    }, F(y), xe && (Pe.attachShadow = function () {\n      return F(xe.apply(this, arguments));\n    })) : (A = [], y[k]("DOMNodeInserted", c(_)), y[k]("DOMNodeRemoved", c(q))), y[k](Y, s), y[k]("readystatechange", s), y.importNode = function (e, t) {\n      switch (e.nodeType) {\n        case 1:\n          return f(y, Xe, [e, !!t]);\n\n        case 11:\n          for (var n = y.createDocumentFragment(), r = e.childNodes, o = r.length, l = 0; l < o; l++) {\n            n.appendChild(y.importNode(r[l], !!t));\n          }\n\n          return n;\n\n        default:\n          return qe.call(e, !!t);\n      }\n    }, Pe.cloneNode = function (e) {\n      return f(this, qe, [!!e]);\n    }), tt) return tt = !1;\n    if (-2 < ue.call(oe, te + n) + ue.call(oe, ee + n) && h(e), !ne.test(n) || -1 < ue.call(re, n)) throw new Error("The type " + e + " is invalid");\n\n    var n,\n        o,\n        a = function a() {\n      return u ? y.createElement(m, n) : y.createElement(m);\n    },\n        i = t || ce,\n        u = se.call(i, B),\n        m = u ? t[B].toUpperCase() : n;\n\n    return u && -1 < ue.call(oe, ee + m) && h(m), o = oe.push((u ? te : ee) + n) - 1, ae = ae.concat(ae.length ? "," : "", u ? m + \'[is="\' + e.toLowerCase() + \'"]\' : m), a.prototype = le[o] = se.call(i, "prototype") ? i.prototype : Ie(Pe), ae.length && r(y.querySelectorAll(ae), _), a;\n  }, y.createElement = $e = function $e(e, t) {\n    var n = v(t),\n        r = n ? Ke.call(y, e, De(n)) : Ke.call(y, e),\n        o = "" + e,\n        l = ue.call(oe, (n ? te : ee) + (n || o).toUpperCase()),\n        a = -1 < l;\n    return n && (r.setAttribute("is", n = n.toLowerCase()), a && (a = i(o.toUpperCase(), n))), ot = !y.createElement.innerHTMLHelper, a && V(r, le[l]), r;\n  }), L.prototype = {\n    constructor: L,\n    define: ge ? function (e, t, n) {\n      if (n) M(e, t, n);else {\n        var r = e.toUpperCase();\n        Ae[r] = {\n          constructor: t,\n          create: [r]\n        }, Ne.set(t, r), He.define(e, t);\n      }\n    } : M,\n    get: ge ? function (e) {\n      return He.get(e) || E(e);\n    } : E,\n    whenDefined: ge ? function (e) {\n      return Ce.race([He.whenDefined(e), g(e)]);\n    } : g\n  }, !He || /^force/.test(t.type)) b();else if (!t.noBuiltIn) try {\n    !function (t, n, r) {\n      var o = new RegExp("^<a\\\\s+is=(\'|\\")" + r + "\\\\1></a>$");\n      if (n[B] = "a", t.prototype = Ie(Ve.prototype), t.prototype.constructor = t, e.customElements.define(r, t, n), !o.test(y.createElement("a", {\n        is: r\n      }).outerHTML) || !o.test(new t().outerHTML)) throw n;\n    }(function ut() {\n      return Reflect.construct(Ve, [], ut);\n    }, {}, "document-register-element-a");\n  } catch (lt) {\n    b();\n  }\n  if (!t.noBuiltIn) try {\n    if (Ke.call(y, "a", "a").outerHTML.indexOf("is") < 0) throw {};\n  } catch (at) {\n    De = function De(e) {\n      return {\n        is: e.toLowerCase()\n      };\n    };\n  }\n}(window);\n\n//# sourceURL=webpack:///./node_modules/document-register-element/build/document-register-element.js?')},"./node_modules/fuse.js/dist/fuse.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Fuse.js v3.4.5 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n!function (e, t) {\n  "object" == ( false ? undefined : _typeof(exports)) && "object" == ( false ? undefined : _typeof(module)) ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(r) {\n      if (t[r]) return t[r].exports;\n      var o = t[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, r) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: r\n      });\n    }, n.r = function (e) {\n      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: "Module"\n      }), Object.defineProperty(e, "__esModule", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;\n      var r = Object.create(null);\n      if (n.r(r), Object.defineProperty(r, "default", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && "string" != typeof e) for (var o in e) {\n        n.d(r, o, function (t) {\n          return e[t];\n        }.bind(null, o));\n      }\n      return r;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, "a", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = "", n(n.s = 1);\n  }([function (e, t) {\n    e.exports = function (e) {\n      return Array.isArray ? Array.isArray(e) : "[object Array]" === Object.prototype.toString.call(e);\n    };\n  }, function (e, t, n) {\n    function r(e) {\n      return (r = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {\n        return _typeof(e);\n      } : function (e) {\n        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);\n      })(e);\n    }\n\n    function o(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var r = t[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n      }\n    }\n\n    var i = n(2),\n        a = n(8),\n        s = n(0),\n        c = function () {\n      function e(t, n) {\n        var r = n.location,\n            o = void 0 === r ? 0 : r,\n            i = n.distance,\n            s = void 0 === i ? 100 : i,\n            c = n.threshold,\n            h = void 0 === c ? .6 : c,\n            l = n.maxPatternLength,\n            u = void 0 === l ? 32 : l,\n            f = n.caseSensitive,\n            d = void 0 !== f && f,\n            v = n.tokenSeparator,\n            p = void 0 === v ? / +/g : v,\n            g = n.findAllMatches,\n            y = void 0 !== g && g,\n            m = n.minMatchCharLength,\n            k = void 0 === m ? 1 : m,\n            S = n.id,\n            x = void 0 === S ? null : S,\n            b = n.keys,\n            M = void 0 === b ? [] : b,\n            _ = n.shouldSort,\n            L = void 0 === _ || _,\n            w = n.getFn,\n            A = void 0 === w ? a : w,\n            C = n.sortFn,\n            I = void 0 === C ? function (e, t) {\n          return e.score - t.score;\n        } : C,\n            O = n.tokenize,\n            j = void 0 !== O && O,\n            P = n.matchAllTokens,\n            F = void 0 !== P && P,\n            T = n.includeMatches,\n            z = void 0 !== T && T,\n            E = n.includeScore,\n            K = void 0 !== E && E,\n            $ = n.verbose,\n            J = void 0 !== $ && $;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");\n        }(this, e), this.options = {\n          location: o,\n          distance: s,\n          threshold: h,\n          maxPatternLength: u,\n          isCaseSensitive: d,\n          tokenSeparator: p,\n          findAllMatches: y,\n          minMatchCharLength: k,\n          id: x,\n          keys: M,\n          includeMatches: z,\n          includeScore: K,\n          shouldSort: L,\n          getFn: A,\n          sortFn: I,\n          verbose: J,\n          tokenize: j,\n          matchAllTokens: F\n        }, this.setCollection(t);\n      }\n\n      var t, n, c;\n      return t = e, (n = [{\n        key: "setCollection",\n        value: function value(e) {\n          return this.list = e, e;\n        }\n      }, {\n        key: "search",\n        value: function value(e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n            limit: !1\n          };\n\n          this._log(\'---------\\nSearch pattern: "\'.concat(e, \'"\'));\n\n          var n = this._prepareSearchers(e),\n              r = n.tokenSearchers,\n              o = n.fullSearcher,\n              i = this._search(r, o),\n              a = i.weights,\n              s = i.results;\n\n          return this._computeScore(a, s), this.options.shouldSort && this._sort(s), t.limit && "number" == typeof t.limit && (s = s.slice(0, t.limit)), this._format(s);\n        }\n      }, {\n        key: "_prepareSearchers",\n        value: function value() {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",\n              t = [];\n          if (this.options.tokenize) for (var n = e.split(this.options.tokenSeparator), r = 0, o = n.length; r < o; r += 1) {\n            t.push(new i(n[r], this.options));\n          }\n          return {\n            tokenSearchers: t,\n            fullSearcher: new i(e, this.options)\n          };\n        }\n      }, {\n        key: "_search",\n        value: function value() {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],\n              t = arguments.length > 1 ? arguments[1] : void 0,\n              n = this.list,\n              r = {},\n              o = [];\n\n          if ("string" == typeof n[0]) {\n            for (var i = 0, a = n.length; i < a; i += 1) {\n              this._analyze({\n                key: "",\n                value: n[i],\n                record: i,\n                index: i\n              }, {\n                resultMap: r,\n                results: o,\n                tokenSearchers: e,\n                fullSearcher: t\n              });\n            }\n\n            return {\n              weights: null,\n              results: o\n            };\n          }\n\n          for (var s = {}, c = 0, h = n.length; c < h; c += 1) {\n            for (var l = n[c], u = 0, f = this.options.keys.length; u < f; u += 1) {\n              var d = this.options.keys[u];\n\n              if ("string" != typeof d) {\n                if (s[d.name] = {\n                  weight: 1 - d.weight || 1\n                }, d.weight <= 0 || d.weight > 1) throw new Error("Key weight has to be > 0 and <= 1");\n                d = d.name;\n              } else s[d] = {\n                weight: 1\n              };\n\n              this._analyze({\n                key: d,\n                value: this.options.getFn(l, d),\n                record: l,\n                index: c\n              }, {\n                resultMap: r,\n                results: o,\n                tokenSearchers: e,\n                fullSearcher: t\n              });\n            }\n          }\n\n          return {\n            weights: s,\n            results: o\n          };\n        }\n      }, {\n        key: "_analyze",\n        value: function value(e, t) {\n          var n = e.key,\n              r = e.arrayIndex,\n              o = void 0 === r ? -1 : r,\n              i = e.value,\n              a = e.record,\n              c = e.index,\n              h = t.tokenSearchers,\n              l = void 0 === h ? [] : h,\n              u = t.fullSearcher,\n              f = void 0 === u ? [] : u,\n              d = t.resultMap,\n              v = void 0 === d ? {} : d,\n              p = t.results,\n              g = void 0 === p ? [] : p;\n\n          if (null != i) {\n            var y = !1,\n                m = -1,\n                k = 0;\n\n            if ("string" == typeof i) {\n              this._log("\\nKey: ".concat("" === n ? "-" : n));\n\n              var S = f.search(i);\n\n              if (this._log(\'Full text: "\'.concat(i, \'", score: \').concat(S.score)), this.options.tokenize) {\n                for (var x = i.split(this.options.tokenSeparator), b = [], M = 0; M < l.length; M += 1) {\n                  var _ = l[M];\n\n                  this._log(\'\\nPattern: "\'.concat(_.pattern, \'"\'));\n\n                  for (var L = !1, w = 0; w < x.length; w += 1) {\n                    var A = x[w],\n                        C = _.search(A),\n                        I = {};\n\n                    C.isMatch ? (I[A] = C.score, y = !0, L = !0, b.push(C.score)) : (I[A] = 1, this.options.matchAllTokens || b.push(1)), this._log(\'Token: "\'.concat(A, \'", score: \').concat(I[A]));\n                  }\n\n                  L && (k += 1);\n                }\n\n                m = b[0];\n\n                for (var O = b.length, j = 1; j < O; j += 1) {\n                  m += b[j];\n                }\n\n                m /= O, this._log("Token score average:", m);\n              }\n\n              var P = S.score;\n              m > -1 && (P = (P + m) / 2), this._log("Score average:", P);\n              var F = !this.options.tokenize || !this.options.matchAllTokens || k >= l.length;\n\n              if (this._log("\\nCheck Matches: ".concat(F)), (y || S.isMatch) && F) {\n                var T = v[c];\n                T ? T.output.push({\n                  key: n,\n                  arrayIndex: o,\n                  value: i,\n                  score: P,\n                  matchedIndices: S.matchedIndices\n                }) : (v[c] = {\n                  item: a,\n                  output: [{\n                    key: n,\n                    arrayIndex: o,\n                    value: i,\n                    score: P,\n                    matchedIndices: S.matchedIndices\n                  }]\n                }, g.push(v[c]));\n              }\n            } else if (s(i)) for (var z = 0, E = i.length; z < E; z += 1) {\n              this._analyze({\n                key: n,\n                arrayIndex: z,\n                value: i[z],\n                record: a,\n                index: c\n              }, {\n                resultMap: v,\n                results: g,\n                tokenSearchers: l,\n                fullSearcher: f\n              });\n            }\n          }\n        }\n      }, {\n        key: "_computeScore",\n        value: function value(e, t) {\n          this._log("\\n\\nComputing score:\\n");\n\n          for (var n = 0, r = t.length; n < r; n += 1) {\n            for (var o = t[n].output, i = o.length, a = 1, s = 1, c = 0; c < i; c += 1) {\n              var h = e ? e[o[c].key].weight : 1,\n                  l = (1 === h ? o[c].score : o[c].score || .001) * h;\n              1 !== h ? s = Math.min(s, l) : (o[c].nScore = l, a *= l);\n            }\n\n            t[n].score = 1 === s ? a : s, this._log(t[n]);\n          }\n        }\n      }, {\n        key: "_sort",\n        value: function value(e) {\n          this._log("\\n\\nSorting...."), e.sort(this.options.sortFn);\n        }\n      }, {\n        key: "_format",\n        value: function value(e) {\n          var t = [];\n\n          if (this.options.verbose) {\n            var n = [];\n            this._log("\\n\\nOutput:\\n\\n", JSON.stringify(e, function (e, t) {\n              if ("object" === r(t) && null !== t) {\n                if (-1 !== n.indexOf(t)) return;\n                n.push(t);\n              }\n\n              return t;\n            })), n = null;\n          }\n\n          var o = [];\n          this.options.includeMatches && o.push(function (e, t) {\n            var n = e.output;\n            t.matches = [];\n\n            for (var r = 0, o = n.length; r < o; r += 1) {\n              var i = n[r];\n\n              if (0 !== i.matchedIndices.length) {\n                var a = {\n                  indices: i.matchedIndices,\n                  value: i.value\n                };\n                i.key && (a.key = i.key), i.hasOwnProperty("arrayIndex") && i.arrayIndex > -1 && (a.arrayIndex = i.arrayIndex), t.matches.push(a);\n              }\n            }\n          }), this.options.includeScore && o.push(function (e, t) {\n            t.score = e.score;\n          });\n\n          for (var i = 0, a = e.length; i < a; i += 1) {\n            var s = e[i];\n\n            if (this.options.id && (s.item = this.options.getFn(s.item, this.options.id)[0]), o.length) {\n              for (var c = {\n                item: s.item\n              }, h = 0, l = o.length; h < l; h += 1) {\n                o[h](s, c);\n              }\n\n              t.push(c);\n            } else t.push(s.item);\n          }\n\n          return t;\n        }\n      }, {\n        key: "_log",\n        value: function value() {\n          var e;\n          this.options.verbose && (e = console).log.apply(e, arguments);\n        }\n      }]) && o(t.prototype, n), c && o(t, c), e;\n    }();\n\n    e.exports = c;\n  }, function (e, t, n) {\n    function r(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var r = t[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n      }\n    }\n\n    var o = n(3),\n        i = n(4),\n        a = n(7),\n        s = function () {\n      function e(t, n) {\n        var r = n.location,\n            o = void 0 === r ? 0 : r,\n            i = n.distance,\n            s = void 0 === i ? 100 : i,\n            c = n.threshold,\n            h = void 0 === c ? .6 : c,\n            l = n.maxPatternLength,\n            u = void 0 === l ? 32 : l,\n            f = n.isCaseSensitive,\n            d = void 0 !== f && f,\n            v = n.tokenSeparator,\n            p = void 0 === v ? / +/g : v,\n            g = n.findAllMatches,\n            y = void 0 !== g && g,\n            m = n.minMatchCharLength,\n            k = void 0 === m ? 1 : m;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");\n        }(this, e), this.options = {\n          location: o,\n          distance: s,\n          threshold: h,\n          maxPatternLength: u,\n          isCaseSensitive: d,\n          tokenSeparator: p,\n          findAllMatches: y,\n          minMatchCharLength: k\n        }, this.pattern = this.options.isCaseSensitive ? t : t.toLowerCase(), this.pattern.length <= u && (this.patternAlphabet = a(this.pattern));\n      }\n\n      var t, n, s;\n      return t = e, (n = [{\n        key: "search",\n        value: function value(e) {\n          if (this.options.isCaseSensitive || (e = e.toLowerCase()), this.pattern === e) return {\n            isMatch: !0,\n            score: 0,\n            matchedIndices: [[0, e.length - 1]]\n          };\n          var t = this.options,\n              n = t.maxPatternLength,\n              r = t.tokenSeparator;\n          if (this.pattern.length > n) return o(e, this.pattern, r);\n          var a = this.options,\n              s = a.location,\n              c = a.distance,\n              h = a.threshold,\n              l = a.findAllMatches,\n              u = a.minMatchCharLength;\n          return i(e, this.pattern, this.patternAlphabet, {\n            location: s,\n            distance: c,\n            threshold: h,\n            findAllMatches: l,\n            minMatchCharLength: u\n          });\n        }\n      }]) && r(t.prototype, n), s && r(t, s), e;\n    }();\n\n    e.exports = s;\n  }, function (e, t) {\n    var n = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\n    e.exports = function (e, t) {\n      var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : / +/g,\n          o = new RegExp(t.replace(n, "\\\\$&").replace(r, "|")),\n          i = e.match(o),\n          a = !!i,\n          s = [];\n      if (a) for (var c = 0, h = i.length; c < h; c += 1) {\n        var l = i[c];\n        s.push([e.indexOf(l), l.length - 1]);\n      }\n      return {\n        score: a ? .5 : 1,\n        isMatch: a,\n        matchedIndices: s\n      };\n    };\n  }, function (e, t, n) {\n    var r = n(5),\n        o = n(6);\n\n    e.exports = function (e, t, n, i) {\n      for (var a = i.location, s = void 0 === a ? 0 : a, c = i.distance, h = void 0 === c ? 100 : c, l = i.threshold, u = void 0 === l ? .6 : l, f = i.findAllMatches, d = void 0 !== f && f, v = i.minMatchCharLength, p = void 0 === v ? 1 : v, g = s, y = e.length, m = u, k = e.indexOf(t, g), S = t.length, x = [], b = 0; b < y; b += 1) {\n        x[b] = 0;\n      }\n\n      if (-1 !== k) {\n        var M = r(t, {\n          errors: 0,\n          currentLocation: k,\n          expectedLocation: g,\n          distance: h\n        });\n\n        if (m = Math.min(M, m), -1 !== (k = e.lastIndexOf(t, g + S))) {\n          var _ = r(t, {\n            errors: 0,\n            currentLocation: k,\n            expectedLocation: g,\n            distance: h\n          });\n\n          m = Math.min(_, m);\n        }\n      }\n\n      k = -1;\n\n      for (var L = [], w = 1, A = S + y, C = 1 << S - 1, I = 0; I < S; I += 1) {\n        for (var O = 0, j = A; O < j;) {\n          r(t, {\n            errors: I,\n            currentLocation: g + j,\n            expectedLocation: g,\n            distance: h\n          }) <= m ? O = j : A = j, j = Math.floor((A - O) / 2 + O);\n        }\n\n        A = j;\n        var P = Math.max(1, g - j + 1),\n            F = d ? y : Math.min(g + j, y) + S,\n            T = Array(F + 2);\n        T[F + 1] = (1 << I) - 1;\n\n        for (var z = F; z >= P; z -= 1) {\n          var E = z - 1,\n              K = n[e.charAt(E)];\n\n          if (K && (x[E] = 1), T[z] = (T[z + 1] << 1 | 1) & K, 0 !== I && (T[z] |= (L[z + 1] | L[z]) << 1 | 1 | L[z + 1]), T[z] & C && (w = r(t, {\n            errors: I,\n            currentLocation: E,\n            expectedLocation: g,\n            distance: h\n          })) <= m) {\n            if (m = w, (k = E) <= g) break;\n            P = Math.max(1, 2 * g - k);\n          }\n        }\n\n        if (r(t, {\n          errors: I + 1,\n          currentLocation: g,\n          expectedLocation: g,\n          distance: h\n        }) > m) break;\n        L = T;\n      }\n\n      return {\n        isMatch: k >= 0,\n        score: 0 === w ? .001 : w,\n        matchedIndices: o(x, p)\n      };\n    };\n  }, function (e, t) {\n    e.exports = function (e, t) {\n      var n = t.errors,\n          r = void 0 === n ? 0 : n,\n          o = t.currentLocation,\n          i = void 0 === o ? 0 : o,\n          a = t.expectedLocation,\n          s = void 0 === a ? 0 : a,\n          c = t.distance,\n          h = void 0 === c ? 100 : c,\n          l = r / e.length,\n          u = Math.abs(s - i);\n      return h ? l + u / h : u ? 1 : l;\n    };\n  }, function (e, t) {\n    e.exports = function () {\n      for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = [], r = -1, o = -1, i = 0, a = e.length; i < a; i += 1) {\n        var s = e[i];\n        s && -1 === r ? r = i : s || -1 === r || ((o = i - 1) - r + 1 >= t && n.push([r, o]), r = -1);\n      }\n\n      return e[i - 1] && i - r >= t && n.push([r, i - 1]), n;\n    };\n  }, function (e, t) {\n    e.exports = function (e) {\n      for (var t = {}, n = e.length, r = 0; r < n; r += 1) {\n        t[e.charAt(r)] = 0;\n      }\n\n      for (var o = 0; o < n; o += 1) {\n        t[e.charAt(o)] |= 1 << n - o - 1;\n      }\n\n      return t;\n    };\n  }, function (e, t, n) {\n    var r = n(0);\n\n    e.exports = function (e, t) {\n      return function e(t, n, o) {\n        if (n) {\n          var i = n.indexOf("."),\n              a = n,\n              s = null;\n          -1 !== i && (a = n.slice(0, i), s = n.slice(i + 1));\n          var c = t[a];\n          if (null != c) if (s || "string" != typeof c && "number" != typeof c) {\n            if (r(c)) for (var h = 0, l = c.length; h < l; h += 1) {\n              e(c[h], s, o);\n            } else s && e(c, s, o);\n          } else o.push(c.toString());\n        } else o.push(t);\n\n        return o;\n      }(e, t, []);\n    };\n  }]);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))\n\n//# sourceURL=webpack:///./node_modules/fuse.js/dist/fuse.js?')},"./node_modules/iframe-resizer/js/iframeResizer.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * File: iframeResizer.js\n * Desc: Force iframes to size to content.\n * Requires: iframeResizer.contentWindow.js to be loaded into the target frame.\n * Doc: https://github.com/davidjbradshaw/iframe-resizer\n * Author: David J. Bradshaw - dave@bradshaw.net\n * Contributor: Jure Mav - jure.mav@gmail.com\n * Contributor: Reed Dadoune - reed@dadoune.com\n */\n(function (undefined) {\n  'use strict';\n\n  if (typeof window === 'undefined') return; // don't run for server side render\n\n  var count = 0,\n      logEnabled = false,\n      hiddenCheckEnabled = false,\n      msgHeader = 'message',\n      msgHeaderLen = msgHeader.length,\n      msgId = '[iFrameSizer]',\n      //Must match iframe msg ID\n  msgIdLen = msgId.length,\n      pagePosition = null,\n      requestAnimationFrame = window.requestAnimationFrame,\n      resetRequiredMethods = {\n    max: 1,\n    scroll: 1,\n    bodyScroll: 1,\n    documentElementScroll: 1\n  },\n      settings = {},\n      timer = null,\n      logId = 'Host Page',\n      defaults = {\n    autoResize: true,\n    bodyBackground: null,\n    bodyMargin: null,\n    bodyMarginV1: 8,\n    bodyPadding: null,\n    checkOrigin: true,\n    inPageLinks: false,\n    enablePublicMethods: true,\n    heightCalculationMethod: 'bodyOffset',\n    id: 'iFrameResizer',\n    interval: 32,\n    log: false,\n    maxHeight: Infinity,\n    maxWidth: Infinity,\n    minHeight: 0,\n    minWidth: 0,\n    resizeFrom: 'parent',\n    scrolling: false,\n    sizeHeight: true,\n    sizeWidth: false,\n    warningTimeout: 5000,\n    tolerance: 0,\n    widthCalculationMethod: 'scroll',\n    closedCallback: function closedCallback() {},\n    initCallback: function initCallback() {},\n    messageCallback: function messageCallback() {\n      warn('MessageCallback function not defined');\n    },\n    resizedCallback: function resizedCallback() {},\n    scrollCallback: function scrollCallback() {\n      return true;\n    }\n  };\n\n  function getMutationObserver() {\n    return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n  }\n\n  function addEventListener(obj, evt, func) {\n    /* istanbul ignore else */\n    // Not testable in PhantonJS\n    if ('addEventListener' in window) {\n      obj.addEventListener(evt, func, false);\n    } else if ('attachEvent' in window) {\n      //IE\n      obj.attachEvent('on' + evt, func);\n    }\n  }\n\n  function removeEventListener(el, evt, func) {\n    /* istanbul ignore else */\n    // Not testable in phantonJS\n    if ('removeEventListener' in window) {\n      el.removeEventListener(evt, func, false);\n    } else if ('detachEvent' in window) {\n      //IE\n      el.detachEvent('on' + evt, func);\n    }\n  }\n\n  function setupRequestAnimationFrame() {\n    var vendors = ['moz', 'webkit', 'o', 'ms'],\n        x; // Remove vendor prefixing if prefixed and break early if not\n\n    for (x = 0; x < vendors.length && !requestAnimationFrame; x += 1) {\n      requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    }\n\n    if (!requestAnimationFrame) {\n      log('setup', 'RequestAnimationFrame not supported');\n    }\n  }\n\n  function getMyID(iframeId) {\n    var retStr = 'Host page: ' + iframeId;\n\n    if (window.top !== window.self) {\n      if (window.parentIFrame && window.parentIFrame.getId) {\n        retStr = window.parentIFrame.getId() + ': ' + iframeId;\n      } else {\n        retStr = 'Nested host page: ' + iframeId;\n      }\n    }\n\n    return retStr;\n  }\n\n  function formatLogHeader(iframeId) {\n    return msgId + '[' + getMyID(iframeId) + ']';\n  }\n\n  function isLogEnabled(iframeId) {\n    return settings[iframeId] ? settings[iframeId].log : logEnabled;\n  }\n\n  function log(iframeId, msg) {\n    output('log', iframeId, msg, isLogEnabled(iframeId));\n  }\n\n  function info(iframeId, msg) {\n    output('info', iframeId, msg, isLogEnabled(iframeId));\n  }\n\n  function warn(iframeId, msg) {\n    output('warn', iframeId, msg, true);\n  }\n\n  function output(type, iframeId, msg, enabled) {\n    if (true === enabled && 'object' === _typeof(window.console)) {\n      console[type](formatLogHeader(iframeId), msg);\n    }\n  }\n\n  function iFrameListener(event) {\n    function resizeIFrame() {\n      function resize() {\n        setSize(messageData);\n        setPagePosition(iframeId);\n        callback('resizedCallback', messageData);\n      }\n\n      ensureInRange('Height');\n      ensureInRange('Width');\n      syncResize(resize, messageData, 'init');\n    }\n\n    function processMsg() {\n      var data = msg.substr(msgIdLen).split(':');\n      return {\n        iframe: settings[data[0]] && settings[data[0]].iframe,\n        id: data[0],\n        height: data[1],\n        width: data[2],\n        type: data[3]\n      };\n    }\n\n    function ensureInRange(Dimension) {\n      var max = Number(settings[iframeId]['max' + Dimension]),\n          min = Number(settings[iframeId]['min' + Dimension]),\n          dimension = Dimension.toLowerCase(),\n          size = Number(messageData[dimension]);\n      log(iframeId, 'Checking ' + dimension + ' is in range ' + min + '-' + max);\n\n      if (size < min) {\n        size = min;\n        log(iframeId, 'Set ' + dimension + ' to min value');\n      }\n\n      if (size > max) {\n        size = max;\n        log(iframeId, 'Set ' + dimension + ' to max value');\n      }\n\n      messageData[dimension] = '' + size;\n    }\n\n    function isMessageFromIFrame() {\n      function checkAllowedOrigin() {\n        function checkList() {\n          var i = 0,\n              retCode = false;\n          log(iframeId, 'Checking connection is from allowed list of origins: ' + checkOrigin);\n\n          for (; i < checkOrigin.length; i++) {\n            if (checkOrigin[i] === origin) {\n              retCode = true;\n              break;\n            }\n          }\n\n          return retCode;\n        }\n\n        function checkSingle() {\n          var remoteHost = settings[iframeId] && settings[iframeId].remoteHost;\n          log(iframeId, 'Checking connection is from: ' + remoteHost);\n          return origin === remoteHost;\n        }\n\n        return checkOrigin.constructor === Array ? checkList() : checkSingle();\n      }\n\n      var origin = event.origin,\n          checkOrigin = settings[iframeId] && settings[iframeId].checkOrigin;\n\n      if (checkOrigin && '' + origin !== 'null' && !checkAllowedOrigin()) {\n        throw new Error('Unexpected message received from: ' + origin + ' for ' + messageData.iframe.id + '. Message was: ' + event.data + '. This error can be disabled by setting the checkOrigin: false option or by providing of array of trusted domains.');\n      }\n\n      return true;\n    }\n\n    function isMessageForUs() {\n      return msgId === ('' + msg).substr(0, msgIdLen) && msg.substr(msgIdLen).split(':')[0] in settings; //''+Protects against non-string msg\n    }\n\n    function isMessageFromMetaParent() {\n      //Test if this message is from a parent above us. This is an ugly test, however, updating\n      //the message format would break backwards compatibity.\n      var retCode = messageData.type in {\n        true: 1,\n        false: 1,\n        undefined: 1\n      };\n\n      if (retCode) {\n        log(iframeId, 'Ignoring init message from meta parent page');\n      }\n\n      return retCode;\n    }\n\n    function getMsgBody(offset) {\n      return msg.substr(msg.indexOf(':') + msgHeaderLen + offset);\n    }\n\n    function forwardMsgFromIFrame(msgBody) {\n      log(iframeId, 'MessageCallback passed: {iframe: ' + messageData.iframe.id + ', message: ' + msgBody + '}');\n      callback('messageCallback', {\n        iframe: messageData.iframe,\n        message: JSON.parse(msgBody)\n      });\n      log(iframeId, '--');\n    }\n\n    function getPageInfo() {\n      var bodyPosition = document.body.getBoundingClientRect(),\n          iFramePosition = messageData.iframe.getBoundingClientRect();\n      return JSON.stringify({\n        iframeHeight: iFramePosition.height,\n        iframeWidth: iFramePosition.width,\n        clientHeight: Math.max(document.documentElement.clientHeight, window.innerHeight || 0),\n        clientWidth: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\n        offsetTop: parseInt(iFramePosition.top - bodyPosition.top, 10),\n        offsetLeft: parseInt(iFramePosition.left - bodyPosition.left, 10),\n        scrollTop: window.pageYOffset,\n        scrollLeft: window.pageXOffset\n      });\n    }\n\n    function sendPageInfoToIframe(iframe, iframeId) {\n      function debouncedTrigger() {\n        trigger('Send Page Info', 'pageInfo:' + getPageInfo(), iframe, iframeId);\n      }\n\n      debounceFrameEvents(debouncedTrigger, 32, iframeId);\n    }\n\n    function startPageInfoMonitor() {\n      function setListener(type, func) {\n        function sendPageInfo() {\n          if (settings[id]) {\n            sendPageInfoToIframe(settings[id].iframe, id);\n          } else {\n            stop();\n          }\n        }\n\n        ['scroll', 'resize'].forEach(function (evt) {\n          log(id, type + evt + ' listener for sendPageInfo');\n          func(window, evt, sendPageInfo);\n        });\n      }\n\n      function stop() {\n        setListener('Remove ', removeEventListener);\n      }\n\n      function start() {\n        setListener('Add ', addEventListener);\n      }\n\n      var id = iframeId; //Create locally scoped copy of iFrame ID\n\n      start();\n\n      if (settings[id]) {\n        settings[id].stopPageInfo = stop;\n      }\n    }\n\n    function stopPageInfoMonitor() {\n      if (settings[iframeId] && settings[iframeId].stopPageInfo) {\n        settings[iframeId].stopPageInfo();\n        delete settings[iframeId].stopPageInfo;\n      }\n    }\n\n    function checkIFrameExists() {\n      var retBool = true;\n\n      if (null === messageData.iframe) {\n        warn(iframeId, 'IFrame (' + messageData.id + ') not found');\n        retBool = false;\n      }\n\n      return retBool;\n    }\n\n    function getElementPosition(target) {\n      var iFramePosition = target.getBoundingClientRect();\n      getPagePosition(iframeId);\n      return {\n        x: Math.floor(Number(iFramePosition.left) + Number(pagePosition.x)),\n        y: Math.floor(Number(iFramePosition.top) + Number(pagePosition.y))\n      };\n    }\n\n    function scrollRequestFromChild(addOffset) {\n      /* istanbul ignore next */\n      //Not testable in Karma\n      function reposition() {\n        pagePosition = newPosition;\n        scrollTo();\n        log(iframeId, '--');\n      }\n\n      function calcOffset() {\n        return {\n          x: Number(messageData.width) + offset.x,\n          y: Number(messageData.height) + offset.y\n        };\n      }\n\n      function scrollParent() {\n        if (window.parentIFrame) {\n          window.parentIFrame['scrollTo' + (addOffset ? 'Offset' : '')](newPosition.x, newPosition.y);\n        } else {\n          warn(iframeId, 'Unable to scroll to requested position, window.parentIFrame not found');\n        }\n      }\n\n      var offset = addOffset ? getElementPosition(messageData.iframe) : {\n        x: 0,\n        y: 0\n      },\n          newPosition = calcOffset();\n      log(iframeId, 'Reposition requested from iFrame (offset x:' + offset.x + ' y:' + offset.y + ')');\n\n      if (window.top !== window.self) {\n        scrollParent();\n      } else {\n        reposition();\n      }\n    }\n\n    function scrollTo() {\n      if (false !== callback('scrollCallback', pagePosition)) {\n        setPagePosition(iframeId);\n      } else {\n        unsetPagePosition();\n      }\n    }\n\n    function findTarget(location) {\n      function jumpToTarget() {\n        var jumpPosition = getElementPosition(target);\n        log(iframeId, 'Moving to in page link (#' + hash + ') at x: ' + jumpPosition.x + ' y: ' + jumpPosition.y);\n        pagePosition = {\n          x: jumpPosition.x,\n          y: jumpPosition.y\n        };\n        scrollTo();\n        log(iframeId, '--');\n      }\n\n      function jumpToParent() {\n        if (window.parentIFrame) {\n          window.parentIFrame.moveToAnchor(hash);\n        } else {\n          log(iframeId, 'In page link #' + hash + ' not found and window.parentIFrame not found');\n        }\n      }\n\n      var hash = location.split('#')[1] || '',\n          hashData = decodeURIComponent(hash),\n          target = document.getElementById(hashData) || document.getElementsByName(hashData)[0];\n\n      if (target) {\n        jumpToTarget();\n      } else if (window.top !== window.self) {\n        jumpToParent();\n      } else {\n        log(iframeId, 'In page link #' + hash + ' not found');\n      }\n    }\n\n    function callback(funcName, val) {\n      return chkCallback(iframeId, funcName, val);\n    }\n\n    function actionMsg() {\n      if (settings[iframeId] && settings[iframeId].firstRun) firstRun();\n\n      switch (messageData.type) {\n        case 'close':\n          if (settings[iframeId].closeRequestCallback) chkCallback(iframeId, 'closeRequestCallback', settings[iframeId].iframe);else closeIFrame(messageData.iframe);\n          break;\n\n        case 'message':\n          forwardMsgFromIFrame(getMsgBody(6));\n          break;\n\n        case 'scrollTo':\n          scrollRequestFromChild(false);\n          break;\n\n        case 'scrollToOffset':\n          scrollRequestFromChild(true);\n          break;\n\n        case 'pageInfo':\n          sendPageInfoToIframe(settings[iframeId] && settings[iframeId].iframe, iframeId);\n          startPageInfoMonitor();\n          break;\n\n        case 'pageInfoStop':\n          stopPageInfoMonitor();\n          break;\n\n        case 'inPageLink':\n          findTarget(getMsgBody(9));\n          break;\n\n        case 'reset':\n          resetIFrame(messageData);\n          break;\n\n        case 'init':\n          resizeIFrame();\n          callback('initCallback', messageData.iframe);\n          break;\n\n        default:\n          resizeIFrame();\n      }\n    }\n\n    function hasSettings(iframeId) {\n      var retBool = true;\n\n      if (!settings[iframeId]) {\n        retBool = false;\n        warn(messageData.type + ' No settings for ' + iframeId + '. Message was: ' + msg);\n      }\n\n      return retBool;\n    }\n\n    function iFrameReadyMsgReceived() {\n      for (var iframeId in settings) {\n        trigger('iFrame requested init', createOutgoingMsg(iframeId), document.getElementById(iframeId), iframeId);\n      }\n    }\n\n    function firstRun() {\n      if (settings[iframeId]) {\n        settings[iframeId].firstRun = false;\n      }\n    }\n\n    function clearWarningTimeout() {\n      if (settings[iframeId]) {\n        clearTimeout(settings[iframeId].msgTimeout);\n        settings[iframeId].warningTimeout = 0;\n      }\n    }\n\n    var msg = event.data,\n        messageData = {},\n        iframeId = null;\n\n    if ('[iFrameResizerChild]Ready' === msg) {\n      iFrameReadyMsgReceived();\n    } else if (isMessageForUs()) {\n      messageData = processMsg();\n      iframeId = logId = messageData.id;\n\n      if (settings[iframeId]) {\n        settings[iframeId].loaded = true;\n      }\n\n      if (!isMessageFromMetaParent() && hasSettings(iframeId)) {\n        log(iframeId, 'Received: ' + msg);\n\n        if (checkIFrameExists() && isMessageFromIFrame()) {\n          actionMsg();\n        }\n      }\n    } else {\n      info(iframeId, 'Ignored: ' + msg);\n    }\n  }\n\n  function chkCallback(iframeId, funcName, val) {\n    var func = null,\n        retVal = null;\n\n    if (settings[iframeId]) {\n      func = settings[iframeId][funcName];\n\n      if ('function' === typeof func) {\n        retVal = func(val);\n      } else {\n        throw new TypeError(funcName + ' on iFrame[' + iframeId + '] is not a function');\n      }\n    }\n\n    return retVal;\n  }\n\n  function removeIframeListeners(iframe) {\n    var iframeId = iframe.id;\n    delete settings[iframeId];\n  }\n\n  function closeIFrame(iframe) {\n    var iframeId = iframe.id;\n    log(iframeId, 'Removing iFrame: ' + iframeId);\n\n    try {\n      // Catch race condition error with React\n      if (iframe.parentNode) {\n        iframe.parentNode.removeChild(iframe);\n      }\n    } catch (e) {}\n\n    chkCallback(iframeId, 'closedCallback', iframeId);\n    log(iframeId, '--');\n    removeIframeListeners(iframe);\n  }\n\n  function getPagePosition(iframeId) {\n    if (null === pagePosition) {\n      pagePosition = {\n        x: window.pageXOffset !== undefined ? window.pageXOffset : document.documentElement.scrollLeft,\n        y: window.pageYOffset !== undefined ? window.pageYOffset : document.documentElement.scrollTop\n      };\n      log(iframeId, 'Get page position: ' + pagePosition.x + ',' + pagePosition.y);\n    }\n  }\n\n  function setPagePosition(iframeId) {\n    if (null !== pagePosition) {\n      window.scrollTo(pagePosition.x, pagePosition.y);\n      log(iframeId, 'Set page position: ' + pagePosition.x + ',' + pagePosition.y);\n      unsetPagePosition();\n    }\n  }\n\n  function unsetPagePosition() {\n    pagePosition = null;\n  }\n\n  function resetIFrame(messageData) {\n    function reset() {\n      setSize(messageData);\n      trigger('reset', 'reset', messageData.iframe, messageData.id);\n    }\n\n    log(messageData.id, 'Size reset requested by ' + ('init' === messageData.type ? 'host page' : 'iFrame'));\n    getPagePosition(messageData.id);\n    syncResize(reset, messageData, 'reset');\n  }\n\n  function setSize(messageData) {\n    function setDimension(dimension) {\n      if (!messageData.id) {\n        log('undefined', 'messageData id not set');\n        return;\n      }\n\n      messageData.iframe.style[dimension] = messageData[dimension] + 'px';\n      log(messageData.id, 'IFrame (' + iframeId + ') ' + dimension + ' set to ' + messageData[dimension] + 'px');\n    }\n\n    function chkZero(dimension) {\n      //FireFox sets dimension of hidden iFrames to zero.\n      //So if we detect that set up an event to check for\n      //when iFrame becomes visible.\n\n      /* istanbul ignore next */\n      //Not testable in PhantomJS\n      if (!hiddenCheckEnabled && '0' === messageData[dimension]) {\n        hiddenCheckEnabled = true;\n        log(iframeId, 'Hidden iFrame detected, creating visibility listener');\n        fixHiddenIFrames();\n      }\n    }\n\n    function processDimension(dimension) {\n      setDimension(dimension);\n      chkZero(dimension);\n    }\n\n    var iframeId = messageData.iframe.id;\n\n    if (settings[iframeId]) {\n      if (settings[iframeId].sizeHeight) {\n        processDimension('height');\n      }\n\n      if (settings[iframeId].sizeWidth) {\n        processDimension('width');\n      }\n    }\n  }\n\n  function syncResize(func, messageData, doNotSync) {\n    /* istanbul ignore if */\n    //Not testable in PhantomJS\n    if (doNotSync !== messageData.type && requestAnimationFrame) {\n      log(messageData.id, 'Requesting animation frame');\n      requestAnimationFrame(func);\n    } else {\n      func();\n    }\n  }\n\n  function trigger(calleeMsg, msg, iframe, id, noResponseWarning) {\n    function postMessageToIFrame() {\n      var target = settings[id] && settings[id].targetOrigin;\n      log(id, '[' + calleeMsg + '] Sending msg to iframe[' + id + '] (' + msg + ') targetOrigin: ' + target);\n      iframe.contentWindow.postMessage(msgId + msg, target);\n    }\n\n    function iFrameNotFound() {\n      warn(id, '[' + calleeMsg + '] IFrame(' + id + ') not found');\n    }\n\n    function chkAndSend() {\n      if (iframe && 'contentWindow' in iframe && null !== iframe.contentWindow) {\n        //Null test for PhantomJS\n        postMessageToIFrame();\n      } else {\n        iFrameNotFound();\n      }\n    }\n\n    function warnOnNoResponse() {\n      function warning() {\n        if (settings[id] && !settings[id].loaded && !errorShown) {\n          errorShown = true;\n          warn(id, 'IFrame has not responded within ' + settings[id].warningTimeout / 1000 + ' seconds. Check iFrameResizer.contentWindow.js has been loaded in iFrame. This message can be ignored if everything is working, or you can set the warningTimeout option to a higher value or zero to suppress this warning.');\n        }\n      }\n\n      if (!!noResponseWarning && settings[id] && !!settings[id].warningTimeout) {\n        settings[id].msgTimeout = setTimeout(warning, settings[id].warningTimeout);\n      }\n    }\n\n    var errorShown = false;\n    id = id || iframe.id;\n\n    if (settings[id]) {\n      chkAndSend();\n      warnOnNoResponse();\n    }\n  }\n\n  function createOutgoingMsg(iframeId) {\n    return iframeId + ':' + settings[iframeId].bodyMarginV1 + ':' + settings[iframeId].sizeWidth + ':' + settings[iframeId].log + ':' + settings[iframeId].interval + ':' + settings[iframeId].enablePublicMethods + ':' + settings[iframeId].autoResize + ':' + settings[iframeId].bodyMargin + ':' + settings[iframeId].heightCalculationMethod + ':' + settings[iframeId].bodyBackground + ':' + settings[iframeId].bodyPadding + ':' + settings[iframeId].tolerance + ':' + settings[iframeId].inPageLinks + ':' + settings[iframeId].resizeFrom + ':' + settings[iframeId].widthCalculationMethod;\n  }\n\n  function setupIFrame(iframe, options) {\n    function setLimits() {\n      function addStyle(style) {\n        if (Infinity !== settings[iframeId][style] && 0 !== settings[iframeId][style]) {\n          iframe.style[style] = settings[iframeId][style] + 'px';\n          log(iframeId, 'Set ' + style + ' = ' + settings[iframeId][style] + 'px');\n        }\n      }\n\n      function chkMinMax(dimension) {\n        if (settings[iframeId]['min' + dimension] > settings[iframeId]['max' + dimension]) {\n          throw new Error('Value for min' + dimension + ' can not be greater than max' + dimension);\n        }\n      }\n\n      chkMinMax('Height');\n      chkMinMax('Width');\n      addStyle('maxHeight');\n      addStyle('minHeight');\n      addStyle('maxWidth');\n      addStyle('minWidth');\n    }\n\n    function newId() {\n      var id = options && options.id || defaults.id + count++;\n\n      if (null !== document.getElementById(id)) {\n        id = id + count++;\n      }\n\n      return id;\n    }\n\n    function ensureHasId(iframeId) {\n      logId = iframeId;\n\n      if ('' === iframeId) {\n        iframe.id = iframeId = newId();\n        logEnabled = (options || {}).log;\n        logId = iframeId;\n        log(iframeId, 'Added missing iframe ID: ' + iframeId + ' (' + iframe.src + ')');\n      }\n\n      return iframeId;\n    }\n\n    function setScrolling() {\n      log(iframeId, 'IFrame scrolling ' + (settings[iframeId] && settings[iframeId].scrolling ? 'enabled' : 'disabled') + ' for ' + iframeId);\n      iframe.style.overflow = false === (settings[iframeId] && settings[iframeId].scrolling) ? 'hidden' : 'auto';\n\n      switch (settings[iframeId] && settings[iframeId].scrolling) {\n        case 'omit':\n          break;\n\n        case true:\n          iframe.scrolling = 'yes';\n          break;\n\n        case false:\n          iframe.scrolling = 'no';\n          break;\n\n        default:\n          iframe.scrolling = settings[iframeId] ? settings[iframeId].scrolling : 'no';\n      }\n    } //The V1 iFrame script expects an int, where as in V2 expects a CSS\n    //string value such as '1px 3em', so if we have an int for V2, set V1=V2\n    //and then convert V2 to a string PX value.\n\n\n    function setupBodyMarginValues() {\n      if ('number' === typeof (settings[iframeId] && settings[iframeId].bodyMargin) || '0' === (settings[iframeId] && settings[iframeId].bodyMargin)) {\n        settings[iframeId].bodyMarginV1 = settings[iframeId].bodyMargin;\n        settings[iframeId].bodyMargin = '' + settings[iframeId].bodyMargin + 'px';\n      }\n    }\n\n    function checkReset() {\n      // Reduce scope of firstRun to function, because IE8's JS execution\n      // context stack is borked and this value gets externally\n      // changed midway through running this function!!!\n      var firstRun = settings[iframeId] && settings[iframeId].firstRun,\n          resetRequertMethod = settings[iframeId] && settings[iframeId].heightCalculationMethod in resetRequiredMethods;\n\n      if (!firstRun && resetRequertMethod) {\n        resetIFrame({\n          iframe: iframe,\n          height: 0,\n          width: 0,\n          type: 'init'\n        });\n      }\n    }\n\n    function setupIFrameObject() {\n      if (Function.prototype.bind && settings[iframeId]) {\n        //Ignore unpolyfilled IE8.\n        settings[iframeId].iframe.iFrameResizer = {\n          close: closeIFrame.bind(null, settings[iframeId].iframe),\n          removeListeners: removeIframeListeners.bind(null, settings[iframeId].iframe),\n          resize: trigger.bind(null, 'Window resize', 'resize', settings[iframeId].iframe),\n          moveToAnchor: function moveToAnchor(anchor) {\n            trigger('Move to anchor', 'moveToAnchor:' + anchor, settings[iframeId].iframe, iframeId);\n          },\n          sendMessage: function sendMessage(message) {\n            message = JSON.stringify(message);\n            trigger('Send Message', 'message:' + message, settings[iframeId].iframe, iframeId);\n          }\n        };\n      }\n    } //We have to call trigger twice, as we can not be sure if all\n    //iframes have completed loading when this code runs. The\n    //event listener also catches the page changing in the iFrame.\n\n\n    function init(msg) {\n      function iFrameLoaded() {\n        trigger('iFrame.onload', msg, iframe, undefined, true);\n        checkReset();\n      }\n\n      function createDestroyObserver(MutationObserver) {\n        if (!iframe.parentNode) {\n          return;\n        }\n\n        var destroyObserver = new MutationObserver(function (mutations) {\n          mutations.forEach(function (mutation) {\n            var removedNodes = Array.prototype.slice.call(mutation.removedNodes); // Transform NodeList into an Array\n\n            removedNodes.forEach(function (removedNode) {\n              if (removedNode === iframe) {\n                closeIFrame(iframe);\n              }\n            });\n          });\n        });\n        destroyObserver.observe(iframe.parentNode, {\n          childList: true\n        });\n      }\n\n      var MutationObserver = getMutationObserver();\n\n      if (MutationObserver) {\n        createDestroyObserver(MutationObserver);\n      }\n\n      addEventListener(iframe, 'load', iFrameLoaded);\n      trigger('init', msg, iframe, undefined, true);\n    }\n\n    function checkOptions(options) {\n      if ('object' !== _typeof(options)) {\n        throw new TypeError('Options is not an object');\n      }\n    }\n\n    function copyOptions(options) {\n      for (var option in defaults) {\n        if (defaults.hasOwnProperty(option)) {\n          settings[iframeId][option] = options.hasOwnProperty(option) ? options[option] : defaults[option];\n        }\n      }\n    }\n\n    function getTargetOrigin(remoteHost) {\n      return '' === remoteHost || 'file://' === remoteHost ? '*' : remoteHost;\n    }\n\n    function processOptions(options) {\n      options = options || {};\n      settings[iframeId] = {\n        firstRun: true,\n        iframe: iframe,\n        remoteHost: iframe.src.split('/').slice(0, 3).join('/')\n      };\n      checkOptions(options);\n      copyOptions(options);\n\n      if (settings[iframeId]) {\n        settings[iframeId].targetOrigin = true === settings[iframeId].checkOrigin ? getTargetOrigin(settings[iframeId].remoteHost) : '*';\n      }\n    }\n\n    function beenHere() {\n      return iframeId in settings && 'iFrameResizer' in iframe;\n    }\n\n    var iframeId = ensureHasId(iframe.id);\n\n    if (!beenHere()) {\n      processOptions(options);\n      setScrolling();\n      setLimits();\n      setupBodyMarginValues();\n      init(createOutgoingMsg(iframeId));\n      setupIFrameObject();\n    } else {\n      warn(iframeId, 'Ignored iFrame, already setup.');\n    }\n  }\n\n  function debouce(fn, time) {\n    if (null === timer) {\n      timer = setTimeout(function () {\n        timer = null;\n        fn();\n      }, time);\n    }\n  }\n\n  var frameTimer = {};\n\n  function debounceFrameEvents(fn, time, frameId) {\n    if (!frameTimer[frameId]) {\n      frameTimer[frameId] = setTimeout(function () {\n        frameTimer[frameId] = null;\n        fn();\n      }, time);\n    }\n  } //Not testable in PhantomJS\n\n  /* istanbul ignore next */\n\n\n  function fixHiddenIFrames() {\n    function checkIFrames() {\n      function checkIFrame(settingId) {\n        function chkDimension(dimension) {\n          return '0px' === (settings[settingId] && settings[settingId].iframe.style[dimension]);\n        }\n\n        function isVisible(el) {\n          return null !== el.offsetParent;\n        }\n\n        if (settings[settingId] && isVisible(settings[settingId].iframe) && (chkDimension('height') || chkDimension('width'))) {\n          trigger('Visibility change', 'resize', settings[settingId].iframe, settingId);\n        }\n      }\n\n      for (var settingId in settings) {\n        checkIFrame(settingId);\n      }\n    }\n\n    function mutationObserved(mutations) {\n      log('window', 'Mutation observed: ' + mutations[0].target + ' ' + mutations[0].type);\n      debouce(checkIFrames, 16);\n    }\n\n    function createMutationObserver() {\n      var target = document.querySelector('body'),\n          config = {\n        attributes: true,\n        attributeOldValue: false,\n        characterData: true,\n        characterDataOldValue: false,\n        childList: true,\n        subtree: true\n      },\n          observer = new MutationObserver(mutationObserved);\n      observer.observe(target, config);\n    }\n\n    var MutationObserver = getMutationObserver();\n\n    if (MutationObserver) {\n      createMutationObserver();\n    }\n  }\n\n  function resizeIFrames(event) {\n    function resize() {\n      sendTriggerMsg('Window ' + event, 'resize');\n    }\n\n    log('window', 'Trigger event: ' + event);\n    debouce(resize, 16);\n  } //Not testable in PhantomJS\n\n  /* istanbul ignore next */\n\n\n  function tabVisible() {\n    function resize() {\n      sendTriggerMsg('Tab Visable', 'resize');\n    }\n\n    if ('hidden' !== document.visibilityState) {\n      log('document', 'Trigger event: Visiblity change');\n      debouce(resize, 16);\n    }\n  }\n\n  function sendTriggerMsg(eventName, event) {\n    function isIFrameResizeEnabled(iframeId) {\n      return settings[iframeId] && 'parent' === settings[iframeId].resizeFrom && settings[iframeId].autoResize && !settings[iframeId].firstRun;\n    }\n\n    for (var iframeId in settings) {\n      if (isIFrameResizeEnabled(iframeId)) {\n        trigger(eventName, event, document.getElementById(iframeId), iframeId);\n      }\n    }\n  }\n\n  function setupEventListeners() {\n    addEventListener(window, 'message', iFrameListener);\n    addEventListener(window, 'resize', function () {\n      resizeIFrames('resize');\n    });\n    addEventListener(document, 'visibilitychange', tabVisible);\n    addEventListener(document, '-webkit-visibilitychange', tabVisible); //Andriod 4.4\n\n    addEventListener(window, 'focusin', function () {\n      resizeIFrames('focus');\n    }); //IE8-9\n\n    addEventListener(window, 'focus', function () {\n      resizeIFrames('focus');\n    });\n  }\n\n  function factory() {\n    function init(options, element) {\n      function chkType() {\n        if (!element.tagName) {\n          throw new TypeError('Object is not a valid DOM element');\n        } else if ('IFRAME' !== element.tagName.toUpperCase()) {\n          throw new TypeError('Expected <IFRAME> tag, found <' + element.tagName + '>');\n        }\n      }\n\n      if (element) {\n        chkType();\n        setupIFrame(element, options);\n        iFrames.push(element);\n      }\n    }\n\n    function warnDeprecatedOptions(options) {\n      if (options && options.enablePublicMethods) {\n        warn('enablePublicMethods option has been removed, public methods are now always available in the iFrame');\n      }\n    }\n\n    var iFrames;\n    setupRequestAnimationFrame();\n    setupEventListeners();\n    return function iFrameResizeF(options, target) {\n      iFrames = []; //Only return iFrames past in on this call\n\n      warnDeprecatedOptions(options);\n\n      switch (_typeof(target)) {\n        case 'undefined':\n        case 'string':\n          Array.prototype.forEach.call(document.querySelectorAll(target || 'iframe'), init.bind(undefined, options));\n          break;\n\n        case 'object':\n          init(options, target);\n          break;\n\n        default:\n          throw new TypeError('Unexpected data type (' + _typeof(target) + ')');\n      }\n\n      return iFrames;\n    };\n  }\n\n  function createJQueryPublicMethod($) {\n    if (!$.fn) {\n      info('', 'Unable to bind to jQuery, it is not fully loaded.');\n    } else if (!$.fn.iFrameResize) {\n      $.fn.iFrameResize = function $iFrameResizeF(options) {\n        function init(index, element) {\n          setupIFrame(element, options);\n        }\n\n        return this.filter('iframe').each(init).end();\n      };\n    }\n  }\n\n  if (window.jQuery) {\n    createJQueryPublicMethod(window.jQuery);\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n  window.iFrameResize = window.iFrameResize || factory();\n})();\n\n//# sourceURL=webpack:///./node_modules/iframe-resizer/js/iframeResizer.js?")},"./node_modules/mousetrap/mousetrap.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.2\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n\n\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n\n  var _REVERSE_MAP;\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n\n\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n\n\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n\n\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n\n    object.attachEvent('on' + type, callback);\n  }\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n\n\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n\n      return character;\n    } // for non keypress events the special maps are needed\n\n\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    } // if it is not in the special map\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n\n\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n\n\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n\n\n  function _eventModifiers(e) {\n    var modifiers = [];\n\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n\n    return modifiers;\n  }\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n\n    e.returnValue = false;\n  }\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n\n    e.cancelBubble = true;\n  }\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n\n\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n\n    return _REVERSE_MAP;\n  }\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n\n\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    } // modifier keys don't work as expected with keypress,\n    // switch to keydown\n\n\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n\n    return action;\n  }\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n\n\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n\n\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = []; // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n\n    keys = _keysFromString(combination);\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i]; // normalize key names\n\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      } // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n\n\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      } // if this key is a modifier then add it to the list of modifiers\n\n\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    } // depending on what the key combination is\n    // we will try to pick the best event for it\n\n\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n\n    if (element === ancestor) {\n      return true;\n    }\n\n    return _belongsTo(element.parentNode, ancestor);\n  }\n\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n\n\n    self.target = targetElement;\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n\n    self._callbacks = {};\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n\n    self._directMap = {};\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n\n    var _sequenceLevels = {};\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n\n    var _resetTimer;\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n\n\n    var _ignoreNextKeyup = false;\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n\n    var _ignoreNextKeypress = false;\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n\n    var _nextExpectedAction = false;\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n          key;\n\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n\n        _sequenceLevels[key] = 0;\n      }\n\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n\n\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type; // if there are no events related to this keycode\n\n      if (!self._callbacks[character]) {\n        return [];\n      } // if a modifier key is coming up on its own we should allow it\n\n\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      } // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n\n\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        } // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n\n\n        if (action != callback.action) {\n          continue;\n        } // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n\n\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n\n          matches.push(callback);\n        }\n      }\n\n      return matches;\n    }\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n\n        _stopPropagation(e);\n      }\n    }\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      } // loop through matching callbacks for this key event\n\n\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n\n          processedSequenceCallback = true; // keep a list of which sequences were matches for later\n\n          doNotReset[callbacks[i].seq] = 1;\n\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\n          continue;\n        } // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n\n\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      } // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n\n\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n\n      var character = _characterFromEvent(e); // no character found then stop\n\n\n      if (!character) {\n        return;\n      } // need to use === for the character check because the character can be 0\n\n\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n\n\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n\n\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n\n          _resetSequenceTimer();\n        };\n      }\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n\n\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n\n\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        } // weird race condition if a sequence ends with the key\n        // another sequence begins with\n\n\n        setTimeout(_resetSequences, 10);\n      } // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n\n\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n\n\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space\n\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info; // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n\n        return;\n      }\n\n      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time\n      // a callback is added for this key\n\n      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one\n\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level); // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n\n\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n\n\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    }; // start!\n\n\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n\n    self._bindMultiple.call(self, keys, callback, action);\n\n    return self;\n  };\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n\n    return self;\n  };\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this; // if the element has the class \"mousetrap\" then no need to stop\n\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    if (_belongsTo(element, self.target)) {\n      return false;\n    } // stop for input, select, and textarea\n\n\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n\n\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n  /**\n   * allow custom key mappings\n   */\n\n\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n\n    _REVERSE_MAP = null;\n  };\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n\n\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n\n  Mousetrap.init(); // expose mousetrap to the global object\n\n  window.Mousetrap = Mousetrap; // expose as a common js module\n\n  if ( true && module.exports) {\n    module.exports = Mousetrap;\n  } // expose mousetrap as an AMD module\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Mousetrap;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);\n\n//# sourceURL=webpack:///./node_modules/mousetrap/mousetrap.js?")},"./node_modules/preact-compat/dist/preact-compat.es.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOM", function() { return DOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return Children; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return render$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createClass", function() { return createClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return createFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return cloneElement$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return isValidElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return findDOMNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return unmountComponentAtNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return PureComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_renderSubtreeIntoContainer", function() { return renderSubtreeIntoContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return unstable_batchedUpdates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return extend; });\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/preact-compat/node_modules/prop-types/index.js");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "PropTypes", function() { return prop_types__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.mjs");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createRef"]; });\n\n/* harmony import */ var preact_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact-context */ "./node_modules/preact-compat/node_modules/preact-context/dist/context.min.js");\n/* harmony import */ var preact_context__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(preact_context__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return preact_context__WEBPACK_IMPORTED_MODULE_2__["createContext"]; });\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\n\n\n\nvar version = \'15.1.0\'; // trick libraries to think we are react\n\nvar ELEMENTS = \'a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn dialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param picture pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr circle clipPath defs ellipse g image line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan\'.split(\' \');\nvar REACT_ELEMENT_TYPE = typeof Symbol !== \'undefined\' && Symbol.for && Symbol.for(\'react.element\') || 0xeac7;\nvar COMPONENT_WRAPPER_KEY = typeof Symbol !== \'undefined\' && Symbol.for ? Symbol.for(\'__preactCompatWrapper\') : \'__preactCompatWrapper\'; // don\'t autobind these methods since they already have guaranteed context.\n\nvar AUTOBIND_BLACKLIST = {\n  constructor: 1,\n  render: 1,\n  shouldComponentUpdate: 1,\n  componentWillReceiveProps: 1,\n  componentWillUpdate: 1,\n  componentDidUpdate: 1,\n  componentWillMount: 1,\n  componentDidMount: 1,\n  componentWillUnmount: 1,\n  componentDidUnmount: 1\n};\nvar CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip|color|fill|flood|font|glyph|horiz|marker|overline|paint|stop|strikethrough|stroke|text|underline|unicode|units|v|vector|vert|word|writing|x)[A-Z]/;\nvar BYPASS_HOOK = {};\n/*global process*/\n\nvar DEV = false;\n\ntry {\n  DEV = "production" !== \'production\';\n} catch (e) {} // a component that renders nothing. Used to replace components for unmountComponentAtNode.\n\n\nfunction EmptyComponent() {\n  return null;\n} // make react think we\'re react.\n\n\nvar VNode = Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(\'a\', null).constructor;\nVNode.prototype.$$typeof = REACT_ELEMENT_TYPE;\nVNode.prototype.preactCompatUpgraded = false;\nVNode.prototype.preactCompatNormalized = false;\nObject.defineProperty(VNode.prototype, \'type\', {\n  get: function get() {\n    return this.nodeName;\n  },\n  set: function set(v) {\n    this.nodeName = v;\n  },\n  configurable: true\n});\nObject.defineProperty(VNode.prototype, \'props\', {\n  get: function get() {\n    return this.attributes;\n  },\n  set: function set(v) {\n    this.attributes = v;\n  },\n  configurable: true\n});\nvar oldEventHook = preact__WEBPACK_IMPORTED_MODULE_1__["options"].event;\n\npreact__WEBPACK_IMPORTED_MODULE_1__["options"].event = function (e) {\n  if (oldEventHook) {\n    e = oldEventHook(e);\n  }\n\n  e.persist = Object;\n  e.nativeEvent = e;\n  return e;\n};\n\nvar oldVnodeHook = preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode;\n\npreact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode = function (vnode) {\n  if (!vnode.preactCompatUpgraded) {\n    vnode.preactCompatUpgraded = true;\n    var tag = vnode.nodeName,\n        attrs = vnode.attributes = vnode.attributes == null ? {} : extend({}, vnode.attributes);\n\n    if (typeof tag === \'function\') {\n      if (tag[COMPONENT_WRAPPER_KEY] === true || tag.prototype && \'isReactComponent\' in tag.prototype) {\n        if (vnode.children && String(vnode.children) === \'\') {\n          vnode.children = undefined;\n        }\n\n        if (vnode.children) {\n          attrs.children = vnode.children;\n        }\n\n        if (!vnode.preactCompatNormalized) {\n          normalizeVNode(vnode);\n        }\n\n        handleComponentVNode(vnode);\n      }\n    } else {\n      if (vnode.children && String(vnode.children) === \'\') {\n        vnode.children = undefined;\n      }\n\n      if (vnode.children) {\n        attrs.children = vnode.children;\n      }\n\n      if (attrs.defaultValue) {\n        if (!attrs.value && attrs.value !== 0) {\n          attrs.value = attrs.defaultValue;\n        }\n\n        delete attrs.defaultValue;\n      }\n\n      handleElementVNode(vnode, attrs);\n    }\n  }\n\n  if (oldVnodeHook) {\n    oldVnodeHook(vnode);\n  }\n};\n\nfunction handleComponentVNode(vnode) {\n  var tag = vnode.nodeName,\n      a = vnode.attributes;\n  vnode.attributes = {};\n\n  if (tag.defaultProps) {\n    extend(vnode.attributes, tag.defaultProps);\n  }\n\n  if (a) {\n    extend(vnode.attributes, a);\n  }\n}\n\nfunction handleElementVNode(vnode, a) {\n  var shouldSanitize, attrs, i;\n\n  if (a) {\n    for (i in a) {\n      if (shouldSanitize = CAMEL_PROPS.test(i)) {\n        break;\n      }\n    }\n\n    if (shouldSanitize) {\n      attrs = vnode.attributes = {};\n\n      for (i in a) {\n        if (a.hasOwnProperty(i)) {\n          attrs[CAMEL_PROPS.test(i) ? i.replace(/([A-Z0-9])/, \'-$1\').toLowerCase() : i] = a[i];\n        }\n      }\n    }\n  }\n} // proxy render() since React returns a Component reference.\n\n\nfunction render$1(vnode, parent, callback) {\n  var prev = parent && parent._preactCompatRendered && parent._preactCompatRendered.base; // ignore impossible previous renders\n\n  if (prev && prev.parentNode !== parent) {\n    prev = null;\n  } // default to first Element child\n\n\n  if (!prev && parent) {\n    prev = parent.firstElementChild;\n  } // remove unaffected siblings\n\n\n  for (var i = parent.childNodes.length; i--;) {\n    if (parent.childNodes[i] !== prev) {\n      parent.removeChild(parent.childNodes[i]);\n    }\n  }\n\n  var out = Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(vnode, parent, prev);\n\n  if (parent) {\n    parent._preactCompatRendered = out && (out._component || {\n      base: out\n    });\n  }\n\n  if (typeof callback === \'function\') {\n    callback();\n  }\n\n  return out && out._component || out;\n}\n\nvar ContextProvider = function ContextProvider() {};\n\nContextProvider.prototype.getChildContext = function () {\n  return this.props.context;\n};\n\nContextProvider.prototype.render = function (props) {\n  return props.children[0];\n};\n\nfunction renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {\n  var wrap = Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(ContextProvider, {\n    context: parentComponent.context\n  }, vnode);\n  var renderContainer = render$1(wrap, container);\n  var component = renderContainer._component || renderContainer.base;\n\n  if (callback) {\n    callback.call(component, renderContainer);\n  }\n\n  return component;\n}\n\nfunction Portal(props) {\n  renderSubtreeIntoContainer(this, props.vnode, props.container);\n}\n\nfunction createPortal(vnode, container) {\n  return Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(Portal, {\n    vnode: vnode,\n    container: container\n  });\n}\n\nfunction unmountComponentAtNode(container) {\n  var existing = container._preactCompatRendered && container._preactCompatRendered.base;\n\n  if (existing && existing.parentNode === container) {\n    Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(EmptyComponent), container, existing);\n    return true;\n  }\n\n  return false;\n}\n\nvar ARR = []; // This API is completely unnecessary for Preact, so it\'s basically passthrough.\n\nvar Children = {\n  map: function map(children, fn, ctx) {\n    if (children == null) {\n      return null;\n    }\n\n    children = Children.toArray(children);\n\n    if (ctx && ctx !== children) {\n      fn = fn.bind(ctx);\n    }\n\n    return children.map(fn);\n  },\n  forEach: function forEach(children, fn, ctx) {\n    if (children == null) {\n      return null;\n    }\n\n    children = Children.toArray(children);\n\n    if (ctx && ctx !== children) {\n      fn = fn.bind(ctx);\n    }\n\n    children.forEach(fn);\n  },\n  count: function count(children) {\n    return children && children.length || 0;\n  },\n  only: function only(children) {\n    children = Children.toArray(children);\n\n    if (children.length !== 1) {\n      throw new Error(\'Children.only() expects only one child.\');\n    }\n\n    return children[0];\n  },\n  toArray: function toArray(children) {\n    if (children == null) {\n      return [];\n    }\n\n    return ARR.concat(children);\n  }\n};\n/** Track current render() component for ref assignment */\n\nvar currentComponent;\n\nfunction createFactory(type) {\n  return createElement.bind(null, type);\n}\n\nvar DOM = {};\n\nfor (var i = ELEMENTS.length; i--;) {\n  DOM[ELEMENTS[i]] = createFactory(ELEMENTS[i]);\n}\n\nfunction upgradeToVNodes(arr, offset) {\n  for (var i = offset || 0; i < arr.length; i++) {\n    var obj = arr[i];\n\n    if (Array.isArray(obj)) {\n      upgradeToVNodes(obj);\n    } else if (obj && _typeof(obj) === \'object\' && !isValidElement(obj) && (obj.props && obj.type || obj.attributes && obj.nodeName || obj.children)) {\n      arr[i] = createElement(obj.type || obj.nodeName, obj.props || obj.attributes, obj.children);\n    }\n  }\n}\n\nfunction isStatelessComponent(c) {\n  return typeof c === \'function\' && !(c.prototype && c.prototype.render);\n} // wraps stateless functional components in a PropTypes validator\n\n\nfunction wrapStatelessComponent(WrappedComponent) {\n  return createClass({\n    displayName: WrappedComponent.displayName || WrappedComponent.name,\n    render: function render() {\n      return WrappedComponent(this.props, this.context);\n    }\n  });\n}\n\nfunction statelessComponentHook(Ctor) {\n  var Wrapped = Ctor[COMPONENT_WRAPPER_KEY];\n\n  if (Wrapped) {\n    return Wrapped === true ? Ctor : Wrapped;\n  }\n\n  Wrapped = wrapStatelessComponent(Ctor);\n  Object.defineProperty(Wrapped, COMPONENT_WRAPPER_KEY, {\n    configurable: true,\n    value: true\n  });\n  Wrapped.displayName = Ctor.displayName;\n  Wrapped.propTypes = Ctor.propTypes;\n  Wrapped.defaultProps = Ctor.defaultProps;\n  Object.defineProperty(Ctor, COMPONENT_WRAPPER_KEY, {\n    configurable: true,\n    value: Wrapped\n  });\n  return Wrapped;\n}\n\nfunction createElement() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) {\n    args[len] = arguments[len];\n  }\n\n  upgradeToVNodes(args, 2);\n  return normalizeVNode(preact__WEBPACK_IMPORTED_MODULE_1__["h"].apply(void 0, args));\n}\n\nfunction normalizeVNode(vnode) {\n  vnode.preactCompatNormalized = true;\n  applyClassName(vnode);\n\n  if (isStatelessComponent(vnode.nodeName)) {\n    vnode.nodeName = statelessComponentHook(vnode.nodeName);\n  }\n\n  var ref = vnode.attributes.ref,\n      type = ref && _typeof(ref);\n\n  if (currentComponent && (type === \'string\' || type === \'number\')) {\n    vnode.attributes.ref = createStringRefProxy(ref, currentComponent);\n  }\n\n  applyEventNormalization(vnode);\n  return vnode;\n}\n\nfunction cloneElement$1(element, props) {\n  var children = [],\n      len = arguments.length - 2;\n\n  while (len-- > 0) {\n    children[len] = arguments[len + 2];\n  }\n\n  if (!isValidElement(element)) {\n    return element;\n  }\n\n  var elementProps = element.attributes || element.props;\n  var node = Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(element.nodeName || element.type, extend({}, elementProps), element.children || elementProps && elementProps.children); // Only provide the 3rd argument if needed.\n  // Arguments 3+ overwrite element.children in preactCloneElement\n\n  var cloneArgs = [node, props];\n\n  if (children && children.length) {\n    cloneArgs.push(children);\n  } else if (props && props.children) {\n    cloneArgs.push(props.children);\n  }\n\n  return normalizeVNode(preact__WEBPACK_IMPORTED_MODULE_1__["cloneElement"].apply(void 0, cloneArgs));\n}\n\nfunction isValidElement(element) {\n  return element && (element instanceof VNode || element.$$typeof === REACT_ELEMENT_TYPE);\n}\n\nfunction createStringRefProxy(name, component) {\n  return component._refProxies[name] || (component._refProxies[name] = function (resolved) {\n    if (component && component.refs) {\n      component.refs[name] = resolved;\n\n      if (resolved === null) {\n        delete component._refProxies[name];\n        component = null;\n      }\n    }\n  });\n}\n\nfunction applyEventNormalization(ref) {\n  var nodeName = ref.nodeName;\n  var attributes = ref.attributes;\n\n  if (!attributes || typeof nodeName !== \'string\') {\n    return;\n  }\n\n  var props = {};\n\n  for (var i in attributes) {\n    props[i.toLowerCase()] = i;\n  }\n\n  if (props.ondoubleclick) {\n    attributes.ondblclick = attributes[props.ondoubleclick];\n    delete attributes[props.ondoubleclick];\n  } // for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:\n\n\n  if (props.onchange && (nodeName === \'textarea\' || nodeName.toLowerCase() === \'input\' && !/^fil|che|rad/i.test(attributes.type))) {\n    var normalized = props.oninput || \'oninput\';\n\n    if (!attributes[normalized]) {\n      attributes[normalized] = multihook([attributes[normalized], attributes[props.onchange]]);\n      delete attributes[props.onchange];\n    }\n  }\n}\n\nfunction applyClassName(vnode) {\n  var a = vnode.attributes || (vnode.attributes = {});\n  classNameDescriptor.enumerable = \'className\' in a;\n\n  if (a.className) {\n    a.class = a.className;\n  }\n\n  Object.defineProperty(a, \'className\', classNameDescriptor);\n}\n\nvar classNameDescriptor = {\n  configurable: true,\n  get: function get() {\n    return this.class;\n  },\n  set: function set(v) {\n    this.class = v;\n  }\n};\n\nfunction extend(base, props) {\n  var arguments$1 = arguments;\n\n  for (var i = 1, obj = void 0; i < arguments.length; i++) {\n    if (obj = arguments$1[i]) {\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          base[key] = obj[key];\n        }\n      }\n    }\n  }\n\n  return base;\n}\n\nfunction shallowDiffers(a, b) {\n  for (var i in a) {\n    if (!(i in b)) {\n      return true;\n    }\n  }\n\n  for (var i$1 in b) {\n    if (a[i$1] !== b[i$1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction findDOMNode(component) {\n  return component && (component.base || component.nodeType === 1 && component) || null;\n}\n\nfunction F() {}\n\nfunction createClass(obj) {\n  function cl(props, context) {\n    bindAll(this);\n    Component$1.call(this, props, context, BYPASS_HOOK);\n    newComponentHook.call(this, props, context);\n  }\n\n  obj = extend({\n    constructor: cl\n  }, obj); // We need to apply mixins here so that getDefaultProps is correctly mixed\n\n  if (obj.mixins) {\n    applyMixins(obj, collateMixins(obj.mixins));\n  }\n\n  if (obj.statics) {\n    extend(cl, obj.statics);\n  }\n\n  if (obj.propTypes) {\n    cl.propTypes = obj.propTypes;\n  }\n\n  if (obj.defaultProps) {\n    cl.defaultProps = obj.defaultProps;\n  }\n\n  if (obj.getDefaultProps) {\n    cl.defaultProps = obj.getDefaultProps.call(cl);\n  }\n\n  F.prototype = Component$1.prototype;\n  cl.prototype = extend(new F(), obj);\n  cl.displayName = obj.displayName || \'Component\';\n  return cl;\n} // Flatten an Array of mixins to a map of method name to mixin implementations\n\n\nfunction collateMixins(mixins) {\n  var keyed = {};\n\n  for (var i = 0; i < mixins.length; i++) {\n    var mixin = mixins[i];\n\n    for (var key in mixin) {\n      if (mixin.hasOwnProperty(key) && typeof mixin[key] === \'function\') {\n        (keyed[key] || (keyed[key] = [])).push(mixin[key]);\n      }\n    }\n  }\n\n  return keyed;\n} // apply a mapping of Arrays of mixin methods to a component prototype\n\n\nfunction applyMixins(proto, mixins) {\n  for (var key in mixins) {\n    if (mixins.hasOwnProperty(key)) {\n      proto[key] = multihook(mixins[key].concat(proto[key] || ARR), key === \'getDefaultProps\' || key === \'getInitialState\' || key === \'getChildContext\');\n    }\n  }\n}\n\nfunction bindAll(ctx) {\n  for (var i in ctx) {\n    var v = ctx[i];\n\n    if (typeof v === \'function\' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {\n      (ctx[i] = v.bind(ctx)).__bound = true;\n    }\n  }\n}\n\nfunction callMethod(ctx, m, args) {\n  if (typeof m === \'string\') {\n    m = ctx.constructor.prototype[m];\n  }\n\n  if (typeof m === \'function\') {\n    return m.apply(ctx, args);\n  }\n}\n\nfunction multihook(hooks, skipDuplicates) {\n  return function () {\n    var arguments$1 = arguments;\n    var this$1 = this;\n    var ret;\n\n    for (var i = 0; i < hooks.length; i++) {\n      var r = callMethod(this$1, hooks[i], arguments$1);\n\n      if (skipDuplicates && r != null) {\n        if (!ret) {\n          ret = {};\n        }\n\n        for (var key in r) {\n          if (r.hasOwnProperty(key)) {\n            ret[key] = r[key];\n          }\n        }\n      } else if (typeof r !== \'undefined\') {\n        ret = r;\n      }\n    }\n\n    return ret;\n  };\n}\n\nfunction newComponentHook(props, context) {\n  propsHook.call(this, props, context);\n  this.componentWillReceiveProps = multihook([propsHook, this.componentWillReceiveProps || \'componentWillReceiveProps\']);\n  this.render = multihook([propsHook, beforeRender, this.render || \'render\', afterRender]);\n}\n\nfunction propsHook(props, context) {\n  if (!props) {\n    return;\n  } // React annoyingly special-cases single children, and some react components are ridiculously strict about this.\n\n\n  var c = props.children;\n\n  if (c && Array.isArray(c) && c.length === 1 && (typeof c[0] === \'string\' || typeof c[0] === \'function\' || c[0] instanceof VNode)) {\n    props.children = c[0]; // but its totally still going to be an Array.\n\n    if (props.children && _typeof(props.children) === \'object\') {\n      props.children.length = 1;\n      props.children[0] = props.children;\n    }\n  } // add proptype checking\n\n\n  if (DEV) {\n    var ctor = typeof this === \'function\' ? this : this.constructor,\n        propTypes = this.propTypes || ctor.propTypes;\n    var displayName = this.displayName || ctor.name;\n\n    if (propTypes) {\n      prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.checkPropTypes(propTypes, props, \'prop\', displayName);\n    }\n  }\n}\n\nfunction beforeRender(props) {\n  currentComponent = this;\n}\n\nfunction afterRender() {\n  if (currentComponent === this) {\n    currentComponent = null;\n  }\n}\n\nfunction Component$1(props, context, opts) {\n  preact__WEBPACK_IMPORTED_MODULE_1__["Component"].call(this, props, context);\n  this.state = this.getInitialState ? this.getInitialState() : {};\n  this.refs = {};\n  this._refProxies = {};\n\n  if (opts !== BYPASS_HOOK) {\n    newComponentHook.call(this, props, context);\n  }\n}\n\nextend(Component$1.prototype = new preact__WEBPACK_IMPORTED_MODULE_1__["Component"](), {\n  constructor: Component$1,\n  isReactComponent: {},\n  replaceState: function replaceState(state, callback) {\n    var this$1 = this;\n    this.setState(state, callback);\n\n    for (var i in this$1.state) {\n      if (!(i in state)) {\n        delete this$1.state[i];\n      }\n    }\n  },\n  getDOMNode: function getDOMNode() {\n    return this.base;\n  },\n  isMounted: function isMounted() {\n    return !!this.base;\n  }\n});\n\nfunction PureComponent(props, context) {\n  Component$1.call(this, props, context);\n}\n\nF.prototype = Component$1.prototype;\nPureComponent.prototype = new F();\nPureComponent.prototype.isPureReactComponent = true;\n\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n  return shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n\nfunction unstable_batchedUpdates(callback) {\n  callback();\n}\n\nvar index = {\n  version: version,\n  DOM: DOM,\n  PropTypes: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a,\n  Children: Children,\n  render: render$1,\n  hydrate: render$1,\n  createClass: createClass,\n  createContext: preact_context__WEBPACK_IMPORTED_MODULE_2__["createContext"],\n  createPortal: createPortal,\n  createFactory: createFactory,\n  createElement: createElement,\n  cloneElement: cloneElement$1,\n  createRef: preact__WEBPACK_IMPORTED_MODULE_1__["createRef"],\n  isValidElement: isValidElement,\n  findDOMNode: findDOMNode,\n  unmountComponentAtNode: unmountComponentAtNode,\n  Component: Component$1,\n  PureComponent: PureComponent,\n  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer,\n  unstable_batchedUpdates: unstable_batchedUpdates,\n  __spread: extend\n};\n/* harmony default export */ __webpack_exports__["default"] = (index);\n\n\n//# sourceURL=webpack:///./node_modules/preact-compat/dist/preact-compat.es.js?')},"./node_modules/preact-compat/node_modules/preact-context/dist/context.min.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n!function (n, t) {\n  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? t(exports, __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.mjs")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.mjs")], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(this, function (n, t) {\n  "use strict";\n\n  var i = {\n    register: function register(n) {\n      console.warn("Consumer used without a Provider");\n    },\n    unregister: function unregister(n) {},\n    val: function val(n) {}\n  };\n\n  function r(n) {\n    var t = n.children;\n    return {\n      child: 1 === t.length ? t[0] : null,\n      children: t\n    };\n  }\n\n  var _e,\n      u = window && window.__extends || (_e = function e(n, t) {\n    return (_e = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (n, t) {\n      n.__proto__ = t;\n    } || function (n, t) {\n      for (var i in t) {\n        t.hasOwnProperty(i) && (n[i] = t[i]);\n      }\n    })(n, t);\n  }, function (n, t) {\n    function i() {\n      this.constructor = n;\n    }\n\n    _e(n, t), n.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i());\n  });\n\n  function o(n) {\n    return r(n).child || "render" in n && n.render;\n  }\n\n  var c = 1073741823,\n      f = function f() {\n    return c;\n  },\n      s = 0;\n\n  function a(n, e) {\n    var a = "_preactContextProvider-" + s++;\n    return {\n      Provider: function (n) {\n        function i(t) {\n          var i = n.call(this, t) || this;\n          return i.t = function (n, t) {\n            var i = [],\n                r = n,\n                e = function e(n) {\n              return 0 | t(r, n);\n            };\n\n            return {\n              register: function register(n) {\n                i.push(n), n(r, e(r));\n              },\n              unregister: function unregister(n) {\n                i = i.filter(function (t) {\n                  return t !== n;\n                });\n              },\n              val: function val(n) {\n                if (void 0 === n || n == r) return r;\n                var t = e(n);\n                return r = n, i.forEach(function (i) {\n                  return i(n, t);\n                }), r;\n              }\n            };\n          }(t.value, e || f), i;\n        }\n\n        return u(i, n), i.prototype.getChildContext = function () {\n          var n;\n          return (n = {})[a] = this.t, n;\n        }, i.prototype.componentDidUpdate = function () {\n          this.t.val(this.props.value);\n        }, i.prototype.render = function () {\n          var n = r(this.props),\n              i = n.child,\n              e = n.children;\n          return i || t.h("span", null, e);\n        }, i;\n      }(t.Component),\n      Consumer: function (t) {\n        function r(i, r) {\n          var e = t.call(this, i, r) || this;\n          return e.i = function (n, t) {\n            var i = e.props.unstable_observedBits,\n                r = void 0 === i || null === i ? c : i;\n            0 != ((r |= 0) & t) && e.setState({\n              value: n\n            });\n          }, e.state = {\n            value: e.u().val() || n\n          }, e;\n        }\n\n        return u(r, t), r.prototype.componentDidMount = function () {\n          this.u().register(this.i);\n        }, r.prototype.shouldComponentUpdate = function (n, t) {\n          return this.state.value !== t.value || o(this.props) !== o(n);\n        }, r.prototype.componentWillUnmount = function () {\n          this.u().unregister(this.i);\n        }, r.prototype.componentDidUpdate = function (n, t, r) {\n          var e = r[a];\n          e !== this.context[a] && ((e || i).unregister(this.i), this.componentDidMount());\n        }, r.prototype.render = function () {\n          var n = "render" in this.props && this.props.render,\n              t = o(this.props);\n          if (n && n !== t && console.warn("Both children and a render function are defined. Children will be used"), "function" == typeof t) return t(this.state.value);\n          console.warn("Consumer is expecting a function as one and only child but didn\'t find any");\n        }, r.prototype.u = function () {\n          return this.context[a] || i;\n        }, r;\n      }(t.Component)\n    };\n  }\n\n  var d = a;\n  n.default = a, n.createContext = d, Object.defineProperty(n, "__esModule", {\n    value: !0\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/preact-compat/node_modules/preact-context/dist/context.min.js?')},"./node_modules/preact-compat/node_modules/prop-types/factoryWithThrowingShims.js":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/preact-compat/node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n\nfunction emptyFunction() {}\n\nfunction emptyFunctionWithReset() {}\n\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function () {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n\n    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n    err.name = 'Invariant Violation';\n    throw err;\n  }\n\n  ;\n  shim.isRequired = shim;\n\n  function getShim() {\n    return shim;\n  }\n\n  ; // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n  ReactPropTypes.PropTypes = ReactPropTypes;\n  return ReactPropTypes;\n};\n\n//# sourceURL=webpack:///./node_modules/preact-compat/node_modules/prop-types/factoryWithThrowingShims.js?")},"./node_modules/preact-compat/node_modules/prop-types/index.js":function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(/*! ./factoryWithThrowingShims */ "./node_modules/preact-compat/node_modules/prop-types/factoryWithThrowingShims.js")();\n}\n\n//# sourceURL=webpack:///./node_modules/preact-compat/node_modules/prop-types/index.js?')},"./node_modules/preact-compat/node_modules/prop-types/lib/ReactPropTypesSecret.js":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nmodule.exports = ReactPropTypesSecret;\n\n//# sourceURL=webpack:///./node_modules/preact-compat/node_modules/prop-types/lib/ReactPropTypesSecret.js?")},"./node_modules/preact-render-to-string/dist/index.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return c; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderToString", function() { return c; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowRender", function() { return s; });\nvar e=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,t=function(e){return String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},r={};function n(t){var n="";for(var o in t){var a=t[o];null!=a&&(n&&(n+=" "),n+=r[o]||(r[o]=o.replace(/([A-Z])/g,"-$1").toLowerCase()),n+=": ",n+=a,"number"==typeof a&&!1===e.test(o)&&(n+="px"),n+=";")}return n||void 0}function o(e,t){for(var r in t)e[r]=t[r];return e}var a={shallow:!0},i=[],l=/^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;c.render=c;var s=function(e,t){return c(e,t,a)};function c(e,r,a,s,f){if(null==e||"boolean"==typeof e)return"";var u,p=e.nodeName,v=e.attributes,d=!1;if(r=r||{},a=a||{},"object"!=typeof e&&!p)return t(e);if("function"==typeof p){if(d=!0,!a.shallow||!s&&!1!==a.renderRootComponent){var h,m=function(e){var t=o({},e.attributes);t.children=e.children;var r=e.nodeName.defaultProps;if(void 0!==r)for(var n in r)void 0===t[n]&&(t[n]=r[n]);return t}(e);if(p.prototype&&"function"==typeof p.prototype.render){var g=new p(m,r);g._disable=g.__x=!0,g.props=m,g.context=r,p.getDerivedStateFromProps?g.state=o(o({},g.state),p.getDerivedStateFromProps(g.props,g.state)):g.componentWillMount&&g.componentWillMount(),h=g.render(g.props,g.state,g.context),g.getChildContext&&(r=o(o({},r),g.getChildContext()))}else h=p(m,r);return c(h,r,a,!1!==a.shallowHighOrder)}p=(u=p).displayName||u!==Function&&u.name||function(e){var t=(Function.prototype.toString.call(e).match(/^\\s*function\\s+([^( ]+)/)||"")[1];if(!t){for(var r=-1,n=i.length;n--;)if(i[n]===e){r=n;break}r<0&&(r=i.push(e)-1),t="UnnamedComponent"+r}return t}(u)}var b,y="";if(v){var x=Object.keys(v);a&&!0===a.sortAttributes&&x.sort();for(var w=0;w<x.length;w++){var k=x[w],C=v[k];if("children"!==k&&(!k.match(/[\\s\\n\\\\/=\'"\\0<>]/)&&(a&&a.allAttributes||"key"!==k&&"ref"!==k))){if("className"===k){if(v.class)continue;k="class"}else f&&k.match(/^xlink:?./)&&(k=k.toLowerCase().replace(/^xlink:?/,"xlink:"));"style"===k&&C&&"object"==typeof C&&(C=n(C));var S=a.attributeHook&&a.attributeHook(k,C,r,a,d);if(S||""===S)y+=S;else if("dangerouslySetInnerHTML"===k)b=C&&C.__html;else if((C||0===C||""===C)&&"function"!=typeof C){if(!(!0!==C&&""!==C||(C=k,a&&a.xml))){y+=" "+k;continue}y+=" "+k+\'="\'+t(C)+\'"\'}}}}if(y="<"+p+y+">",String(p).match(/[\\s\\n\\\\/=\'"\\0<>]/))throw y;var j=String(p).match(l);j&&(y=y.replace(/>$/," />"));var _=[];if(b)y+=b;else if(e.children)for(var F=0;F<e.children.length;F++){var H=e.children[F];if(null!=H&&!1!==H){var N=c(H,r,a,!0,"svg"===p||"foreignObject"!==p&&f);N&&_.push(N)}}if(_.length)y+=_.join("");else if(a&&a.xml)return y.substring(0,y.length-1)+" />";return j||(y+="</"+p+">"),y}c.shallowRender=s;/* harmony default export */ __webpack_exports__["default"] = (c);\n//# sourceMappingURL=index.mjs.map\n\n\n//# sourceURL=webpack:///./node_modules/preact-render-to-string/dist/index.mjs?')},"./node_modules/preact/dist/preact.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneElement\", function() { return cloneElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return rerender; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\nvar VNode = function VNode() {};\n\nvar options = {};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\nfunction applyRef(ref, value) {\n  if (ref != null) {\n    if (typeof ref == 'function') ref(value);else ref.current = value;\n  }\n}\n\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nfunction cloneElement(vnode, props) {\n  return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p;\n\twhile (p = items.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\nfunction getNodeProps(vnode) {\n\tvar props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {} else if (name === 'ref') {\n\t\tapplyRef(old, null);\n\t\tapplyRef(value, node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\ttry {\n\t\t\tnode[name] = value == null ? '' : value;\n\t\t} catch (e) {}\n\t\tif ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));\n\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\nvar mounts = [];\n\nvar diffLevel = 0;\n\nvar isSvgMode = false;\n\nvar hydrating = false;\n\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.shift()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\tif (!diffLevel++) {\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t}\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t} else if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\tdiffAttributes(out, vnode.attributes, props);\n\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t} else if (min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\tunmountComponent(component);\n\t} else {\n\t\tif (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\nvar recyclerComponents = [];\n\nfunction createComponent(Ctor, props, context) {\n\tvar inst,\n\t    i = recyclerComponents.length;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\twhile (i--) {\n\t\tif (recyclerComponents[i].constructor === Ctor) {\n\t\t\tinst.nextBase = recyclerComponents[i].nextBase;\n\t\t\trecyclerComponents.splice(i, 1);\n\t\t\treturn inst;\n\t\t}\n\t}\n\n\treturn inst;\n}\n\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\nfunction setComponentProps(component, props, renderMode, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tcomponent.__ref = props.ref;\n\tcomponent.__key = props.key;\n\tdelete props.ref;\n\tdelete props.key;\n\n\tif (typeof component.constructor.getDerivedStateFromProps === 'undefined') {\n\t\tif (!component.base || mountAll) {\n\t\t\tif (component.componentWillMount) component.componentWillMount();\n\t\t} else if (component.componentWillReceiveProps) {\n\t\t\tcomponent.componentWillReceiveProps(props, context);\n\t\t}\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (renderMode !== 0) {\n\t\tif (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tapplyRef(component.__ref, component);\n}\n\nfunction renderComponent(component, renderMode, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    snapshot = previousContext,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\tif (component.constructor.getDerivedStateFromProps) {\n\t\tstate = extend(extend({}, state), component.constructor.getDerivedStateFromProps(props, state));\n\t\tcomponent.state = state;\n\t}\n\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tif (isUpdate && component.getSnapshotBeforeUpdate) {\n\t\t\tsnapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || renderMode === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.push(component);\n\t} else if (!skip) {\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, snapshot);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\twhile (component._renderCallbacks.length) {\n\t\tcomponent._renderCallbacks.pop().call(component);\n\t}if (!diffLevel && !isChild) flushMounts();\n}\n\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\trecyclerComponents.push(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tapplyRef(component.__ref, null);\n}\n\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\tthis.context = context;\n\n\tthis.props = props;\n\n\tthis.state = this.state || {};\n\n\tthis._renderCallbacks = [];\n}\n\nextend(Component.prototype, {\n\tsetState: function setState(state, callback) {\n\t\tif (!this.prevState) this.prevState = this.state;\n\t\tthis.state = extend(extend({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t},\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\trender: function render() {}\n});\n\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nfunction createRef() {\n\treturn {};\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tcreateRef: createRef,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (preact);\n\n//# sourceMappingURL=preact.mjs.map\n\n\n//# sourceURL=webpack:///./node_modules/preact/dist/preact.mjs?")},"./node_modules/pwa-helpers/lazy-reducer-enhancer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lazyReducerEnhancer", function() { return lazyReducerEnhancer; });\n/**\n@license\nCopyright (c) 2018 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nvar lazyReducerEnhancer = function lazyReducerEnhancer(combineReducers) {\n  var enhancer = function enhancer(nextCreator) {\n    return function (origReducer, preloadedState) {\n      var lazyReducers = {};\n      var nextStore = nextCreator(origReducer, preloadedState);\n      return Object.assign({}, nextStore, {\n        addReducers: function addReducers(newReducers) {\n          var combinedReducerMap = Object.assign({}, lazyReducers, newReducers);\n          this.replaceReducer(combineReducers(lazyReducers = combinedReducerMap));\n        }\n      });\n    };\n  };\n\n  return enhancer;\n};\n\n//# sourceURL=webpack:///./node_modules/pwa-helpers/lazy-reducer-enhancer.js?')},"./node_modules/react-animate-height/lib/AnimateHeight.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/preact-compat/dist/preact-compat.es.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/react-animate-height/node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = __webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof2(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof2(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ANIMATION_STATE_CLASSES = {\n  animating: 'rah-animating',\n  animatingUp: 'rah-animating--up',\n  animatingDown: 'rah-animating--down',\n  animatingToHeightZero: 'rah-animating--to-height-zero',\n  animatingToHeightAuto: 'rah-animating--to-height-auto',\n  animatingToHeightSpecific: 'rah-animating--to-height-specific',\n  static: 'rah-static',\n  staticHeightZero: 'rah-static--height-zero',\n  staticHeightAuto: 'rah-static--height-auto',\n  staticHeightSpecific: 'rah-static--height-specific'\n};\nvar PROPS_TO_OMIT = ['animateOpacity', 'animationStateClasses', 'applyInlineTransitions', 'children', 'contentClassName', 'delay', 'duration', 'easing', 'height', 'onAnimationEnd', 'onAnimationStart'];\n\nfunction omit(obj) {\n  for (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n\n  if (!keys.length) {\n    return obj;\n  }\n\n  var res = {};\n  var objectKeys = Object.keys(obj);\n\n  for (var i = 0; i < objectKeys.length; i++) {\n    var key = objectKeys[i];\n\n    if (keys.indexOf(key) === -1) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n} // Start animation helper using nested requestAnimationFrames\n\n\nfunction startAnimationHelper(callback) {\n  requestAnimationFrame(function () {\n    requestAnimationFrame(function () {\n      callback();\n    });\n  });\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction isPercentage(height) {\n  // Percentage height\n  return typeof height === 'string' && height.search('%') === height.length - 1 && isNumber(height.substr(0, height.length - 1));\n}\n\nfunction runCallback(callback, params) {\n  if (callback && typeof callback === 'function') {\n    callback(params);\n  }\n}\n\nvar AnimateHeight = function (_React$Component) {\n  _inherits(AnimateHeight, _React$Component);\n\n  function AnimateHeight(props) {\n    _classCallCheck(this, AnimateHeight);\n\n    var _this = _possibleConstructorReturn(this, (AnimateHeight.__proto__ || Object.getPrototypeOf(AnimateHeight)).call(this, props));\n\n    var height = 'auto';\n    var overflow = 'visible';\n\n    if (isNumber(props.height)) {\n      // If value is string \"0\" make sure we convert it to number 0\n      height = props.height < 0 || props.height === '0' ? 0 : props.height;\n      overflow = 'hidden';\n    } else if (isPercentage(props.height)) {\n      // If value is string \"0%\" make sure we convert it to number 0\n      height = props.height === '0%' ? 0 : props.height;\n      overflow = 'hidden';\n    }\n\n    _this.animationStateClasses = _extends({}, ANIMATION_STATE_CLASSES, props.animationStateClasses);\n\n    var animationStateClasses = _this.getStaticStateClasses(height);\n\n    _this.state = {\n      animationStateClasses: animationStateClasses,\n      height: height,\n      overflow: overflow,\n      shouldUseTransitions: false\n    };\n    return _this;\n  }\n\n  _createClass(AnimateHeight, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var height = this.state.height; // Hide content if height is 0 (to prevent tabbing into it)\n      // Check for contentElement is added cause this would fail in tests (react-test-renderer)\n      // Read more here: https://github.com/Stanko/react-animate-height/issues/17\n\n      if (this.contentElement && this.contentElement.style) {\n        this.hideContent(height);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props = this.props,\n          delay = _props.delay,\n          duration = _props.duration,\n          height = _props.height,\n          onAnimationEnd = _props.onAnimationEnd,\n          onAnimationStart = _props.onAnimationStart; // Check if 'height' prop has changed\n\n      if (this.contentElement && height !== prevProps.height) {\n        var _cx; // Remove display: none from the content div\n        // if it was hidden to prevent tabbing into it\n\n\n        this.showContent(prevState.height); // Cache content height\n\n        this.contentElement.style.overflow = 'hidden';\n        var contentHeight = this.contentElement.offsetHeight;\n        this.contentElement.style.overflow = ''; // set total animation time\n\n        var totalDuration = duration + delay;\n        var newHeight = null;\n        var timeoutState = {\n          height: null,\n          // it will be always set to either 'auto' or specific number\n          overflow: 'hidden'\n        };\n        var isCurrentHeightAuto = prevState.height === 'auto';\n\n        if (isNumber(height)) {\n          // If value is string \"0\" make sure we convert it to number 0\n          newHeight = height < 0 || height === '0' ? 0 : height;\n          timeoutState.height = newHeight;\n        } else if (isPercentage(height)) {\n          // If value is string \"0%\" make sure we convert it to number 0\n          newHeight = height === '0%' ? 0 : height;\n          timeoutState.height = newHeight;\n        } else {\n          // If not, animate to content height\n          // and then reset to auto\n          newHeight = contentHeight; // TODO solve contentHeight = 0\n\n          timeoutState.height = 'auto';\n          timeoutState.overflow = null;\n        }\n\n        if (isCurrentHeightAuto) {\n          // This is the height to be animated to\n          timeoutState.height = newHeight; // If previous height was 'auto'\n          // set starting height explicitly to be able to use transition\n\n          newHeight = contentHeight;\n        } // Animation classes\n\n\n        var animationStateClasses = (0, _classnames2.default)((_cx = {}, _defineProperty(_cx, this.animationStateClasses.animating, true), _defineProperty(_cx, this.animationStateClasses.animatingUp, prevProps.height === 'auto' || height < prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingDown, height === 'auto' || height > prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingToHeightZero, timeoutState.height === 0), _defineProperty(_cx, this.animationStateClasses.animatingToHeightAuto, timeoutState.height === 'auto'), _defineProperty(_cx, this.animationStateClasses.animatingToHeightSpecific, timeoutState.height > 0), _cx)); // Animation classes to be put after animation is complete\n\n        var timeoutAnimationStateClasses = this.getStaticStateClasses(timeoutState.height); // Set starting height and animating classes\n        // We are safe to call set state as it will not trigger infinite loop\n        // because of the \"height !== prevProps.height\" check\n\n        this.setState({\n          // eslint-disable-line react/no-did-update-set-state\n          animationStateClasses: animationStateClasses,\n          height: newHeight,\n          overflow: 'hidden',\n          // When animating from 'auto' we first need to set fixed height\n          // that change should be animated\n          shouldUseTransitions: !isCurrentHeightAuto\n        }); // Clear timeouts\n\n        clearTimeout(this.timeoutID);\n        clearTimeout(this.animationClassesTimeoutID);\n\n        if (isCurrentHeightAuto) {\n          // When animating from 'auto' we use a short timeout to start animation\n          // after setting fixed height above\n          timeoutState.shouldUseTransitions = true;\n          startAnimationHelper(function () {\n            _this2.setState(timeoutState); // ANIMATION STARTS, run a callback if it exists\n\n\n            runCallback(onAnimationStart, {\n              newHeight: timeoutState.height\n            });\n          }); // Set static classes and remove transitions when animation ends\n\n          this.animationClassesTimeoutID = setTimeout(function () {\n            _this2.setState({\n              animationStateClasses: timeoutAnimationStateClasses,\n              shouldUseTransitions: false\n            }); // ANIMATION ENDS\n            // Hide content if height is 0 (to prevent tabbing into it)\n\n\n            _this2.hideContent(timeoutState.height); // Run a callback if it exists\n\n\n            runCallback(onAnimationEnd, {\n              newHeight: timeoutState.height\n            });\n          }, totalDuration);\n        } else {\n          // ANIMATION STARTS, run a callback if it exists\n          runCallback(onAnimationStart, {\n            newHeight: newHeight\n          }); // Set end height, classes and remove transitions when animation is complete\n\n          this.timeoutID = setTimeout(function () {\n            timeoutState.animationStateClasses = timeoutAnimationStateClasses;\n            timeoutState.shouldUseTransitions = false;\n\n            _this2.setState(timeoutState); // ANIMATION ENDS\n            // If height is auto, don't hide the content\n            // (case when element is empty, therefore height is 0)\n\n\n            if (height !== 'auto') {\n              // Hide content if height is 0 (to prevent tabbing into it)\n              _this2.hideContent(newHeight); // TODO solve newHeight = 0\n\n            } // Run a callback if it exists\n\n\n            runCallback(onAnimationEnd, {\n              newHeight: newHeight\n            });\n          }, totalDuration);\n        }\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      clearTimeout(this.timeoutID);\n      clearTimeout(this.animationClassesTimeoutID);\n      this.timeoutID = null;\n      this.animationClassesTimeoutID = null;\n      this.animationStateClasses = null;\n    }\n  }, {\n    key: 'showContent',\n    value: function showContent(height) {\n      if (height === 0) {\n        this.contentElement.style.display = '';\n      }\n    }\n  }, {\n    key: 'hideContent',\n    value: function hideContent(newHeight) {\n      if (newHeight === 0) {\n        this.contentElement.style.display = 'none';\n      }\n    }\n  }, {\n    key: 'getStaticStateClasses',\n    value: function getStaticStateClasses(height) {\n      var _cx2;\n\n      return (0, _classnames2.default)((_cx2 = {}, _defineProperty(_cx2, this.animationStateClasses.static, true), _defineProperty(_cx2, this.animationStateClasses.staticHeightZero, height === 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightSpecific, height > 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightAuto, height === 'auto'), _cx2));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _cx3,\n          _this3 = this;\n\n      var _props2 = this.props,\n          animateOpacity = _props2.animateOpacity,\n          applyInlineTransitions = _props2.applyInlineTransitions,\n          children = _props2.children,\n          className = _props2.className,\n          contentClassName = _props2.contentClassName,\n          duration = _props2.duration,\n          easing = _props2.easing,\n          delay = _props2.delay,\n          style = _props2.style;\n      var _state = this.state,\n          height = _state.height,\n          overflow = _state.overflow,\n          animationStateClasses = _state.animationStateClasses,\n          shouldUseTransitions = _state.shouldUseTransitions;\n\n      var componentStyle = _extends({}, style, {\n        height: height,\n        overflow: overflow || style.overflow\n      });\n\n      if (shouldUseTransitions && applyInlineTransitions) {\n        componentStyle.transition = 'height ' + duration + 'ms ' + easing + ' ' + delay + 'ms'; // Include transition passed through styles\n\n        if (style.transition) {\n          componentStyle.transition = style.transition + ', ' + componentStyle.transition;\n        } // Add webkit vendor prefix still used by opera, blackberry...\n\n\n        componentStyle.WebkitTransition = componentStyle.transition;\n      }\n\n      var contentStyle = {};\n\n      if (animateOpacity) {\n        contentStyle.transition = 'opacity ' + duration + 'ms ' + easing + ' ' + delay + 'ms'; // Add webkit vendor prefix still used by opera, blackberry...\n\n        contentStyle.WebkitTransition = contentStyle.transition;\n\n        if (height === 0) {\n          contentStyle.opacity = 0;\n        }\n      }\n\n      var componentClasses = (0, _classnames2.default)((_cx3 = {}, _defineProperty(_cx3, animationStateClasses, true), _defineProperty(_cx3, className, className), _cx3));\n      return _react2.default.createElement('div', _extends({}, omit.apply(undefined, [this.props].concat(PROPS_TO_OMIT)), {\n        'aria-hidden': height === 0,\n        className: componentClasses,\n        style: componentStyle\n      }), _react2.default.createElement('div', {\n        className: contentClassName,\n        style: contentStyle,\n        ref: function ref(el) {\n          return _this3.contentElement = el;\n        }\n      }, children));\n    }\n  }]);\n\n  return AnimateHeight;\n}(_react2.default.Component);\n\nvar heightPropType = function heightPropType(props, propName, componentName) {\n  var value = props[propName];\n\n  if (typeof value === 'number' && value >= 0 || isPercentage(value) || value === 'auto') {\n    return null;\n  }\n\n  return new TypeError('value \"' + value + '\" of type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is invalid type for ' + propName + ' in ' + componentName + '. ' + 'It needs to be a positive number, string \"auto\" or percentage string (e.g. \"15%\").');\n};\n\nAnimateHeight.propTypes = {\n  animateOpacity: _propTypes2.default.bool,\n  animationStateClasses: _propTypes2.default.object,\n  applyInlineTransitions: _propTypes2.default.bool,\n  children: _propTypes2.default.any.isRequired,\n  className: _propTypes2.default.string,\n  contentClassName: _propTypes2.default.string,\n  duration: _propTypes2.default.number,\n  delay: _propTypes2.default.number,\n  easing: _propTypes2.default.string,\n  height: heightPropType,\n  onAnimationEnd: _propTypes2.default.func,\n  onAnimationStart: _propTypes2.default.func,\n  style: _propTypes2.default.object\n};\nAnimateHeight.defaultProps = {\n  animateOpacity: false,\n  animationStateClasses: ANIMATION_STATE_CLASSES,\n  applyInlineTransitions: true,\n  duration: 250,\n  delay: 0,\n  easing: 'ease',\n  style: {}\n};\nexports.default = AnimateHeight;\n\n//# sourceURL=webpack:///./node_modules/react-animate-height/lib/AnimateHeight.js?")},"./node_modules/react-animate-height/node_modules/prop-types/factoryWithThrowingShims.js":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/react-animate-height/node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n\nfunction emptyFunction() {}\n\nfunction emptyFunctionWithReset() {}\n\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function () {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n\n    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n    err.name = 'Invariant Violation';\n    throw err;\n  }\n\n  ;\n  shim.isRequired = shim;\n\n  function getShim() {\n    return shim;\n  }\n\n  ; // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n  ReactPropTypes.PropTypes = ReactPropTypes;\n  return ReactPropTypes;\n};\n\n//# sourceURL=webpack:///./node_modules/react-animate-height/node_modules/prop-types/factoryWithThrowingShims.js?")},"./node_modules/react-animate-height/node_modules/prop-types/index.js":function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(/*! ./factoryWithThrowingShims */ "./node_modules/react-animate-height/node_modules/prop-types/factoryWithThrowingShims.js")();\n}\n\n//# sourceURL=webpack:///./node_modules/react-animate-height/node_modules/prop-types/index.js?')},"./node_modules/react-animate-height/node_modules/prop-types/lib/ReactPropTypesSecret.js":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nmodule.exports = ReactPropTypesSecret;\n\n//# sourceURL=webpack:///./node_modules/react-animate-height/node_modules/prop-types/lib/ReactPropTypesSecret.js?")},"./node_modules/react-autosuggest/dist/Autosuggest.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/preact-compat/dist/preact-compat.es.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/react-autosuggest/node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _arrays = __webpack_require__(/*! shallow-equal/arrays */ \"./node_modules/react-autosuggest/node_modules/shallow-equal/arrays/index.js\");\n\nvar _arrays2 = _interopRequireDefault(_arrays);\n\nvar _reactAutowhatever = __webpack_require__(/*! react-autowhatever */ \"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/index.js\");\n\nvar _reactAutowhatever2 = _interopRequireDefault(_reactAutowhatever);\n\nvar _theme = __webpack_require__(/*! ./theme */ \"./node_modules/react-autosuggest/dist/theme.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar alwaysTrue = function alwaysTrue() {\n  return true;\n};\n\nvar defaultShouldRenderSuggestions = function defaultShouldRenderSuggestions(value) {\n  return value.trim().length > 0;\n};\n\nvar defaultRenderSuggestionsContainer = function defaultRenderSuggestionsContainer(_ref) {\n  var containerProps = _ref.containerProps,\n      children = _ref.children;\n  return _react2.default.createElement('div', containerProps, children);\n};\n\nvar Autosuggest = function (_Component) {\n  _inherits(Autosuggest, _Component);\n\n  function Autosuggest(_ref2) {\n    var alwaysRenderSuggestions = _ref2.alwaysRenderSuggestions;\n\n    _classCallCheck(this, Autosuggest);\n\n    var _this = _possibleConstructorReturn(this, (Autosuggest.__proto__ || Object.getPrototypeOf(Autosuggest)).call(this));\n\n    _initialiseProps.call(_this);\n\n    _this.state = {\n      isFocused: false,\n      isCollapsed: !alwaysRenderSuggestions,\n      highlightedSectionIndex: null,\n      highlightedSuggestionIndex: null,\n      highlightedSuggestion: null,\n      valueBeforeUpDown: null\n    };\n    _this.justPressedUpDown = false;\n    _this.justMouseEntered = false;\n    _this.pressedSuggestion = null;\n    return _this;\n  }\n\n  _createClass(Autosuggest, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      document.addEventListener('mousedown', this.onDocumentMouseDown);\n      document.addEventListener('mouseup', this.onDocumentMouseUp);\n      this.input = this.autowhatever.input;\n      this.suggestionsContainer = this.autowhatever.itemsContainer;\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      if ((0, _arrays2.default)(nextProps.suggestions, this.props.suggestions)) {\n        if (nextProps.highlightFirstSuggestion && nextProps.suggestions.length > 0 && this.justPressedUpDown === false && this.justMouseEntered === false) {\n          this.highlightFirstSuggestion();\n        }\n      } else {\n        if (this.willRenderSuggestions(nextProps)) {\n          if (this.state.isCollapsed && !this.justSelectedSuggestion) {\n            this.revealSuggestions();\n          }\n        } else {\n          this.resetHighlightedSuggestion();\n        }\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props = this.props,\n          suggestions = _props.suggestions,\n          onSuggestionHighlighted = _props.onSuggestionHighlighted,\n          highlightFirstSuggestion = _props.highlightFirstSuggestion;\n\n      if (!(0, _arrays2.default)(suggestions, prevProps.suggestions) && suggestions.length > 0 && highlightFirstSuggestion) {\n        this.highlightFirstSuggestion();\n        return;\n      }\n\n      if (onSuggestionHighlighted) {\n        var highlightedSuggestion = this.getHighlightedSuggestion();\n        var prevHighlightedSuggestion = prevState.highlightedSuggestion;\n\n        if (highlightedSuggestion != prevHighlightedSuggestion) {\n          onSuggestionHighlighted({\n            suggestion: highlightedSuggestion\n          });\n        }\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      document.removeEventListener('mousedown', this.onDocumentMouseDown);\n      document.removeEventListener('mouseup', this.onDocumentMouseUp);\n    }\n  }, {\n    key: 'updateHighlightedSuggestion',\n    value: function updateHighlightedSuggestion(sectionIndex, suggestionIndex, prevValue) {\n      var _this2 = this;\n\n      this.setState(function (state) {\n        var valueBeforeUpDown = state.valueBeforeUpDown;\n\n        if (suggestionIndex === null) {\n          valueBeforeUpDown = null;\n        } else if (valueBeforeUpDown === null && typeof prevValue !== 'undefined') {\n          valueBeforeUpDown = prevValue;\n        }\n\n        return {\n          highlightedSectionIndex: sectionIndex,\n          highlightedSuggestionIndex: suggestionIndex,\n          highlightedSuggestion: suggestionIndex === null ? null : _this2.getSuggestion(sectionIndex, suggestionIndex),\n          valueBeforeUpDown: valueBeforeUpDown\n        };\n      });\n    }\n  }, {\n    key: 'resetHighlightedSuggestion',\n    value: function resetHighlightedSuggestion() {\n      var shouldResetValueBeforeUpDown = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.setState(function (state) {\n        var valueBeforeUpDown = state.valueBeforeUpDown;\n        return {\n          highlightedSectionIndex: null,\n          highlightedSuggestionIndex: null,\n          highlightedSuggestion: null,\n          valueBeforeUpDown: shouldResetValueBeforeUpDown ? null : valueBeforeUpDown\n        };\n      });\n    }\n  }, {\n    key: 'revealSuggestions',\n    value: function revealSuggestions() {\n      this.setState({\n        isCollapsed: false\n      });\n    }\n  }, {\n    key: 'closeSuggestions',\n    value: function closeSuggestions() {\n      this.setState({\n        highlightedSectionIndex: null,\n        highlightedSuggestionIndex: null,\n        highlightedSuggestion: null,\n        valueBeforeUpDown: null,\n        isCollapsed: true\n      });\n    }\n  }, {\n    key: 'getSuggestion',\n    value: function getSuggestion(sectionIndex, suggestionIndex) {\n      var _props2 = this.props,\n          suggestions = _props2.suggestions,\n          multiSection = _props2.multiSection,\n          getSectionSuggestions = _props2.getSectionSuggestions;\n\n      if (multiSection) {\n        return getSectionSuggestions(suggestions[sectionIndex])[suggestionIndex];\n      }\n\n      return suggestions[suggestionIndex];\n    }\n  }, {\n    key: 'getHighlightedSuggestion',\n    value: function getHighlightedSuggestion() {\n      var _state = this.state,\n          highlightedSectionIndex = _state.highlightedSectionIndex,\n          highlightedSuggestionIndex = _state.highlightedSuggestionIndex;\n\n      if (highlightedSuggestionIndex === null) {\n        return null;\n      }\n\n      return this.getSuggestion(highlightedSectionIndex, highlightedSuggestionIndex);\n    }\n  }, {\n    key: 'getSuggestionValueByIndex',\n    value: function getSuggestionValueByIndex(sectionIndex, suggestionIndex) {\n      var getSuggestionValue = this.props.getSuggestionValue;\n      return getSuggestionValue(this.getSuggestion(sectionIndex, suggestionIndex));\n    }\n  }, {\n    key: 'getSuggestionIndices',\n    value: function getSuggestionIndices(suggestionElement) {\n      var sectionIndex = suggestionElement.getAttribute('data-section-index');\n      var suggestionIndex = suggestionElement.getAttribute('data-suggestion-index');\n      return {\n        sectionIndex: typeof sectionIndex === 'string' ? parseInt(sectionIndex, 10) : null,\n        suggestionIndex: parseInt(suggestionIndex, 10)\n      };\n    }\n  }, {\n    key: 'findSuggestionElement',\n    value: function findSuggestionElement(startNode) {\n      var node = startNode;\n\n      do {\n        if (node.getAttribute('data-suggestion-index') !== null) {\n          return node;\n        }\n\n        node = node.parentNode;\n      } while (node !== null);\n\n      console.error('Clicked element:', startNode); // eslint-disable-line no-console\n\n      throw new Error(\"Couldn't find suggestion element\");\n    }\n  }, {\n    key: 'maybeCallOnChange',\n    value: function maybeCallOnChange(event, newValue, method) {\n      var _props$inputProps = this.props.inputProps,\n          value = _props$inputProps.value,\n          onChange = _props$inputProps.onChange;\n\n      if (newValue !== value) {\n        onChange(event, {\n          newValue: newValue,\n          method: method\n        });\n      }\n    }\n  }, {\n    key: 'willRenderSuggestions',\n    value: function willRenderSuggestions(props) {\n      var suggestions = props.suggestions,\n          inputProps = props.inputProps,\n          shouldRenderSuggestions = props.shouldRenderSuggestions;\n      var value = inputProps.value;\n      return suggestions.length > 0 && shouldRenderSuggestions(value);\n    }\n  }, {\n    key: 'getQuery',\n    value: function getQuery() {\n      var inputProps = this.props.inputProps;\n      var value = inputProps.value;\n      var valueBeforeUpDown = this.state.valueBeforeUpDown;\n      return (valueBeforeUpDown === null ? value : valueBeforeUpDown).trim();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props3 = this.props,\n          suggestions = _props3.suggestions,\n          renderInputComponent = _props3.renderInputComponent,\n          onSuggestionsFetchRequested = _props3.onSuggestionsFetchRequested,\n          renderSuggestion = _props3.renderSuggestion,\n          inputProps = _props3.inputProps,\n          multiSection = _props3.multiSection,\n          renderSectionTitle = _props3.renderSectionTitle,\n          id = _props3.id,\n          getSectionSuggestions = _props3.getSectionSuggestions,\n          theme = _props3.theme,\n          getSuggestionValue = _props3.getSuggestionValue,\n          alwaysRenderSuggestions = _props3.alwaysRenderSuggestions,\n          highlightFirstSuggestion = _props3.highlightFirstSuggestion;\n      var _state2 = this.state,\n          isFocused = _state2.isFocused,\n          isCollapsed = _state2.isCollapsed,\n          highlightedSectionIndex = _state2.highlightedSectionIndex,\n          highlightedSuggestionIndex = _state2.highlightedSuggestionIndex,\n          valueBeforeUpDown = _state2.valueBeforeUpDown;\n      var shouldRenderSuggestions = alwaysRenderSuggestions ? alwaysTrue : this.props.shouldRenderSuggestions;\n      var value = inputProps.value,\n          _onFocus = inputProps.onFocus,\n          _onKeyDown = inputProps.onKeyDown;\n      var willRenderSuggestions = this.willRenderSuggestions(this.props);\n      var isOpen = alwaysRenderSuggestions || isFocused && !isCollapsed && willRenderSuggestions;\n      var items = isOpen ? suggestions : [];\n\n      var autowhateverInputProps = _extends({}, inputProps, {\n        onFocus: function onFocus(event) {\n          if (!_this3.justSelectedSuggestion && !_this3.justClickedOnSuggestionsContainer) {\n            var shouldRender = shouldRenderSuggestions(value);\n\n            _this3.setState({\n              isFocused: true,\n              isCollapsed: !shouldRender\n            });\n\n            _onFocus && _onFocus(event);\n\n            if (shouldRender) {\n              onSuggestionsFetchRequested({\n                value: value,\n                reason: 'input-focused'\n              });\n            }\n          }\n        },\n        onBlur: function onBlur(event) {\n          if (_this3.justClickedOnSuggestionsContainer) {\n            _this3.input.focus();\n\n            return;\n          }\n\n          _this3.blurEvent = event;\n\n          if (!_this3.justSelectedSuggestion) {\n            _this3.onBlur();\n\n            _this3.onSuggestionsClearRequested();\n          }\n        },\n        onChange: function onChange(event) {\n          var value = event.target.value;\n          var shouldRender = shouldRenderSuggestions(value);\n\n          _this3.maybeCallOnChange(event, value, 'type');\n\n          if (_this3.suggestionsContainer) {\n            _this3.suggestionsContainer.scrollTop = 0;\n          }\n\n          _this3.setState(_extends({}, highlightFirstSuggestion ? {} : {\n            highlightedSectionIndex: null,\n            highlightedSuggestionIndex: null,\n            highlightedSuggestion: null\n          }, {\n            valueBeforeUpDown: null,\n            isCollapsed: !shouldRender\n          }));\n\n          if (shouldRender) {\n            onSuggestionsFetchRequested({\n              value: value,\n              reason: 'input-changed'\n            });\n          } else {\n            _this3.onSuggestionsClearRequested();\n          }\n        },\n        onKeyDown: function onKeyDown(event, data) {\n          var keyCode = event.keyCode;\n\n          switch (keyCode) {\n            case 40: // ArrowDown\n\n            case 38:\n              // ArrowUp\n              if (isCollapsed) {\n                if (shouldRenderSuggestions(value)) {\n                  onSuggestionsFetchRequested({\n                    value: value,\n                    reason: 'suggestions-revealed'\n                  });\n\n                  _this3.revealSuggestions();\n                }\n              } else if (suggestions.length > 0) {\n                var newHighlightedSectionIndex = data.newHighlightedSectionIndex,\n                    newHighlightedItemIndex = data.newHighlightedItemIndex;\n                var newValue = void 0;\n\n                if (newHighlightedItemIndex === null) {\n                  // valueBeforeUpDown can be null if, for example, user\n                  // hovers on the first suggestion and then pressed Up.\n                  // If that happens, use the original input value.\n                  newValue = valueBeforeUpDown === null ? value : valueBeforeUpDown;\n                } else {\n                  newValue = _this3.getSuggestionValueByIndex(newHighlightedSectionIndex, newHighlightedItemIndex);\n                }\n\n                _this3.updateHighlightedSuggestion(newHighlightedSectionIndex, newHighlightedItemIndex, value);\n\n                _this3.maybeCallOnChange(event, newValue, keyCode === 40 ? 'down' : 'up');\n              }\n\n              event.preventDefault(); // Prevents the cursor from moving\n\n              _this3.justPressedUpDown = true;\n              setTimeout(function () {\n                _this3.justPressedUpDown = false;\n              });\n              break;\n            // Enter\n\n            case 13:\n              {\n                // See #388\n                if (event.keyCode === 229) {\n                  break;\n                }\n\n                var highlightedSuggestion = _this3.getHighlightedSuggestion();\n\n                if (isOpen && !alwaysRenderSuggestions) {\n                  _this3.closeSuggestions();\n                }\n\n                if (highlightedSuggestion != null) {\n                  var _newValue = getSuggestionValue(highlightedSuggestion);\n\n                  _this3.maybeCallOnChange(event, _newValue, 'enter');\n\n                  _this3.onSuggestionSelected(event, {\n                    suggestion: highlightedSuggestion,\n                    suggestionValue: _newValue,\n                    suggestionIndex: highlightedSuggestionIndex,\n                    sectionIndex: highlightedSectionIndex,\n                    method: 'enter'\n                  });\n\n                  _this3.justSelectedSuggestion = true;\n                  setTimeout(function () {\n                    _this3.justSelectedSuggestion = false;\n                  });\n                }\n\n                break;\n              }\n            // Escape\n\n            case 27:\n              {\n                if (isOpen) {\n                  // If input.type === 'search', the browser clears the input\n                  // when Escape is pressed. We want to disable this default\n                  // behaviour so that, when suggestions are shown, we just hide\n                  // them, without clearing the input.\n                  event.preventDefault();\n                }\n\n                var willCloseSuggestions = isOpen && !alwaysRenderSuggestions;\n\n                if (valueBeforeUpDown === null) {\n                  // Didn't interact with Up/Down\n                  if (!willCloseSuggestions) {\n                    var _newValue2 = '';\n\n                    _this3.maybeCallOnChange(event, _newValue2, 'escape');\n\n                    if (shouldRenderSuggestions(_newValue2)) {\n                      onSuggestionsFetchRequested({\n                        value: _newValue2,\n                        reason: 'escape-pressed'\n                      });\n                    } else {\n                      _this3.onSuggestionsClearRequested();\n                    }\n                  }\n                } else {\n                  // Interacted with Up/Down\n                  _this3.maybeCallOnChange(event, valueBeforeUpDown, 'escape');\n                }\n\n                if (willCloseSuggestions) {\n                  _this3.onSuggestionsClearRequested();\n\n                  _this3.closeSuggestions();\n                } else {\n                  _this3.resetHighlightedSuggestion();\n                }\n\n                break;\n              }\n          }\n\n          _onKeyDown && _onKeyDown(event);\n        }\n      });\n\n      var renderSuggestionData = {\n        query: this.getQuery()\n      };\n      return _react2.default.createElement(_reactAutowhatever2.default, {\n        multiSection: multiSection,\n        items: items,\n        renderInputComponent: renderInputComponent,\n        renderItemsContainer: this.renderSuggestionsContainer,\n        renderItem: renderSuggestion,\n        renderItemData: renderSuggestionData,\n        renderSectionTitle: renderSectionTitle,\n        getSectionItems: getSectionSuggestions,\n        highlightedSectionIndex: highlightedSectionIndex,\n        highlightedItemIndex: highlightedSuggestionIndex,\n        inputProps: autowhateverInputProps,\n        itemProps: this.itemProps,\n        theme: (0, _theme.mapToAutowhateverTheme)(theme),\n        id: id,\n        ref: this.storeAutowhateverRef\n      });\n    }\n  }]);\n\n  return Autosuggest;\n}(_react.Component);\n\nAutosuggest.propTypes = {\n  suggestions: _propTypes2.default.array.isRequired,\n  onSuggestionsFetchRequested: function onSuggestionsFetchRequested(props, propName) {\n    var onSuggestionsFetchRequested = props[propName];\n\n    if (typeof onSuggestionsFetchRequested !== 'function') {\n      throw new Error(\"'onSuggestionsFetchRequested' must be implemented. See: https://github.com/moroshko/react-autosuggest#onSuggestionsFetchRequestedProp\");\n    }\n  },\n  onSuggestionsClearRequested: function onSuggestionsClearRequested(props, propName) {\n    var onSuggestionsClearRequested = props[propName];\n\n    if (props.alwaysRenderSuggestions === false && typeof onSuggestionsClearRequested !== 'function') {\n      throw new Error(\"'onSuggestionsClearRequested' must be implemented. See: https://github.com/moroshko/react-autosuggest#onSuggestionsClearRequestedProp\");\n    }\n  },\n  onSuggestionSelected: _propTypes2.default.func,\n  onSuggestionHighlighted: _propTypes2.default.func,\n  renderInputComponent: _propTypes2.default.func,\n  renderSuggestionsContainer: _propTypes2.default.func,\n  getSuggestionValue: _propTypes2.default.func.isRequired,\n  renderSuggestion: _propTypes2.default.func.isRequired,\n  inputProps: function inputProps(props, propName) {\n    var inputProps = props[propName];\n\n    if (!inputProps.hasOwnProperty('value')) {\n      throw new Error(\"'inputProps' must have 'value'.\");\n    }\n\n    if (!inputProps.hasOwnProperty('onChange')) {\n      throw new Error(\"'inputProps' must have 'onChange'.\");\n    }\n  },\n  shouldRenderSuggestions: _propTypes2.default.func,\n  alwaysRenderSuggestions: _propTypes2.default.bool,\n  multiSection: _propTypes2.default.bool,\n  renderSectionTitle: function renderSectionTitle(props, propName) {\n    var renderSectionTitle = props[propName];\n\n    if (props.multiSection === true && typeof renderSectionTitle !== 'function') {\n      throw new Error(\"'renderSectionTitle' must be implemented. See: https://github.com/moroshko/react-autosuggest#renderSectionTitleProp\");\n    }\n  },\n  getSectionSuggestions: function getSectionSuggestions(props, propName) {\n    var getSectionSuggestions = props[propName];\n\n    if (props.multiSection === true && typeof getSectionSuggestions !== 'function') {\n      throw new Error(\"'getSectionSuggestions' must be implemented. See: https://github.com/moroshko/react-autosuggest#getSectionSuggestionsProp\");\n    }\n  },\n  focusInputOnSuggestionClick: _propTypes2.default.bool,\n  highlightFirstSuggestion: _propTypes2.default.bool,\n  theme: _propTypes2.default.object,\n  id: _propTypes2.default.string\n};\nAutosuggest.defaultProps = {\n  renderSuggestionsContainer: defaultRenderSuggestionsContainer,\n  shouldRenderSuggestions: defaultShouldRenderSuggestions,\n  alwaysRenderSuggestions: false,\n  multiSection: false,\n  focusInputOnSuggestionClick: true,\n  highlightFirstSuggestion: false,\n  theme: _theme.defaultTheme,\n  id: '1'\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this.onDocumentMouseDown = function (event) {\n    _this4.justClickedOnSuggestionsContainer = false;\n    var node = event.detail && event.detail.target || // This is for testing only. Please show me a better way to emulate this.\n    event.target;\n\n    while (node !== null && node !== document) {\n      if (node.getAttribute('data-suggestion-index') !== null) {\n        // Suggestion was clicked\n        return;\n      }\n\n      if (node === _this4.suggestionsContainer) {\n        // Something else inside suggestions container was clicked\n        _this4.justClickedOnSuggestionsContainer = true;\n        return;\n      }\n\n      node = node.parentNode;\n    }\n  };\n\n  this.storeAutowhateverRef = function (autowhatever) {\n    if (autowhatever !== null) {\n      _this4.autowhatever = autowhatever;\n    }\n  };\n\n  this.onSuggestionMouseEnter = function (event, _ref3) {\n    var sectionIndex = _ref3.sectionIndex,\n        itemIndex = _ref3.itemIndex;\n\n    _this4.updateHighlightedSuggestion(sectionIndex, itemIndex);\n\n    if (event.target === _this4.pressedSuggestion) {\n      _this4.justSelectedSuggestion = true;\n    }\n\n    _this4.justMouseEntered = true;\n    setTimeout(function () {\n      _this4.justMouseEntered = false;\n    });\n  };\n\n  this.highlightFirstSuggestion = function () {\n    _this4.updateHighlightedSuggestion(_this4.props.multiSection ? 0 : null, 0);\n  };\n\n  this.onDocumentMouseUp = function () {\n    if (_this4.pressedSuggestion && !_this4.justSelectedSuggestion) {\n      _this4.input.focus();\n    }\n\n    _this4.pressedSuggestion = null;\n  };\n\n  this.onSuggestionMouseDown = function (event) {\n    // Checking if this.justSelectedSuggestion is already true to not duplicate touch events in chrome\n    // See: https://github.com/facebook/react/issues/9809#issuecomment-413978405\n    if (!_this4.justSelectedSuggestion) {\n      _this4.justSelectedSuggestion = true;\n      _this4.pressedSuggestion = event.target;\n    }\n  };\n\n  this.onSuggestionsClearRequested = function () {\n    var onSuggestionsClearRequested = _this4.props.onSuggestionsClearRequested;\n    onSuggestionsClearRequested && onSuggestionsClearRequested();\n  };\n\n  this.onSuggestionSelected = function (event, data) {\n    var _props4 = _this4.props,\n        alwaysRenderSuggestions = _props4.alwaysRenderSuggestions,\n        onSuggestionSelected = _props4.onSuggestionSelected,\n        onSuggestionsFetchRequested = _props4.onSuggestionsFetchRequested;\n    onSuggestionSelected && onSuggestionSelected(event, data);\n\n    if (alwaysRenderSuggestions) {\n      onSuggestionsFetchRequested({\n        value: data.suggestionValue,\n        reason: 'suggestion-selected'\n      });\n    } else {\n      _this4.onSuggestionsClearRequested();\n    }\n\n    _this4.resetHighlightedSuggestion();\n  };\n\n  this.onSuggestionClick = function (event) {\n    var _props5 = _this4.props,\n        alwaysRenderSuggestions = _props5.alwaysRenderSuggestions,\n        focusInputOnSuggestionClick = _props5.focusInputOnSuggestionClick;\n\n    var _getSuggestionIndices = _this4.getSuggestionIndices(_this4.findSuggestionElement(event.target)),\n        sectionIndex = _getSuggestionIndices.sectionIndex,\n        suggestionIndex = _getSuggestionIndices.suggestionIndex;\n\n    var clickedSuggestion = _this4.getSuggestion(sectionIndex, suggestionIndex);\n\n    var clickedSuggestionValue = _this4.props.getSuggestionValue(clickedSuggestion);\n\n    _this4.maybeCallOnChange(event, clickedSuggestionValue, 'click');\n\n    _this4.onSuggestionSelected(event, {\n      suggestion: clickedSuggestion,\n      suggestionValue: clickedSuggestionValue,\n      suggestionIndex: suggestionIndex,\n      sectionIndex: sectionIndex,\n      method: 'click'\n    });\n\n    if (!alwaysRenderSuggestions) {\n      _this4.closeSuggestions();\n    }\n\n    if (focusInputOnSuggestionClick === true) {\n      _this4.input.focus();\n    } else {\n      _this4.onBlur();\n    }\n\n    setTimeout(function () {\n      _this4.justSelectedSuggestion = false;\n    });\n  };\n\n  this.onBlur = function () {\n    var _props6 = _this4.props,\n        inputProps = _props6.inputProps,\n        shouldRenderSuggestions = _props6.shouldRenderSuggestions;\n    var value = inputProps.value,\n        onBlur = inputProps.onBlur;\n\n    var highlightedSuggestion = _this4.getHighlightedSuggestion();\n\n    var shouldRender = shouldRenderSuggestions(value);\n\n    _this4.setState({\n      isFocused: false,\n      highlightedSectionIndex: null,\n      highlightedSuggestionIndex: null,\n      highlightedSuggestion: null,\n      valueBeforeUpDown: null,\n      isCollapsed: !shouldRender\n    });\n\n    onBlur && onBlur(_this4.blurEvent, {\n      highlightedSuggestion: highlightedSuggestion\n    });\n  };\n\n  this.onSuggestionMouseLeave = function (event) {\n    _this4.resetHighlightedSuggestion(false); // shouldResetValueBeforeUpDown\n\n\n    if (_this4.justSelectedSuggestion && event.target === _this4.pressedSuggestion) {\n      _this4.justSelectedSuggestion = false;\n    }\n  };\n\n  this.onSuggestionTouchStart = function () {\n    _this4.justSelectedSuggestion = true; // todo: event.preventDefault when https://github.com/facebook/react/issues/2043\n    // todo: gets released so onSuggestionMouseDown won't fire in chrome\n  };\n\n  this.onSuggestionTouchMove = function () {\n    _this4.justSelectedSuggestion = false;\n    _this4.pressedSuggestion = null;\n\n    _this4.input.focus();\n  };\n\n  this.itemProps = function (_ref4) {\n    var sectionIndex = _ref4.sectionIndex,\n        itemIndex = _ref4.itemIndex;\n    return {\n      'data-section-index': sectionIndex,\n      'data-suggestion-index': itemIndex,\n      onMouseEnter: _this4.onSuggestionMouseEnter,\n      onMouseLeave: _this4.onSuggestionMouseLeave,\n      onMouseDown: _this4.onSuggestionMouseDown,\n      onTouchStart: _this4.onSuggestionTouchStart,\n      onTouchMove: _this4.onSuggestionTouchMove,\n      onClick: _this4.onSuggestionClick\n    };\n  };\n\n  this.renderSuggestionsContainer = function (_ref5) {\n    var containerProps = _ref5.containerProps,\n        children = _ref5.children;\n    var renderSuggestionsContainer = _this4.props.renderSuggestionsContainer;\n    return renderSuggestionsContainer({\n      containerProps: containerProps,\n      children: children,\n      query: _this4.getQuery()\n    });\n  };\n};\n\nexports.default = Autosuggest;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/dist/Autosuggest.js?")},"./node_modules/react-autosuggest/dist/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = __webpack_require__(/*! ./Autosuggest */ "./node_modules/react-autosuggest/dist/Autosuggest.js").default;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/dist/index.js?')},"./node_modules/react-autosuggest/dist/theme.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar defaultTheme = exports.defaultTheme = {\n  container: 'react-autosuggest__container',\n  containerOpen: 'react-autosuggest__container--open',\n  input: 'react-autosuggest__input',\n  inputOpen: 'react-autosuggest__input--open',\n  inputFocused: 'react-autosuggest__input--focused',\n  suggestionsContainer: 'react-autosuggest__suggestions-container',\n  suggestionsContainerOpen: 'react-autosuggest__suggestions-container--open',\n  suggestionsList: 'react-autosuggest__suggestions-list',\n  suggestion: 'react-autosuggest__suggestion',\n  suggestionFirst: 'react-autosuggest__suggestion--first',\n  suggestionHighlighted: 'react-autosuggest__suggestion--highlighted',\n  sectionContainer: 'react-autosuggest__section-container',\n  sectionContainerFirst: 'react-autosuggest__section-container--first',\n  sectionTitle: 'react-autosuggest__section-title'\n};\n\nvar mapToAutowhateverTheme = exports.mapToAutowhateverTheme = function mapToAutowhateverTheme(theme) {\n  var result = {};\n\n  for (var key in theme) {\n    switch (key) {\n      case 'suggestionsContainer':\n        result['itemsContainer'] = theme[key];\n        break;\n\n      case 'suggestionsContainerOpen':\n        result['itemsContainerOpen'] = theme[key];\n        break;\n\n      case 'suggestion':\n        result['item'] = theme[key];\n        break;\n\n      case 'suggestionFirst':\n        result['itemFirst'] = theme[key];\n        break;\n\n      case 'suggestionHighlighted':\n        result['itemHighlighted'] = theme[key];\n        break;\n\n      case 'suggestionsList':\n        result['itemsList'] = theme[key];\n        break;\n\n      default:\n        result[key] = theme[key];\n    }\n  }\n\n  return result;\n};\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/dist/theme.js?")},"./node_modules/react-autosuggest/node_modules/prop-types/factoryWithThrowingShims.js":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/react-autosuggest/node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n\nfunction emptyFunction() {}\n\nfunction emptyFunctionWithReset() {}\n\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function () {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n\n    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n    err.name = 'Invariant Violation';\n    throw err;\n  }\n\n  ;\n  shim.isRequired = shim;\n\n  function getShim() {\n    return shim;\n  }\n\n  ; // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n  ReactPropTypes.PropTypes = ReactPropTypes;\n  return ReactPropTypes;\n};\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/prop-types/factoryWithThrowingShims.js?")},"./node_modules/react-autosuggest/node_modules/prop-types/index.js":function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(/*! ./factoryWithThrowingShims */ "./node_modules/react-autosuggest/node_modules/prop-types/factoryWithThrowingShims.js")();\n}\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/prop-types/index.js?')},"./node_modules/react-autosuggest/node_modules/prop-types/lib/ReactPropTypesSecret.js":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nmodule.exports = ReactPropTypesSecret;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/prop-types/lib/ReactPropTypesSecret.js?")},"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/Autowhatever.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/preact-compat/dist/preact-compat.es.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/react-autosuggest/node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _sectionIterator = __webpack_require__(/*! section-iterator */ \"./node_modules/react-autosuggest/node_modules/section-iterator/dist/index.js\");\n\nvar _sectionIterator2 = _interopRequireDefault(_sectionIterator);\n\nvar _reactThemeable = __webpack_require__(/*! react-themeable */ \"./node_modules/react-autosuggest/node_modules/react-themeable/dist/index.js\");\n\nvar _reactThemeable2 = _interopRequireDefault(_reactThemeable);\n\nvar _SectionTitle = __webpack_require__(/*! ./SectionTitle */ \"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/SectionTitle.js\");\n\nvar _SectionTitle2 = _interopRequireDefault(_SectionTitle);\n\nvar _ItemsList = __webpack_require__(/*! ./ItemsList */ \"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/ItemsList.js\");\n\nvar _ItemsList2 = _interopRequireDefault(_ItemsList);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar emptyObject = {};\n\nvar defaultRenderInputComponent = function defaultRenderInputComponent(props) {\n  return _react2.default.createElement('input', props);\n};\n\nvar defaultRenderItemsContainer = function defaultRenderItemsContainer(_ref) {\n  var containerProps = _ref.containerProps,\n      children = _ref.children;\n  return _react2.default.createElement('div', containerProps, children);\n};\n\nvar defaultTheme = {\n  container: 'react-autowhatever__container',\n  containerOpen: 'react-autowhatever__container--open',\n  input: 'react-autowhatever__input',\n  inputOpen: 'react-autowhatever__input--open',\n  inputFocused: 'react-autowhatever__input--focused',\n  itemsContainer: 'react-autowhatever__items-container',\n  itemsContainerOpen: 'react-autowhatever__items-container--open',\n  itemsList: 'react-autowhatever__items-list',\n  item: 'react-autowhatever__item',\n  itemFirst: 'react-autowhatever__item--first',\n  itemHighlighted: 'react-autowhatever__item--highlighted',\n  sectionContainer: 'react-autowhatever__section-container',\n  sectionContainerFirst: 'react-autowhatever__section-container--first',\n  sectionTitle: 'react-autowhatever__section-title'\n};\n\nvar Autowhatever = function (_Component) {\n  _inherits(Autowhatever, _Component);\n\n  function Autowhatever(props) {\n    _classCallCheck(this, Autowhatever);\n\n    var _this = _possibleConstructorReturn(this, (Autowhatever.__proto__ || Object.getPrototypeOf(Autowhatever)).call(this, props));\n\n    _this.storeInputReference = function (input) {\n      if (input !== null) {\n        _this.input = input;\n      }\n    };\n\n    _this.storeItemsContainerReference = function (itemsContainer) {\n      if (itemsContainer !== null) {\n        _this.itemsContainer = itemsContainer;\n      }\n    };\n\n    _this.onHighlightedItemChange = function (highlightedItem) {\n      _this.highlightedItem = highlightedItem;\n    };\n\n    _this.getItemId = function (sectionIndex, itemIndex) {\n      if (itemIndex === null) {\n        return null;\n      }\n\n      var id = _this.props.id;\n      var section = sectionIndex === null ? '' : 'section-' + sectionIndex;\n      return 'react-autowhatever-' + id + '-' + section + '-item-' + itemIndex;\n    };\n\n    _this.onFocus = function (event) {\n      var inputProps = _this.props.inputProps;\n\n      _this.setState({\n        isInputFocused: true\n      });\n\n      inputProps.onFocus && inputProps.onFocus(event);\n    };\n\n    _this.onBlur = function (event) {\n      var inputProps = _this.props.inputProps;\n\n      _this.setState({\n        isInputFocused: false\n      });\n\n      inputProps.onBlur && inputProps.onBlur(event);\n    };\n\n    _this.onKeyDown = function (event) {\n      var _this$props = _this.props,\n          inputProps = _this$props.inputProps,\n          highlightedSectionIndex = _this$props.highlightedSectionIndex,\n          highlightedItemIndex = _this$props.highlightedItemIndex;\n\n      switch (event.key) {\n        case 'ArrowDown':\n        case 'ArrowUp':\n          {\n            var nextPrev = event.key === 'ArrowDown' ? 'next' : 'prev';\n\n            var _this$sectionIterator = _this.sectionIterator[nextPrev]([highlightedSectionIndex, highlightedItemIndex]),\n                _this$sectionIterator2 = _slicedToArray(_this$sectionIterator, 2),\n                newHighlightedSectionIndex = _this$sectionIterator2[0],\n                newHighlightedItemIndex = _this$sectionIterator2[1];\n\n            inputProps.onKeyDown(event, {\n              newHighlightedSectionIndex: newHighlightedSectionIndex,\n              newHighlightedItemIndex: newHighlightedItemIndex\n            });\n            break;\n          }\n\n        default:\n          inputProps.onKeyDown(event, {\n            highlightedSectionIndex: highlightedSectionIndex,\n            highlightedItemIndex: highlightedItemIndex\n          });\n      }\n    };\n\n    _this.highlightedItem = null;\n    _this.state = {\n      isInputFocused: false\n    };\n\n    _this.setSectionsItems(props);\n\n    _this.setSectionIterator(props);\n\n    _this.setTheme(props);\n\n    return _this;\n  }\n\n  _createClass(Autowhatever, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.ensureHighlightedItemIsVisible();\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.items !== this.props.items) {\n        this.setSectionsItems(nextProps);\n      }\n\n      if (nextProps.items !== this.props.items || nextProps.multiSection !== this.props.multiSection) {\n        this.setSectionIterator(nextProps);\n      }\n\n      if (nextProps.theme !== this.props.theme) {\n        this.setTheme(nextProps);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.ensureHighlightedItemIsVisible();\n    }\n  }, {\n    key: 'setSectionsItems',\n    value: function setSectionsItems(props) {\n      if (props.multiSection) {\n        this.sectionsItems = props.items.map(function (section) {\n          return props.getSectionItems(section);\n        });\n        this.sectionsLengths = this.sectionsItems.map(function (items) {\n          return items.length;\n        });\n        this.allSectionsAreEmpty = this.sectionsLengths.every(function (itemsCount) {\n          return itemsCount === 0;\n        });\n      }\n    }\n  }, {\n    key: 'setSectionIterator',\n    value: function setSectionIterator(props) {\n      this.sectionIterator = (0, _sectionIterator2.default)({\n        multiSection: props.multiSection,\n        data: props.multiSection ? this.sectionsLengths : props.items.length\n      });\n    }\n  }, {\n    key: 'setTheme',\n    value: function setTheme(props) {\n      this.theme = (0, _reactThemeable2.default)(props.theme);\n    }\n  }, {\n    key: 'renderSections',\n    value: function renderSections() {\n      var _this2 = this;\n\n      if (this.allSectionsAreEmpty) {\n        return null;\n      }\n\n      var theme = this.theme;\n      var _props = this.props,\n          id = _props.id,\n          items = _props.items,\n          renderItem = _props.renderItem,\n          renderItemData = _props.renderItemData,\n          renderSectionTitle = _props.renderSectionTitle,\n          highlightedSectionIndex = _props.highlightedSectionIndex,\n          highlightedItemIndex = _props.highlightedItemIndex,\n          itemProps = _props.itemProps;\n      return items.map(function (section, sectionIndex) {\n        var keyPrefix = 'react-autowhatever-' + id + '-';\n        var sectionKeyPrefix = keyPrefix + 'section-' + sectionIndex + '-';\n        var isFirstSection = sectionIndex === 0; // `key` is provided by theme()\n\n        /* eslint-disable react/jsx-key */\n\n        return _react2.default.createElement('div', theme(sectionKeyPrefix + 'container', 'sectionContainer', isFirstSection && 'sectionContainerFirst'), _react2.default.createElement(_SectionTitle2.default, {\n          section: section,\n          renderSectionTitle: renderSectionTitle,\n          theme: theme,\n          sectionKeyPrefix: sectionKeyPrefix\n        }), _react2.default.createElement(_ItemsList2.default, {\n          items: _this2.sectionsItems[sectionIndex],\n          itemProps: itemProps,\n          renderItem: renderItem,\n          renderItemData: renderItemData,\n          sectionIndex: sectionIndex,\n          highlightedItemIndex: highlightedSectionIndex === sectionIndex ? highlightedItemIndex : null,\n          onHighlightedItemChange: _this2.onHighlightedItemChange,\n          getItemId: _this2.getItemId,\n          theme: theme,\n          keyPrefix: keyPrefix,\n          ref: _this2.storeItemsListReference\n        }));\n        /* eslint-enable react/jsx-key */\n      });\n    }\n  }, {\n    key: 'renderItems',\n    value: function renderItems() {\n      var items = this.props.items;\n\n      if (items.length === 0) {\n        return null;\n      }\n\n      var theme = this.theme;\n      var _props2 = this.props,\n          id = _props2.id,\n          renderItem = _props2.renderItem,\n          renderItemData = _props2.renderItemData,\n          highlightedSectionIndex = _props2.highlightedSectionIndex,\n          highlightedItemIndex = _props2.highlightedItemIndex,\n          itemProps = _props2.itemProps;\n      return _react2.default.createElement(_ItemsList2.default, {\n        items: items,\n        itemProps: itemProps,\n        renderItem: renderItem,\n        renderItemData: renderItemData,\n        highlightedItemIndex: highlightedSectionIndex === null ? highlightedItemIndex : null,\n        onHighlightedItemChange: this.onHighlightedItemChange,\n        getItemId: this.getItemId,\n        theme: theme,\n        keyPrefix: 'react-autowhatever-' + id + '-'\n      });\n    }\n  }, {\n    key: 'ensureHighlightedItemIsVisible',\n    value: function ensureHighlightedItemIsVisible() {\n      var highlightedItem = this.highlightedItem;\n\n      if (!highlightedItem) {\n        return;\n      }\n\n      var itemsContainer = this.itemsContainer;\n      var itemOffsetRelativeToContainer = highlightedItem.offsetParent === itemsContainer ? highlightedItem.offsetTop : highlightedItem.offsetTop - itemsContainer.offsetTop;\n      var scrollTop = itemsContainer.scrollTop; // Top of the visible area\n\n      if (itemOffsetRelativeToContainer < scrollTop) {\n        // Item is off the top of the visible area\n        scrollTop = itemOffsetRelativeToContainer;\n      } else if (itemOffsetRelativeToContainer + highlightedItem.offsetHeight > scrollTop + itemsContainer.offsetHeight) {\n        // Item is off the bottom of the visible area\n        scrollTop = itemOffsetRelativeToContainer + highlightedItem.offsetHeight - itemsContainer.offsetHeight;\n      }\n\n      if (scrollTop !== itemsContainer.scrollTop) {\n        itemsContainer.scrollTop = scrollTop;\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var theme = this.theme;\n      var _props3 = this.props,\n          id = _props3.id,\n          multiSection = _props3.multiSection,\n          renderInputComponent = _props3.renderInputComponent,\n          renderItemsContainer = _props3.renderItemsContainer,\n          highlightedSectionIndex = _props3.highlightedSectionIndex,\n          highlightedItemIndex = _props3.highlightedItemIndex;\n      var isInputFocused = this.state.isInputFocused;\n      var renderedItems = multiSection ? this.renderSections() : this.renderItems();\n      var isOpen = renderedItems !== null;\n      var ariaActivedescendant = this.getItemId(highlightedSectionIndex, highlightedItemIndex);\n      var itemsContainerId = 'react-autowhatever-' + id;\n\n      var containerProps = _extends({\n        role: 'combobox',\n        'aria-haspopup': 'listbox',\n        'aria-owns': itemsContainerId,\n        'aria-expanded': isOpen\n      }, theme('react-autowhatever-' + id + '-container', 'container', isOpen && 'containerOpen'), this.props.containerProps);\n\n      var inputComponent = renderInputComponent(_extends({\n        type: 'text',\n        value: '',\n        autoComplete: 'off',\n        'aria-autocomplete': 'list',\n        'aria-controls': itemsContainerId,\n        'aria-activedescendant': ariaActivedescendant\n      }, theme('react-autowhatever-' + id + '-input', 'input', isOpen && 'inputOpen', isInputFocused && 'inputFocused'), this.props.inputProps, {\n        onFocus: this.onFocus,\n        onBlur: this.onBlur,\n        onKeyDown: this.props.inputProps.onKeyDown && this.onKeyDown,\n        ref: this.storeInputReference\n      }));\n      var itemsContainer = renderItemsContainer({\n        containerProps: _extends({\n          id: itemsContainerId,\n          role: 'listbox'\n        }, theme('react-autowhatever-' + id + '-items-container', 'itemsContainer', isOpen && 'itemsContainerOpen'), {\n          ref: this.storeItemsContainerReference\n        }),\n        children: renderedItems\n      });\n      return _react2.default.createElement('div', containerProps, inputComponent, itemsContainer);\n    }\n  }]);\n\n  return Autowhatever;\n}(_react.Component);\n\nAutowhatever.propTypes = {\n  id: _propTypes2.default.string,\n  // Used in aria-* attributes. If multiple Autowhatever's are rendered on a page, they must have unique ids.\n  multiSection: _propTypes2.default.bool,\n  // Indicates whether a multi section layout should be rendered.\n  renderInputComponent: _propTypes2.default.func,\n  // When specified, it is used to render the input element.\n  renderItemsContainer: _propTypes2.default.func,\n  // Renders the items container.\n  items: _propTypes2.default.array.isRequired,\n  // Array of items or sections to render.\n  renderItem: _propTypes2.default.func,\n  // This function renders a single item.\n  renderItemData: _propTypes2.default.object,\n  // Arbitrary data that will be passed to renderItem()\n  renderSectionTitle: _propTypes2.default.func,\n  // This function gets a section and renders its title.\n  getSectionItems: _propTypes2.default.func,\n  // This function gets a section and returns its items, which will be passed into `renderItem` for rendering.\n  containerProps: _propTypes2.default.object,\n  // Arbitrary container props\n  inputProps: _propTypes2.default.object,\n  // Arbitrary input props\n  itemProps: _propTypes2.default.oneOfType([// Arbitrary item props\n  _propTypes2.default.object, _propTypes2.default.func]),\n  highlightedSectionIndex: _propTypes2.default.number,\n  // Section index of the highlighted item\n  highlightedItemIndex: _propTypes2.default.number,\n  // Highlighted item index (within a section)\n  theme: _propTypes2.default.oneOfType([// Styles. See: https://github.com/markdalgleish/react-themeable\n  _propTypes2.default.object, _propTypes2.default.array])\n};\nAutowhatever.defaultProps = {\n  id: '1',\n  multiSection: false,\n  renderInputComponent: defaultRenderInputComponent,\n  renderItemsContainer: defaultRenderItemsContainer,\n  renderItem: function renderItem() {\n    throw new Error('`renderItem` must be provided');\n  },\n  renderItemData: emptyObject,\n  renderSectionTitle: function renderSectionTitle() {\n    throw new Error('`renderSectionTitle` must be provided');\n  },\n  getSectionItems: function getSectionItems() {\n    throw new Error('`getSectionItems` must be provided');\n  },\n  containerProps: emptyObject,\n  inputProps: emptyObject,\n  itemProps: emptyObject,\n  highlightedSectionIndex: null,\n  highlightedItemIndex: null,\n  theme: defaultTheme\n};\nexports.default = Autowhatever;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/Autowhatever.js?")},"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/Item.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/react-autosuggest/node_modules/prop-types/index.js");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _compareObjects = __webpack_require__(/*! ./compareObjects */ "./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/compareObjects.js");\n\nvar _compareObjects2 = _interopRequireDefault(_compareObjects);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar Item = function (_Component) {\n  _inherits(Item, _Component);\n\n  function Item() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Item);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Item.__proto__ || Object.getPrototypeOf(Item)).call.apply(_ref, [this].concat(args))), _this), _this.storeItemReference = function (item) {\n      if (item !== null) {\n        _this.item = item;\n      }\n    }, _this.onMouseEnter = function (event) {\n      var _this$props = _this.props,\n          sectionIndex = _this$props.sectionIndex,\n          itemIndex = _this$props.itemIndex;\n\n      _this.props.onMouseEnter(event, {\n        sectionIndex: sectionIndex,\n        itemIndex: itemIndex\n      });\n    }, _this.onMouseLeave = function (event) {\n      var _this$props2 = _this.props,\n          sectionIndex = _this$props2.sectionIndex,\n          itemIndex = _this$props2.itemIndex;\n\n      _this.props.onMouseLeave(event, {\n        sectionIndex: sectionIndex,\n        itemIndex: itemIndex\n      });\n    }, _this.onMouseDown = function (event) {\n      var _this$props3 = _this.props,\n          sectionIndex = _this$props3.sectionIndex,\n          itemIndex = _this$props3.itemIndex;\n\n      _this.props.onMouseDown(event, {\n        sectionIndex: sectionIndex,\n        itemIndex: itemIndex\n      });\n    }, _this.onClick = function (event) {\n      var _this$props4 = _this.props,\n          sectionIndex = _this$props4.sectionIndex,\n          itemIndex = _this$props4.itemIndex;\n\n      _this.props.onClick(event, {\n        sectionIndex: sectionIndex,\n        itemIndex: itemIndex\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Item, [{\n    key: \'shouldComponentUpdate\',\n    value: function shouldComponentUpdate(nextProps) {\n      return (0, _compareObjects2.default)(nextProps, this.props, [\'renderItemData\']);\n    }\n  }, {\n    key: \'render\',\n    value: function render() {\n      var _props = this.props,\n          isHighlighted = _props.isHighlighted,\n          item = _props.item,\n          renderItem = _props.renderItem,\n          renderItemData = _props.renderItemData,\n          restProps = _objectWithoutProperties(_props, [\'isHighlighted\', \'item\', \'renderItem\', \'renderItemData\']);\n\n      delete restProps.sectionIndex;\n      delete restProps.itemIndex;\n\n      if (typeof restProps.onMouseEnter === \'function\') {\n        restProps.onMouseEnter = this.onMouseEnter;\n      }\n\n      if (typeof restProps.onMouseLeave === \'function\') {\n        restProps.onMouseLeave = this.onMouseLeave;\n      }\n\n      if (typeof restProps.onMouseDown === \'function\') {\n        restProps.onMouseDown = this.onMouseDown;\n      }\n\n      if (typeof restProps.onClick === \'function\') {\n        restProps.onClick = this.onClick;\n      }\n\n      return _react2.default.createElement(\'li\', _extends({\n        role: \'option\'\n      }, restProps, {\n        ref: this.storeItemReference\n      }), renderItem(item, _extends({\n        isHighlighted: isHighlighted\n      }, renderItemData)));\n    }\n  }]);\n\n  return Item;\n}(_react.Component);\n\nItem.propTypes = {\n  sectionIndex: _propTypes2.default.number,\n  isHighlighted: _propTypes2.default.bool.isRequired,\n  itemIndex: _propTypes2.default.number.isRequired,\n  item: _propTypes2.default.any.isRequired,\n  renderItem: _propTypes2.default.func.isRequired,\n  renderItemData: _propTypes2.default.object.isRequired,\n  onMouseEnter: _propTypes2.default.func,\n  onMouseLeave: _propTypes2.default.func,\n  onMouseDown: _propTypes2.default.func,\n  onClick: _propTypes2.default.func\n};\nexports.default = Item;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/Item.js?')},"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/ItemsList.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/preact-compat/dist/preact-compat.es.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/react-autosuggest/node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _Item = __webpack_require__(/*! ./Item */ \"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/Item.js\");\n\nvar _Item2 = _interopRequireDefault(_Item);\n\nvar _compareObjects = __webpack_require__(/*! ./compareObjects */ \"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/compareObjects.js\");\n\nvar _compareObjects2 = _interopRequireDefault(_compareObjects);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ItemsList = function (_Component) {\n  _inherits(ItemsList, _Component);\n\n  function ItemsList() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ItemsList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ItemsList.__proto__ || Object.getPrototypeOf(ItemsList)).call.apply(_ref, [this].concat(args))), _this), _this.storeHighlightedItemReference = function (highlightedItem) {\n      _this.props.onHighlightedItemChange(highlightedItem === null ? null : highlightedItem.item);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(ItemsList, [{\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps) {\n      return (0, _compareObjects2.default)(nextProps, this.props, ['itemProps']);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          items = _props.items,\n          itemProps = _props.itemProps,\n          renderItem = _props.renderItem,\n          renderItemData = _props.renderItemData,\n          sectionIndex = _props.sectionIndex,\n          highlightedItemIndex = _props.highlightedItemIndex,\n          getItemId = _props.getItemId,\n          theme = _props.theme,\n          keyPrefix = _props.keyPrefix;\n      var sectionPrefix = sectionIndex === null ? keyPrefix : keyPrefix + 'section-' + sectionIndex + '-';\n      var isItemPropsFunction = typeof itemProps === 'function';\n      return _react2.default.createElement('ul', _extends({\n        role: 'listbox'\n      }, theme(sectionPrefix + 'items-list', 'itemsList')), items.map(function (item, itemIndex) {\n        var isFirst = itemIndex === 0;\n        var isHighlighted = itemIndex === highlightedItemIndex;\n        var itemKey = sectionPrefix + 'item-' + itemIndex;\n        var itemPropsObj = isItemPropsFunction ? itemProps({\n          sectionIndex: sectionIndex,\n          itemIndex: itemIndex\n        }) : itemProps;\n\n        var allItemProps = _extends({\n          id: getItemId(sectionIndex, itemIndex),\n          'aria-selected': isHighlighted\n        }, theme(itemKey, 'item', isFirst && 'itemFirst', isHighlighted && 'itemHighlighted'), itemPropsObj);\n\n        if (isHighlighted) {\n          allItemProps.ref = _this2.storeHighlightedItemReference;\n        } // `key` is provided by theme()\n\n        /* eslint-disable react/jsx-key */\n\n\n        return _react2.default.createElement(_Item2.default, _extends({}, allItemProps, {\n          sectionIndex: sectionIndex,\n          isHighlighted: isHighlighted,\n          itemIndex: itemIndex,\n          item: item,\n          renderItem: renderItem,\n          renderItemData: renderItemData\n        }));\n        /* eslint-enable react/jsx-key */\n      }));\n    }\n  }]);\n\n  return ItemsList;\n}(_react.Component);\n\nItemsList.propTypes = {\n  items: _propTypes2.default.array.isRequired,\n  itemProps: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),\n  renderItem: _propTypes2.default.func.isRequired,\n  renderItemData: _propTypes2.default.object.isRequired,\n  sectionIndex: _propTypes2.default.number,\n  highlightedItemIndex: _propTypes2.default.number,\n  onHighlightedItemChange: _propTypes2.default.func.isRequired,\n  getItemId: _propTypes2.default.func.isRequired,\n  theme: _propTypes2.default.func.isRequired,\n  keyPrefix: _propTypes2.default.string.isRequired\n};\nItemsList.defaultProps = {\n  sectionIndex: null\n};\nexports.default = ItemsList;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/ItemsList.js?")},"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/SectionTitle.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = __webpack_require__(/*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/react-autosuggest/node_modules/prop-types/index.js");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _compareObjects = __webpack_require__(/*! ./compareObjects */ "./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/compareObjects.js");\n\nvar _compareObjects2 = _interopRequireDefault(_compareObjects);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar SectionTitle = function (_Component) {\n  _inherits(SectionTitle, _Component);\n\n  function SectionTitle() {\n    _classCallCheck(this, SectionTitle);\n\n    return _possibleConstructorReturn(this, (SectionTitle.__proto__ || Object.getPrototypeOf(SectionTitle)).apply(this, arguments));\n  }\n\n  _createClass(SectionTitle, [{\n    key: \'shouldComponentUpdate\',\n    value: function shouldComponentUpdate(nextProps) {\n      return (0, _compareObjects2.default)(nextProps, this.props);\n    }\n  }, {\n    key: \'render\',\n    value: function render() {\n      var _props = this.props,\n          section = _props.section,\n          renderSectionTitle = _props.renderSectionTitle,\n          theme = _props.theme,\n          sectionKeyPrefix = _props.sectionKeyPrefix;\n      var sectionTitle = renderSectionTitle(section);\n\n      if (!sectionTitle) {\n        return null;\n      }\n\n      return _react2.default.createElement(\'div\', theme(sectionKeyPrefix + \'title\', \'sectionTitle\'), sectionTitle);\n    }\n  }]);\n\n  return SectionTitle;\n}(_react.Component);\n\nSectionTitle.propTypes = {\n  section: _propTypes2.default.any.isRequired,\n  renderSectionTitle: _propTypes2.default.func.isRequired,\n  theme: _propTypes2.default.func.isRequired,\n  sectionKeyPrefix: _propTypes2.default.string.isRequired\n};\nexports.default = SectionTitle;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/SectionTitle.js?')},"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/compareObjects.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);\n};\n\nexports.default = compareObjects;\n\nfunction compareObjects(objA, objB) {\n  var keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (objA === objB) {\n    return false;\n  }\n\n  var aKeys = Object.keys(objA);\n  var bKeys = Object.keys(objB);\n\n  if (aKeys.length !== bKeys.length) {\n    return true;\n  }\n\n  var keysMap = {};\n  var i = void 0,\n      len = void 0;\n\n  for (i = 0, len = keys.length; i < len; i++) {\n    keysMap[keys[i]] = true;\n  }\n\n  for (i = 0, len = aKeys.length; i < len; i++) {\n    var key = aKeys[i];\n    var aValue = objA[key];\n    var bValue = objB[key];\n\n    if (aValue === bValue) {\n      continue;\n    }\n\n    if (!keysMap[key] || aValue === null || bValue === null || (typeof aValue === \'undefined\' ? \'undefined\' : _typeof(aValue)) !== \'object\' || (typeof bValue === \'undefined\' ? \'undefined\' : _typeof(bValue)) !== \'object\') {\n      return true;\n    }\n\n    var aValueKeys = Object.keys(aValue);\n    var bValueKeys = Object.keys(bValue);\n\n    if (aValueKeys.length !== bValueKeys.length) {\n      return true;\n    }\n\n    for (var n = 0, length = aValueKeys.length; n < length; n++) {\n      var aValueKey = aValueKeys[n];\n\n      if (aValue[aValueKey] !== bValue[aValueKey]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/compareObjects.js?')},"./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = __webpack_require__(/*! ./Autowhatever */ "./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/Autowhatever.js").default;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-autowhatever/dist/index.js?')},"./node_modules/react-autosuggest/node_modules/react-themeable/dist/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar _objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/react-autosuggest/node_modules/react-themeable/node_modules/object-assign/index.js\");\n\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\n\nvar truthy = function truthy(x) {\n  return x;\n};\n\nexports['default'] = function (input) {\n  var _ref = Array.isArray(input) && input.length === 2 ? input : [input, null];\n\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var theme = _ref2[0];\n  var classNameDecorator = _ref2[1];\n  return function (key) {\n    for (var _len = arguments.length, names = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      names[_key - 1] = arguments[_key];\n    }\n\n    var styles = names.map(function (name) {\n      return theme[name];\n    }).filter(truthy);\n    return typeof styles[0] === 'string' || typeof classNameDecorator === 'function' ? {\n      key: key,\n      className: classNameDecorator ? classNameDecorator.apply(undefined, _toConsumableArray(styles)) : styles.join(' ')\n    } : {\n      key: key,\n      style: _objectAssign2['default'].apply(undefined, [{}].concat(_toConsumableArray(styles)))\n    };\n  };\n};\n\nmodule.exports = exports['default'];\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-themeable/dist/index.js?")},"./node_modules/react-autosuggest/node_modules/react-themeable/node_modules/object-assign/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction ToObject(val) {\n  if (val == null) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n\n  return Object(val);\n}\n\nfunction ownEnumerableKeys(obj) {\n  var keys = Object.getOwnPropertyNames(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    keys = keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys.filter(function (key) {\n    return propIsEnumerable.call(obj, key);\n  });\n}\n\nmodule.exports = Object.assign || function (target, source) {\n  var from;\n  var keys;\n  var to = ToObject(target);\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = arguments[s];\n    keys = ownEnumerableKeys(Object(from));\n\n    for (var i = 0; i < keys.length; i++) {\n      to[keys[i]] = from[keys[i]];\n    }\n  }\n\n  return to;\n};\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/react-themeable/node_modules/object-assign/index.js?")},"./node_modules/react-autosuggest/node_modules/section-iterator/dist/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"]) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  };\n}();\n\nmodule.exports = function (_ref) {\n  var data = _ref.data;\n  var multiSection = _ref.multiSection;\n\n  function nextNonEmptySectionIndex(sectionIndex) {\n    if (sectionIndex === null) {\n      sectionIndex = 0;\n    } else {\n      sectionIndex++;\n    }\n\n    while (sectionIndex < data.length && data[sectionIndex] === 0) {\n      sectionIndex++;\n    }\n\n    return sectionIndex === data.length ? null : sectionIndex;\n  }\n\n  function prevNonEmptySectionIndex(sectionIndex) {\n    if (sectionIndex === null) {\n      sectionIndex = data.length - 1;\n    } else {\n      sectionIndex--;\n    }\n\n    while (sectionIndex >= 0 && data[sectionIndex] === 0) {\n      sectionIndex--;\n    }\n\n    return sectionIndex === -1 ? null : sectionIndex;\n  }\n\n  function next(position) {\n    var _position = _slicedToArray(position, 2);\n\n    var sectionIndex = _position[0];\n    var itemIndex = _position[1];\n\n    if (multiSection) {\n      if (itemIndex === null || itemIndex === data[sectionIndex] - 1) {\n        sectionIndex = nextNonEmptySectionIndex(sectionIndex);\n\n        if (sectionIndex === null) {\n          return [null, null];\n        }\n\n        return [sectionIndex, 0];\n      }\n\n      return [sectionIndex, itemIndex + 1];\n    }\n\n    if (data === 0 || itemIndex === data - 1) {\n      return [null, null];\n    }\n\n    if (itemIndex === null) {\n      return [null, 0];\n    }\n\n    return [null, itemIndex + 1];\n  }\n\n  function prev(position) {\n    var _position2 = _slicedToArray(position, 2);\n\n    var sectionIndex = _position2[0];\n    var itemIndex = _position2[1];\n\n    if (multiSection) {\n      if (itemIndex === null || itemIndex === 0) {\n        sectionIndex = prevNonEmptySectionIndex(sectionIndex);\n\n        if (sectionIndex === null) {\n          return [null, null];\n        }\n\n        return [sectionIndex, data[sectionIndex] - 1];\n      }\n\n      return [sectionIndex, itemIndex - 1];\n    }\n\n    if (data === 0 || itemIndex === 0) {\n      return [null, null];\n    }\n\n    if (itemIndex === null) {\n      return [null, data - 1];\n    }\n\n    return [null, itemIndex - 1];\n  }\n\n  function isLast(position) {\n    return next(position)[1] === null;\n  }\n\n  return {\n    next: next,\n    prev: prev,\n    isLast: isLast\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/section-iterator/dist/index.js?')},"./node_modules/react-autosuggest/node_modules/shallow-equal/arrays/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction shallowEqualArrays(arrA, arrB) {\n  if (arrA === arrB) {\n    return true;\n  }\n\n  if (!arrA || !arrB) {\n    return false;\n  }\n\n  var len = arrA.length;\n\n  if (arrB.length !== len) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (arrA[i] !== arrB[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqualArrays;\n\n//# sourceURL=webpack:///./node_modules/react-autosuggest/node_modules/shallow-equal/arrays/index.js?")},"./node_modules/react-html-parser/lib/HtmlParser.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = HtmlParser;\n\nvar _htmlparser = __webpack_require__(/*! htmlparser2 */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js");\n\nvar _htmlparser2 = _interopRequireDefault(_htmlparser);\n\nvar _processNodes = __webpack_require__(/*! ./processNodes */ "./node_modules/react-html-parser/lib/processNodes.js");\n\nvar _processNodes2 = _interopRequireDefault(_processNodes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Parses a HTML string and returns a list of React components generated from it\n *\n * @param {String} html The HTML to convert into React component\n * @param {Object} options Options to pass\n * @returns {Array} List of top level React elements\n */\n\n\nfunction HtmlParser(html) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$decodeEntities = _ref.decodeEntities,\n      decodeEntities = _ref$decodeEntities === undefined ? true : _ref$decodeEntities,\n      transform = _ref.transform,\n      _ref$preprocessNodes = _ref.preprocessNodes,\n      preprocessNodes = _ref$preprocessNodes === undefined ? function (nodes) {\n    return nodes;\n  } : _ref$preprocessNodes;\n\n  var nodes = preprocessNodes(_htmlparser2.default.parseDOM(html, {\n    decodeEntities: decodeEntities\n  }));\n  return (0, _processNodes2.default)(nodes, transform);\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/HtmlParser.js?')},"./node_modules/react-html-parser/lib/convertNodeToElement.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = convertNodeToElement;\n\nvar _elementTypes = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-html-parser/lib/elementTypes/index.js");\n\nvar _elementTypes2 = _interopRequireDefault(_elementTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Converts a htmlparser2 node to a React element\n *\n * @param {Object} node The htmlparser2 node to convert\n * @param {Number} index The index of the current node\n * @param {Function} transform Transform function to apply to children of the node\n * @returns {React.Element}\n */\n\n\nfunction convertNodeToElement(node, index, transform) {\n  return _elementTypes2.default[node.type](node, index, transform);\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/convertNodeToElement.js?')},"./node_modules/react-html-parser/lib/dom/attributes/BooleanAttributes.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * List of boolean attributes\n * These attributes should have their React attribute value set to be the same as their name\n * E.g. <input disabled> = <input disabled>\n *      <input disabled=\"\"> = <input disabled>\n *      <input disabled=\"disabled\"> = <input disabled>\n * @type {Array}\n */\n\nexports.default = ['allowfullScreen', 'async', 'autoplay', 'capture', 'checked', 'controls', 'default', 'defer', 'disabled', 'formnovalidate', 'hidden', 'loop', 'multiple', 'muted', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'itemscope'];\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/dom/attributes/BooleanAttributes.js?")},"./node_modules/react-html-parser/lib/dom/attributes/ReactAttributes.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Mapping of standard HTML attributes to their React counterparts\n * List taken and reversed from react/src/renderers/dom/shared/HTMLDOMPropertyConfig.js\n * https://github.com/facebook/react/blob/c9c3c339b757682f1154f1c915eb55e6a8766933/src/renderers/dom/shared/HTMLDOMPropertyConfig.js\n * @type {Object}\n */\n\nexports.default = {\n  /**\n   * Standard Properties\n   */\n  accept: 'accept',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocomplete: 'autoComplete',\n  autoplay: 'autoPlay',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  challenge: 'challenge',\n  checked: 'checked',\n  cite: 'cite',\n  classid: 'classID',\n  class: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlsList: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  data: 'data',\n  datetime: 'dateTime',\n  default: 'default',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  form: 'form',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  for: 'htmlFor',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  slot: 'slot',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  /**\n   * RDFa Properties\n   */\n  about: 'about',\n  datatype: 'datatype',\n  inlist: 'inlist',\n  prefix: 'prefix',\n  property: 'property',\n  resource: 'resource',\n  typeof: 'typeof',\n  vocab: 'vocab',\n\n  /**\n   * Non-standard Properties\n   */\n  autocapitalize: 'autoCapitalize',\n  autocorrect: 'autoCorrect',\n  autosave: 'autoSave',\n  color: 'color',\n  itemprop: 'itemProp',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  itemid: 'itemID',\n  itemref: 'itemRef',\n  results: 'results',\n  security: 'security',\n  unselectable: 'unselectable'\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/dom/attributes/ReactAttributes.js?")},"./node_modules/react-html-parser/lib/dom/elements/VoidElements.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * List of void elements\n * These elements are not allowed to have children\n * @type {Array}\n */\n\nexports.default = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/dom/elements/VoidElements.js?")},"./node_modules/react-html-parser/lib/elementTypes/StyleElementType.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = StyleElementType;\n\nvar _react = __webpack_require__(/*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _generatePropsFromAttributes = __webpack_require__(/*! ../utils/generatePropsFromAttributes */ "./node_modules/react-html-parser/lib/utils/generatePropsFromAttributes.js");\n\nvar _generatePropsFromAttributes2 = _interopRequireDefault(_generatePropsFromAttributes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Converts a <style> element to a React element\n *\n * @param {Object} node The style node\n * @param {String} index The index of the React element relative to it\'s parent\n * @returns {React.Element} The React style element\n */\n\n\nfunction StyleElementType(node, index) {\n  // The style element only ever has a single child which is the styles so try and find this to add as\n  // a child to the style element that will be created\n  var styles = void 0;\n\n  if (node.children.length > 0) {\n    styles = node.children[0].data;\n  } // generate props\n\n\n  var props = (0, _generatePropsFromAttributes2.default)(node.attribs, index); // create and return the element\n\n  return _react2.default.createElement(\'style\', props, styles);\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/elementTypes/StyleElementType.js?')},"./node_modules/react-html-parser/lib/elementTypes/TagElementType.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = TagElementType;\n\nvar _react = __webpack_require__(/*! react */ "./node_modules/preact-compat/dist/preact-compat.es.js");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _processNodes = __webpack_require__(/*! ../processNodes */ "./node_modules/react-html-parser/lib/processNodes.js");\n\nvar _processNodes2 = _interopRequireDefault(_processNodes);\n\nvar _generatePropsFromAttributes = __webpack_require__(/*! ../utils/generatePropsFromAttributes */ "./node_modules/react-html-parser/lib/utils/generatePropsFromAttributes.js");\n\nvar _generatePropsFromAttributes2 = _interopRequireDefault(_generatePropsFromAttributes);\n\nvar _VoidElements = __webpack_require__(/*! ../dom/elements/VoidElements */ "./node_modules/react-html-parser/lib/dom/elements/VoidElements.js");\n\nvar _VoidElements2 = _interopRequireDefault(_VoidElements);\n\nvar _isValidTagOrAttributeName = __webpack_require__(/*! ../utils/isValidTagOrAttributeName */ "./node_modules/react-html-parser/lib/utils/isValidTagOrAttributeName.js");\n\nvar _isValidTagOrAttributeName2 = _interopRequireDefault(_isValidTagOrAttributeName);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Converts any element (excluding style - see StyleElementType - and script) to a react element.\n *\n * @param {Object} node The tag node\n * @param {String} index The index of the React element relative to it\'s parent\n * @param {Function} transform The transform function to apply to all children\n * @returns {React.Element} The React tag element\n */\n\n\nfunction TagElementType(node, index, transform) {\n  var tagName = node.name; // validate tag name\n\n  if (!(0, _isValidTagOrAttributeName2.default)(tagName)) {\n    return null;\n  } // generate props\n\n\n  var props = (0, _generatePropsFromAttributes2.default)(node.attribs, index); // If the node is not a void element and has children then process them\n\n  var children = null;\n\n  if (_VoidElements2.default.indexOf(tagName) === -1) {\n    children = (0, _processNodes2.default)(node.children, transform);\n  } // create and return the element\n\n\n  return _react2.default.createElement(tagName, props, children);\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/elementTypes/TagElementType.js?')},"./node_modules/react-html-parser/lib/elementTypes/TextElementType.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = TextElementType;\n/**\n * Converts a text node to a React text element\n *\n * @param {Object} node The text node\n * @returns {String} The text\n */\n\nfunction TextElementType(node) {\n  // React will accept plain text for rendering so just return the node data\n  return node.data;\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/elementTypes/TextElementType.js?')},"./node_modules/react-html-parser/lib/elementTypes/UnsupportedElementType.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = UnsupportedElementType;\n/**\n * Handles an unsupported element type by returning null so nothing is rendered\n * @returns {null}\n */\n\nfunction UnsupportedElementType() {\n  // do nothing because the element type is unsupported\n  // comment, directive, script, cdata, doctype are all currently unsupported\n  return null;\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/elementTypes/UnsupportedElementType.js?')},"./node_modules/react-html-parser/lib/elementTypes/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _ElementType$Text$Ele;\n\nvar _htmlparser = __webpack_require__(/*! htmlparser2 */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js");\n\nvar _TextElementType = __webpack_require__(/*! ./TextElementType */ "./node_modules/react-html-parser/lib/elementTypes/TextElementType.js");\n\nvar _TextElementType2 = _interopRequireDefault(_TextElementType);\n\nvar _TagElementType = __webpack_require__(/*! ./TagElementType */ "./node_modules/react-html-parser/lib/elementTypes/TagElementType.js");\n\nvar _TagElementType2 = _interopRequireDefault(_TagElementType);\n\nvar _StyleElementType = __webpack_require__(/*! ./StyleElementType */ "./node_modules/react-html-parser/lib/elementTypes/StyleElementType.js");\n\nvar _StyleElementType2 = _interopRequireDefault(_StyleElementType);\n\nvar _UnsupportedElementType = __webpack_require__(/*! ./UnsupportedElementType */ "./node_modules/react-html-parser/lib/elementTypes/UnsupportedElementType.js");\n\nvar _UnsupportedElementType2 = _interopRequireDefault(_UnsupportedElementType);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\n * Map each htmlparser2 element type to a function which will convert that element type to a React element\n * Not all of the element types are supported so the UnsupportedElementType is used for them which will not return any\n * value\n */\n\n\nexports.default = (_ElementType$Text$Ele = {}, _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Text, _TextElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Tag, _TagElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Style, _StyleElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Directive, _UnsupportedElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Comment, _UnsupportedElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Script, _UnsupportedElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.CDATA, _UnsupportedElementType2.default), _defineProperty(_ElementType$Text$Ele, _htmlparser.ElementType.Doctype, _UnsupportedElementType2.default), _ElementType$Text$Ele);\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/elementTypes/index.js?')},"./node_modules/react-html-parser/lib/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.htmlparser2 = exports.convertNodeToElement = exports.processNodes = undefined;\n\nvar _processNodes = __webpack_require__(/*! ./processNodes */ "./node_modules/react-html-parser/lib/processNodes.js");\n\nObject.defineProperty(exports, \'processNodes\', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_processNodes).default;\n  }\n});\n\nvar _convertNodeToElement = __webpack_require__(/*! ./convertNodeToElement */ "./node_modules/react-html-parser/lib/convertNodeToElement.js");\n\nObject.defineProperty(exports, \'convertNodeToElement\', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_convertNodeToElement).default;\n  }\n});\n\nvar _htmlparser = __webpack_require__(/*! htmlparser2 */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js");\n\nObject.defineProperty(exports, \'htmlparser2\', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_htmlparser).default;\n  }\n});\n\nvar _HtmlParser = __webpack_require__(/*! ./HtmlParser */ "./node_modules/react-html-parser/lib/HtmlParser.js");\n\nvar _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nexports.default = _HtmlParser2.default;\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/index.js?')},"./node_modules/react-html-parser/lib/processNodes.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = processNodes;\n\nvar _isEmptyTextNode = __webpack_require__(/*! ./utils/isEmptyTextNode */ "./node_modules/react-html-parser/lib/utils/isEmptyTextNode.js");\n\nvar _isEmptyTextNode2 = _interopRequireDefault(_isEmptyTextNode);\n\nvar _convertNodeToElement = __webpack_require__(/*! ./convertNodeToElement */ "./node_modules/react-html-parser/lib/convertNodeToElement.js");\n\nvar _convertNodeToElement2 = _interopRequireDefault(_convertNodeToElement);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Processes the nodes generated by htmlparser2 and convert them all into React elements\n *\n * @param {Object[]} nodes List of nodes to process\n * @param {Function} transform Transform function to optionally apply to nodes\n * @returns {React.Element[]} The list of processed React elements\n */\n\n\nfunction processNodes(nodes, transform) {\n  return nodes.filter(function (node) {\n    return !(0, _isEmptyTextNode2.default)(node);\n  }).map(function (node, index) {\n    // return the result of the transform function if applicable\n    var transformed = void 0;\n\n    if (typeof transform === \'function\') {\n      transformed = transform(node, index);\n\n      if (transformed === null || !!transformed) {\n        return transformed;\n      }\n    } // otherwise convert the node as standard\n\n\n    return (0, _convertNodeToElement2.default)(node, index, transform);\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/processNodes.js?')},"./node_modules/react-html-parser/lib/utils/generatePropsFromAttributes.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = generatePropsFromAttributes;\n\nvar _htmlAttributesToReact = __webpack_require__(/*! ./htmlAttributesToReact */ "./node_modules/react-html-parser/lib/utils/htmlAttributesToReact.js");\n\nvar _htmlAttributesToReact2 = _interopRequireDefault(_htmlAttributesToReact);\n\nvar _inlineStyleToObject = __webpack_require__(/*! ./inlineStyleToObject */ "./node_modules/react-html-parser/lib/utils/inlineStyleToObject.js");\n\nvar _inlineStyleToObject2 = _interopRequireDefault(_inlineStyleToObject);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Generates props for a React element from an object of HTML attributes\n *\n * @param {Object} attributes The HTML attributes\n * @param {String} key The key to give the react element\n */\n\n\nfunction generatePropsFromAttributes(attributes, key) {\n  // generate props\n  var props = _extends({}, (0, _htmlAttributesToReact2.default)(attributes), {\n    key: key\n  }); // if there is an inline/string style prop then convert it to a React style object\n  // otherwise, it is invalid and omitted\n\n\n  if (typeof props.style === \'string\' || props.style instanceof String) {\n    props.style = (0, _inlineStyleToObject2.default)(props.style);\n  } else {\n    delete props.style;\n  }\n\n  return props;\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/utils/generatePropsFromAttributes.js?')},"./node_modules/react-html-parser/lib/utils/htmlAttributesToReact.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = htmlAttributesToReact;\n\nvar _BooleanAttributes = __webpack_require__(/*! ../dom/attributes/BooleanAttributes */ "./node_modules/react-html-parser/lib/dom/attributes/BooleanAttributes.js");\n\nvar _BooleanAttributes2 = _interopRequireDefault(_BooleanAttributes);\n\nvar _ReactAttributes = __webpack_require__(/*! ../dom/attributes/ReactAttributes */ "./node_modules/react-html-parser/lib/dom/attributes/ReactAttributes.js");\n\nvar _ReactAttributes2 = _interopRequireDefault(_ReactAttributes);\n\nvar _isValidTagOrAttributeName = __webpack_require__(/*! ./isValidTagOrAttributeName */ "./node_modules/react-html-parser/lib/utils/isValidTagOrAttributeName.js");\n\nvar _isValidTagOrAttributeName2 = _interopRequireDefault(_isValidTagOrAttributeName);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Returns the parsed attribute value taking into account things like boolean attributes\n *\n * @param {String} attribute The name of the attribute\n * @param {*} value The value of the attribute from the HTML\n * @returns {*} The parsed attribute value\n */\n\n\nvar getParsedAttributeValue = function getParsedAttributeValue(attribute, value) {\n  // if the attribute if a boolean then it\'s value should be the same as it\'s name\n  // e.g. disabled="disabled"\n  var lowerBooleanAttributes = _BooleanAttributes2.default.map(function (attr) {\n    return attr.toLowerCase();\n  });\n\n  if (lowerBooleanAttributes.indexOf(attribute.toLowerCase()) >= 0) {\n    value = attribute;\n  }\n\n  return value;\n};\n/**\n * Takes an object of standard HTML property names and converts them to their React counterpart. If the react\n * version does not exist for an attribute then just use it as it is\n *\n * @param {Object} attributes The HTML attributes to convert\n * @returns {Object} The React attributes\n */\n\n\nfunction htmlAttributesToReact(attributes) {\n  return Object.keys(attributes).filter(function (attr) {\n    return (0, _isValidTagOrAttributeName2.default)(attr);\n  }).reduce(function (mappedAttributes, attribute) {\n    // lowercase the attribute name and find it in the react attribute map\n    var lowerCaseAttribute = attribute.toLowerCase(); // format the attribute name\n\n    var name = _ReactAttributes2.default[lowerCaseAttribute] || lowerCaseAttribute; // add the parsed attribute value to the mapped attributes\n\n    mappedAttributes[name] = getParsedAttributeValue(name, attributes[attribute]);\n    return mappedAttributes;\n  }, {});\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/utils/htmlAttributesToReact.js?')},"./node_modules/react-html-parser/lib/utils/inlineStyleToObject.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.default = InlineStyleToObject;\n/**\n * Converts an inline style string into an object of React style properties\n *\n * @param {String} inlineStyle='' The inline style to convert\n * @returns {Object} The converted style\n */\n\nfunction InlineStyleToObject() {\n  var inlineStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; // just return empty object if the inlineStyle is empty\n\n  if (inlineStyle === '') {\n    return {};\n  }\n\n  return inlineStyle.split(';').reduce(function (styleObject, stylePropertyValue) {\n    // extract the style property name and value\n    var _stylePropertyValue$s = stylePropertyValue.split(/^([^:]+):/).filter(function (val, i) {\n      return i > 0;\n    }).map(function (item) {\n      return item.trim().toLowerCase();\n    }),\n        _stylePropertyValue$s2 = _slicedToArray(_stylePropertyValue$s, 2),\n        property = _stylePropertyValue$s2[0],\n        value = _stylePropertyValue$s2[1]; // if there is no value (i.e. no : in the style) then ignore it\n\n\n    if (value === undefined) {\n      return styleObject;\n    } // convert the property name into the correct React format\n    // remove all hyphens and convert the letter immediately after each hyphen to upper case\n    // additionally don't uppercase any -ms- prefix\n    // e.g. -ms-style-property = msStyleProperty\n    //      -webkit-style-property = WebkitStyleProperty\n\n\n    property = property.replace(/^-ms-/, 'ms-').replace(/-(.)/g, function (_, character) {\n      return character.toUpperCase();\n    }); // add the new style property and value to the style object\n\n    styleObject[property] = value;\n    return styleObject;\n  }, {});\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/utils/inlineStyleToObject.js?")},"./node_modules/react-html-parser/lib/utils/isEmptyTextNode.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isEmptyTextNode;\n/**\n * Tests a htmlparser2 node and returns whether is it a text node at the start and end of the line containing only\n * white space. This allows these node types to be excluded from the rendering because they are unnecessary.\n *\n * @param {Object} node The element object as created by htmlparser2\n * @returns {boolean} Whether the node is an empty text node\n */\n\nfunction isEmptyTextNode(node) {\n  return node.type === 'text' && /\\r?\\n/.test(node.data) && node.data.trim() === '';\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/utils/isEmptyTextNode.js?")},"./node_modules/react-html-parser/lib/utils/isValidTagOrAttributeName.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = isValidTagOrAttributeName;\nvar VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/;\nvar nameCache = {};\n\nfunction isValidTagOrAttributeName(tagName) {\n  if (!nameCache.hasOwnProperty(tagName)) {\n    nameCache[tagName] = VALID_TAG_REGEX.test(tagName);\n  }\n\n  return nameCache[tagName];\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/lib/utils/isValidTagOrAttributeName.js?')},"./node_modules/react-html-parser/node_modules/dom-serializer/index.js":function(module,exports,__webpack_require__){eval("/*\n  Module dependencies\n*/\nvar ElementType = __webpack_require__(/*! domelementtype */ \"./node_modules/react-html-parser/node_modules/domelementtype/index.js\");\n\nvar entities = __webpack_require__(/*! entities */ \"./node_modules/react-html-parser/node_modules/entities/index.js\");\n\nvar unencodedElements = {\n  __proto__: null,\n  style: true,\n  script: true,\n  xmp: true,\n  iframe: true,\n  noembed: true,\n  noframes: true,\n  plaintext: true,\n  noscript: true\n};\n/*\n  Format attributes\n*/\n\nfunction formatAttrs(attributes, opts) {\n  if (!attributes) return;\n  var output = '',\n      value; // Loop through the attributes\n\n  for (var key in attributes) {\n    value = attributes[key];\n\n    if (output) {\n      output += ' ';\n    }\n\n    output += key;\n\n    if (value !== null && value !== '' || opts.xmlMode) {\n      output += '=\"' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '\"';\n    }\n  }\n\n  return output;\n}\n/*\n  Self-enclosing tags (stolen from node-htmlparser)\n*/\n\n\nvar singleTag = {\n  __proto__: null,\n  area: true,\n  base: true,\n  basefont: true,\n  br: true,\n  col: true,\n  command: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  isindex: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nvar render = module.exports = function (dom, opts) {\n  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];\n  opts = opts || {};\n  var output = '';\n\n  for (var i = 0; i < dom.length; i++) {\n    var elem = dom[i];\n    if (elem.type === 'root') output += render(elem.children, opts);else if (ElementType.isTag(elem)) output += renderTag(elem, opts);else if (elem.type === ElementType.Directive) output += renderDirective(elem);else if (elem.type === ElementType.Comment) output += renderComment(elem);else if (elem.type === ElementType.CDATA) output += renderCdata(elem);else output += renderText(elem, opts);\n  }\n\n  return output;\n};\n\nfunction renderTag(elem, opts) {\n  // Handle SVG\n  if (elem.name === \"svg\") opts = {\n    decodeEntities: opts.decodeEntities,\n    xmlMode: true\n  };\n  var tag = '<' + elem.name,\n      attribs = formatAttrs(elem.attribs, opts);\n\n  if (attribs) {\n    tag += ' ' + attribs;\n  }\n\n  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {\n    tag += '/>';\n  } else {\n    tag += '>';\n\n    if (elem.children) {\n      tag += render(elem.children, opts);\n    }\n\n    if (!singleTag[elem.name] || opts.xmlMode) {\n      tag += '</' + elem.name + '>';\n    }\n  }\n\n  return tag;\n}\n\nfunction renderDirective(elem) {\n  return '<' + elem.data + '>';\n}\n\nfunction renderText(elem, opts) {\n  var data = elem.data || ''; // if entities weren't decoded, no need to encode them back\n\n  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {\n    data = entities.encodeXML(data);\n  }\n\n  return data;\n}\n\nfunction renderCdata(elem) {\n  return '<![CDATA[' + elem.children[0].data + ']]>';\n}\n\nfunction renderComment(elem) {\n  return '\x3c!--' + elem.data + '--\x3e';\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/dom-serializer/index.js?")},"./node_modules/react-html-parser/node_modules/domelementtype/index.js":function(module,exports){eval('//Types of elements found in the DOM\nmodule.exports = {\n  Text: "text",\n  //Text\n  Directive: "directive",\n  //<? ... ?>\n  Comment: "comment",\n  //\x3c!-- ... --\x3e\n  Script: "script",\n  //<script> tags\n  Style: "style",\n  //<style> tags\n  Tag: "tag",\n  //Any tag\n  CDATA: "cdata",\n  //<![CDATA[ ... ]]>\n  Doctype: "doctype",\n  isTag: function isTag(elem) {\n    return elem.type === "tag" || elem.type === "script" || elem.type === "style";\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domelementtype/index.js?')},"./node_modules/react-html-parser/node_modules/domhandler/index.js":function(module,exports,__webpack_require__){eval('function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/react-html-parser/node_modules/domelementtype/index.js");\n\nvar re_whitespace = /\\s+/g;\n\nvar NodePrototype = __webpack_require__(/*! ./lib/node */ "./node_modules/react-html-parser/node_modules/domhandler/lib/node.js");\n\nvar ElementPrototype = __webpack_require__(/*! ./lib/element */ "./node_modules/react-html-parser/node_modules/domhandler/lib/element.js");\n\nfunction DomHandler(callback, options, elementCB) {\n  if (_typeof(callback) === "object") {\n    elementCB = options;\n    options = callback;\n    callback = null;\n  } else if (typeof options === "function") {\n    elementCB = options;\n    options = defaultOpts;\n  }\n\n  this._callback = callback;\n  this._options = options || defaultOpts;\n  this._elementCB = elementCB;\n  this.dom = [];\n  this._done = false;\n  this._tagStack = [];\n  this._parser = this._parser || null;\n} //default options\n\n\nvar defaultOpts = {\n  normalizeWhitespace: false,\n  //Replace all whitespace with single spaces\n  withStartIndices: false,\n  //Add startIndex properties to nodes\n  withEndIndices: false //Add endIndex properties to nodes\n\n};\n\nDomHandler.prototype.onparserinit = function (parser) {\n  this._parser = parser;\n}; //Resets the handler back to starting state\n\n\nDomHandler.prototype.onreset = function () {\n  DomHandler.call(this, this._callback, this._options, this._elementCB);\n}; //Signals the handler that parsing is done\n\n\nDomHandler.prototype.onend = function () {\n  if (this._done) return;\n  this._done = true;\n  this._parser = null;\n\n  this._handleCallback(null);\n};\n\nDomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function (error) {\n  if (typeof this._callback === "function") {\n    this._callback(error, this.dom);\n  } else {\n    if (error) throw error;\n  }\n};\n\nDomHandler.prototype.onclosetag = function () {\n  //if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn\'t match!"));\n  var elem = this._tagStack.pop();\n\n  if (this._options.withEndIndices && elem) {\n    elem.endIndex = this._parser.endIndex;\n  }\n\n  if (this._elementCB) this._elementCB(elem);\n};\n\nDomHandler.prototype._createDomElement = function (properties) {\n  if (!this._options.withDomLvl1) return properties;\n  var element;\n\n  if (properties.type === "tag") {\n    element = Object.create(ElementPrototype);\n  } else {\n    element = Object.create(NodePrototype);\n  }\n\n  for (var key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      element[key] = properties[key];\n    }\n  }\n\n  return element;\n};\n\nDomHandler.prototype._addDomElement = function (element) {\n  var parent = this._tagStack[this._tagStack.length - 1];\n  var siblings = parent ? parent.children : this.dom;\n  var previousSibling = siblings[siblings.length - 1];\n  element.next = null;\n\n  if (this._options.withStartIndices) {\n    element.startIndex = this._parser.startIndex;\n  }\n\n  if (this._options.withEndIndices) {\n    element.endIndex = this._parser.endIndex;\n  }\n\n  if (previousSibling) {\n    element.prev = previousSibling;\n    previousSibling.next = element;\n  } else {\n    element.prev = null;\n  }\n\n  siblings.push(element);\n  element.parent = parent || null;\n};\n\nDomHandler.prototype.onopentag = function (name, attribs) {\n  var properties = {\n    type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,\n    name: name,\n    attribs: attribs,\n    children: []\n  };\n\n  var element = this._createDomElement(properties);\n\n  this._addDomElement(element);\n\n  this._tagStack.push(element);\n};\n\nDomHandler.prototype.ontext = function (data) {\n  //the ignoreWhitespace is officially dropped, but for now,\n  //it\'s an alias for normalizeWhitespace\n  var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;\n  var lastTag;\n\n  if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {\n    if (normalize) {\n      lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");\n    } else {\n      lastTag.data += data;\n    }\n  } else {\n    if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {\n      if (normalize) {\n        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");\n      } else {\n        lastTag.data += data;\n      }\n    } else {\n      if (normalize) {\n        data = data.replace(re_whitespace, " ");\n      }\n\n      var element = this._createDomElement({\n        data: data,\n        type: ElementType.Text\n      });\n\n      this._addDomElement(element);\n    }\n  }\n};\n\nDomHandler.prototype.oncomment = function (data) {\n  var lastTag = this._tagStack[this._tagStack.length - 1];\n\n  if (lastTag && lastTag.type === ElementType.Comment) {\n    lastTag.data += data;\n    return;\n  }\n\n  var properties = {\n    data: data,\n    type: ElementType.Comment\n  };\n\n  var element = this._createDomElement(properties);\n\n  this._addDomElement(element);\n\n  this._tagStack.push(element);\n};\n\nDomHandler.prototype.oncdatastart = function () {\n  var properties = {\n    children: [{\n      data: "",\n      type: ElementType.Text\n    }],\n    type: ElementType.CDATA\n  };\n\n  var element = this._createDomElement(properties);\n\n  this._addDomElement(element);\n\n  this._tagStack.push(element);\n};\n\nDomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function () {\n  this._tagStack.pop();\n};\n\nDomHandler.prototype.onprocessinginstruction = function (name, data) {\n  var element = this._createDomElement({\n    name: name,\n    data: data,\n    type: ElementType.Directive\n  });\n\n  this._addDomElement(element);\n};\n\nmodule.exports = DomHandler;\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domhandler/index.js?')},"./node_modules/react-html-parser/node_modules/domhandler/lib/element.js":function(module,exports,__webpack_require__){eval('// DOM-Level-1-compliant structure\nvar NodePrototype = __webpack_require__(/*! ./node */ "./node_modules/react-html-parser/node_modules/domhandler/lib/node.js");\n\nvar ElementPrototype = module.exports = Object.create(NodePrototype);\nvar domLvl1 = {\n  tagName: "name"\n};\nObject.keys(domLvl1).forEach(function (key) {\n  var shorthand = domLvl1[key];\n  Object.defineProperty(ElementPrototype, key, {\n    get: function get() {\n      return this[shorthand] || null;\n    },\n    set: function set(val) {\n      this[shorthand] = val;\n      return val;\n    }\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domhandler/lib/element.js?')},"./node_modules/react-html-parser/node_modules/domhandler/lib/node.js":function(module,exports){eval('// This object will be used as the prototype for Nodes when creating a\n// DOM-Level-1-compliant structure.\nvar NodePrototype = module.exports = {\n  get firstChild() {\n    var children = this.children;\n    return children && children[0] || null;\n  },\n\n  get lastChild() {\n    var children = this.children;\n    return children && children[children.length - 1] || null;\n  },\n\n  get nodeType() {\n    return nodeTypes[this.type] || nodeTypes.element;\n  }\n\n};\nvar domLvl1 = {\n  tagName: "name",\n  childNodes: "children",\n  parentNode: "parent",\n  previousSibling: "prev",\n  nextSibling: "next",\n  nodeValue: "data"\n};\nvar nodeTypes = {\n  element: 1,\n  text: 3,\n  cdata: 4,\n  comment: 8\n};\nObject.keys(domLvl1).forEach(function (key) {\n  var shorthand = domLvl1[key];\n  Object.defineProperty(NodePrototype, key, {\n    get: function get() {\n      return this[shorthand] || null;\n    },\n    set: function set(val) {\n      this[shorthand] = val;\n      return val;\n    }\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domhandler/lib/node.js?')},"./node_modules/react-html-parser/node_modules/domutils/index.js":function(module,exports,__webpack_require__){eval('var DomUtils = module.exports;\n[__webpack_require__(/*! ./lib/stringify */ "./node_modules/react-html-parser/node_modules/domutils/lib/stringify.js"), __webpack_require__(/*! ./lib/traversal */ "./node_modules/react-html-parser/node_modules/domutils/lib/traversal.js"), __webpack_require__(/*! ./lib/manipulation */ "./node_modules/react-html-parser/node_modules/domutils/lib/manipulation.js"), __webpack_require__(/*! ./lib/querying */ "./node_modules/react-html-parser/node_modules/domutils/lib/querying.js"), __webpack_require__(/*! ./lib/legacy */ "./node_modules/react-html-parser/node_modules/domutils/lib/legacy.js"), __webpack_require__(/*! ./lib/helpers */ "./node_modules/react-html-parser/node_modules/domutils/lib/helpers.js")].forEach(function (ext) {\n  Object.keys(ext).forEach(function (key) {\n    DomUtils[key] = ext[key].bind(DomUtils);\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/index.js?')},"./node_modules/react-html-parser/node_modules/domutils/lib/helpers.js":function(module,exports){eval("// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function (nodes) {\n  var idx = nodes.length,\n      node,\n      ancestor,\n      replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = ancestor.parent;\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n}; // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n\n\nvar POSITION = {\n  DISCONNECTED: 1,\n  PRECEDING: 2,\n  FOLLOWING: 4,\n  CONTAINS: 8,\n  CONTAINED_BY: 16\n}; // Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\n\nvar comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {\n  var aParents = [];\n  var bParents = [];\n  var current, sharedParent, siblings, aSibling, bSibling, idx;\n\n  if (nodeA === nodeB) {\n    return 0;\n  }\n\n  current = nodeA;\n\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n\n  current = nodeB;\n\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n\n  idx = 0;\n\n  while (aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return POSITION.DISCONNECTED;\n  }\n\n  sharedParent = aParents[idx - 1];\n  siblings = sharedParent.children;\n  aSibling = aParents[idx];\n  bSibling = bParents[idx];\n\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n    }\n\n    return POSITION.FOLLOWING;\n  } else {\n    if (sharedParent === nodeA) {\n      return POSITION.PRECEDING | POSITION.CONTAINS;\n    }\n\n    return POSITION.PRECEDING;\n  }\n}; // Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\n\n\nexports.uniqueSort = function (nodes) {\n  var idx = nodes.length,\n      node,\n      position;\n  nodes = nodes.slice();\n\n  while (--idx > -1) {\n    node = nodes[idx];\n    position = nodes.indexOf(node);\n\n    if (position > -1 && position < idx) {\n      nodes.splice(idx, 1);\n    }\n  }\n\n  nodes.sort(function (a, b) {\n    var relative = comparePos(a, b);\n\n    if (relative & POSITION.PRECEDING) {\n      return -1;\n    } else if (relative & POSITION.FOLLOWING) {\n      return 1;\n    }\n\n    return 0;\n  });\n  return nodes;\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/lib/helpers.js?")},"./node_modules/react-html-parser/node_modules/domutils/lib/legacy.js":function(module,exports,__webpack_require__){eval('var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/react-html-parser/node_modules/domelementtype/index.js");\n\nvar isTag = exports.isTag = ElementType.isTag;\n\nexports.testElement = function (options, element) {\n  for (var key in options) {\n    if (!options.hasOwnProperty(key)) ;else if (key === "tag_name") {\n      if (!isTag(element) || !options.tag_name(element.name)) {\n        return false;\n      }\n    } else if (key === "tag_type") {\n      if (!options.tag_type(element.type)) return false;\n    } else if (key === "tag_contains") {\n      if (isTag(element) || !options.tag_contains(element.data)) {\n        return false;\n      }\n    } else if (!element.attribs || !options[key](element.attribs[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar Checks = {\n  tag_name: function tag_name(name) {\n    if (typeof name === "function") {\n      return function (elem) {\n        return isTag(elem) && name(elem.name);\n      };\n    } else if (name === "*") {\n      return isTag;\n    } else {\n      return function (elem) {\n        return isTag(elem) && elem.name === name;\n      };\n    }\n  },\n  tag_type: function tag_type(type) {\n    if (typeof type === "function") {\n      return function (elem) {\n        return type(elem.type);\n      };\n    } else {\n      return function (elem) {\n        return elem.type === type;\n      };\n    }\n  },\n  tag_contains: function tag_contains(data) {\n    if (typeof data === "function") {\n      return function (elem) {\n        return !isTag(elem) && data(elem.data);\n      };\n    } else {\n      return function (elem) {\n        return !isTag(elem) && elem.data === data;\n      };\n    }\n  }\n};\n\nfunction getAttribCheck(attrib, value) {\n  if (typeof value === "function") {\n    return function (elem) {\n      return elem.attribs && value(elem.attribs[attrib]);\n    };\n  } else {\n    return function (elem) {\n      return elem.attribs && elem.attribs[attrib] === value;\n    };\n  }\n}\n\nfunction combineFuncs(a, b) {\n  return function (elem) {\n    return a(elem) || b(elem);\n  };\n}\n\nexports.getElements = function (options, element, recurse, limit) {\n  var funcs = Object.keys(options).map(function (key) {\n    var value = options[key];\n    return key in Checks ? Checks[key](value) : getAttribCheck(key, value);\n  });\n  return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);\n};\n\nexports.getElementById = function (id, element, recurse) {\n  if (!Array.isArray(element)) element = [element];\n  return this.findOne(getAttribCheck("id", id), element, recurse !== false);\n};\n\nexports.getElementsByTagName = function (name, element, recurse, limit) {\n  return this.filter(Checks.tag_name(name), element, recurse, limit);\n};\n\nexports.getElementsByTagType = function (type, element, recurse, limit) {\n  return this.filter(Checks.tag_type(type), element, recurse, limit);\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/lib/legacy.js?')},"./node_modules/react-html-parser/node_modules/domutils/lib/manipulation.js":function(module,exports){eval("exports.removeElement = function (elem) {\n  if (elem.prev) elem.prev.next = elem.next;\n  if (elem.next) elem.next.prev = elem.prev;\n\n  if (elem.parent) {\n    var childs = elem.parent.children;\n    childs.splice(childs.lastIndexOf(elem), 1);\n  }\n};\n\nexports.replaceElement = function (elem, replacement) {\n  var prev = replacement.prev = elem.prev;\n\n  if (prev) {\n    prev.next = replacement;\n  }\n\n  var next = replacement.next = elem.next;\n\n  if (next) {\n    next.prev = replacement;\n  }\n\n  var parent = replacement.parent = elem.parent;\n\n  if (parent) {\n    var childs = parent.children;\n    childs[childs.lastIndexOf(elem)] = replacement;\n  }\n};\n\nexports.appendChild = function (elem, child) {\n  child.parent = elem;\n\n  if (elem.children.push(child) !== 1) {\n    var sibling = elem.children[elem.children.length - 2];\n    sibling.next = child;\n    child.prev = sibling;\n    child.next = null;\n  }\n};\n\nexports.append = function (elem, next) {\n  var parent = elem.parent,\n      currNext = elem.next;\n  next.next = currNext;\n  next.prev = elem;\n  elem.next = next;\n  next.parent = parent;\n\n  if (currNext) {\n    currNext.prev = next;\n\n    if (parent) {\n      var childs = parent.children;\n      childs.splice(childs.lastIndexOf(currNext), 0, next);\n    }\n  } else if (parent) {\n    parent.children.push(next);\n  }\n};\n\nexports.prepend = function (elem, prev) {\n  var parent = elem.parent;\n\n  if (parent) {\n    var childs = parent.children;\n    childs.splice(childs.lastIndexOf(elem), 0, prev);\n  }\n\n  if (elem.prev) {\n    elem.prev.next = prev;\n  }\n\n  prev.parent = parent;\n  prev.prev = elem.prev;\n  prev.next = elem;\n  elem.prev = prev;\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/lib/manipulation.js?")},"./node_modules/react-html-parser/node_modules/domutils/lib/querying.js":function(module,exports,__webpack_require__){eval('var isTag = __webpack_require__(/*! domelementtype */ "./node_modules/react-html-parser/node_modules/domelementtype/index.js").isTag;\n\nmodule.exports = {\n  filter: filter,\n  find: find,\n  findOneChild: findOneChild,\n  findOne: findOne,\n  existsOne: existsOne,\n  findAll: findAll\n};\n\nfunction filter(test, element, recurse, limit) {\n  if (!Array.isArray(element)) element = [element];\n\n  if (typeof limit !== "number" || !isFinite(limit)) {\n    limit = Infinity;\n  }\n\n  return find(test, element, recurse !== false, limit);\n}\n\nfunction find(test, elems, recurse, limit) {\n  var result = [],\n      childs;\n\n  for (var i = 0, j = elems.length; i < j; i++) {\n    if (test(elems[i])) {\n      result.push(elems[i]);\n      if (--limit <= 0) break;\n    }\n\n    childs = elems[i].children;\n\n    if (recurse && childs && childs.length > 0) {\n      childs = find(test, childs, recurse, limit);\n      result = result.concat(childs);\n      limit -= childs.length;\n      if (limit <= 0) break;\n    }\n  }\n\n  return result;\n}\n\nfunction findOneChild(test, elems) {\n  for (var i = 0, l = elems.length; i < l; i++) {\n    if (test(elems[i])) return elems[i];\n  }\n\n  return null;\n}\n\nfunction findOne(test, elems) {\n  var elem = null;\n\n  for (var i = 0, l = elems.length; i < l && !elem; i++) {\n    if (!isTag(elems[i])) {\n      continue;\n    } else if (test(elems[i])) {\n      elem = elems[i];\n    } else if (elems[i].children.length > 0) {\n      elem = findOne(test, elems[i].children);\n    }\n  }\n\n  return elem;\n}\n\nfunction existsOne(test, elems) {\n  for (var i = 0, l = elems.length; i < l; i++) {\n    if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction findAll(test, rootElems) {\n  var result = [];\n  var stack = rootElems.slice();\n\n  while (stack.length) {\n    var elem = stack.shift();\n    if (!isTag(elem)) continue;\n\n    if (elem.children && elem.children.length > 0) {\n      stack.unshift.apply(stack, elem.children);\n    }\n\n    if (test(elem)) result.push(elem);\n  }\n\n  return result;\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/lib/querying.js?')},"./node_modules/react-html-parser/node_modules/domutils/lib/stringify.js":function(module,exports,__webpack_require__){eval('var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/react-html-parser/node_modules/domelementtype/index.js"),\n    getOuterHTML = __webpack_require__(/*! dom-serializer */ "./node_modules/react-html-parser/node_modules/dom-serializer/index.js"),\n    isTag = ElementType.isTag;\n\nmodule.exports = {\n  getInnerHTML: getInnerHTML,\n  getOuterHTML: getOuterHTML,\n  getText: getText\n};\n\nfunction getInnerHTML(elem, opts) {\n  return elem.children ? elem.children.map(function (elem) {\n    return getOuterHTML(elem, opts);\n  }).join("") : "";\n}\n\nfunction getText(elem) {\n  if (Array.isArray(elem)) return elem.map(getText).join("");\n  if (isTag(elem)) return elem.name === "br" ? "\\n" : getText(elem.children);\n  if (elem.type === ElementType.CDATA) return getText(elem.children);\n  if (elem.type === ElementType.Text) return elem.data;\n  return "";\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/lib/stringify.js?')},"./node_modules/react-html-parser/node_modules/domutils/lib/traversal.js":function(module,exports){eval("var getChildren = exports.getChildren = function (elem) {\n  return elem.children;\n};\n\nvar getParent = exports.getParent = function (elem) {\n  return elem.parent;\n};\n\nexports.getSiblings = function (elem) {\n  var parent = getParent(elem);\n  return parent ? getChildren(parent) : [elem];\n};\n\nexports.getAttributeValue = function (elem, name) {\n  return elem.attribs && elem.attribs[name];\n};\n\nexports.hasAttrib = function (elem, name) {\n  return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);\n};\n\nexports.getName = function (elem) {\n  return elem.name;\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/domutils/lib/traversal.js?")},"./node_modules/react-html-parser/node_modules/entities/index.js":function(module,exports,__webpack_require__){eval('var encode = __webpack_require__(/*! ./lib/encode.js */ "./node_modules/react-html-parser/node_modules/entities/lib/encode.js"),\n    decode = __webpack_require__(/*! ./lib/decode.js */ "./node_modules/react-html-parser/node_modules/entities/lib/decode.js");\n\nexports.decode = function (data, level) {\n  return (!level || level <= 0 ? decode.XML : decode.HTML)(data);\n};\n\nexports.decodeStrict = function (data, level) {\n  return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);\n};\n\nexports.encode = function (data, level) {\n  return (!level || level <= 0 ? encode.XML : encode.HTML)(data);\n};\n\nexports.encodeXML = encode.XML;\nexports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML = encode.HTML;\nexports.decodeXML = exports.decodeXMLStrict = decode.XML;\nexports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML = decode.HTML;\nexports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict = decode.HTMLStrict;\nexports.escape = encode.escape;\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/index.js?')},"./node_modules/react-html-parser/node_modules/entities/lib/decode.js":function(module,exports,__webpack_require__){eval('var entityMap = __webpack_require__(/*! ../maps/entities.json */ "./node_modules/react-html-parser/node_modules/entities/maps/entities.json"),\n    legacyMap = __webpack_require__(/*! ../maps/legacy.json */ "./node_modules/react-html-parser/node_modules/entities/maps/legacy.json"),\n    xmlMap = __webpack_require__(/*! ../maps/xml.json */ "./node_modules/react-html-parser/node_modules/entities/maps/xml.json"),\n    decodeCodePoint = __webpack_require__(/*! ./decode_codepoint.js */ "./node_modules/react-html-parser/node_modules/entities/lib/decode_codepoint.js");\n\nvar decodeXMLStrict = getStrictDecoder(xmlMap),\n    decodeHTMLStrict = getStrictDecoder(entityMap);\n\nfunction getStrictDecoder(map) {\n  var keys = Object.keys(map).join("|"),\n      replace = getReplacer(map);\n  keys += "|#[xX][\\\\da-fA-F]+|#\\\\d+";\n  var re = new RegExp("&(?:" + keys + ");", "g");\n  return function (str) {\n    return String(str).replace(re, replace);\n  };\n}\n\nvar decodeHTML = function () {\n  var legacy = Object.keys(legacyMap).sort(sorter);\n  var keys = Object.keys(entityMap).sort(sorter);\n\n  for (var i = 0, j = 0; i < keys.length; i++) {\n    if (legacy[j] === keys[i]) {\n      keys[i] += ";?";\n      j++;\n    } else {\n      keys[i] += ";";\n    }\n  }\n\n  var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)", "g"),\n      replace = getReplacer(entityMap);\n\n  function replacer(str) {\n    if (str.substr(-1) !== ";") str += ";";\n    return replace(str);\n  } //TODO consider creating a merged map\n\n\n  return function (str) {\n    return String(str).replace(re, replacer);\n  };\n}();\n\nfunction sorter(a, b) {\n  return a < b ? 1 : -1;\n}\n\nfunction getReplacer(map) {\n  return function replace(str) {\n    if (str.charAt(1) === "#") {\n      if (str.charAt(2) === "X" || str.charAt(2) === "x") {\n        return decodeCodePoint(parseInt(str.substr(3), 16));\n      }\n\n      return decodeCodePoint(parseInt(str.substr(2), 10));\n    }\n\n    return map[str.slice(1, -1)];\n  };\n}\n\nmodule.exports = {\n  XML: decodeXMLStrict,\n  HTML: decodeHTML,\n  HTMLStrict: decodeHTMLStrict\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/lib/decode.js?')},"./node_modules/react-html-parser/node_modules/entities/lib/decode_codepoint.js":function(module,exports,__webpack_require__){eval('var decodeMap = __webpack_require__(/*! ../maps/decode.json */ "./node_modules/react-html-parser/node_modules/entities/maps/decode.json");\n\nmodule.exports = decodeCodePoint; // modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\n\nfunction decodeCodePoint(codePoint) {\n  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {\n    return "\\uFFFD";\n  }\n\n  if (codePoint in decodeMap) {\n    codePoint = decodeMap[codePoint];\n  }\n\n  var output = "";\n\n  if (codePoint > 0xffff) {\n    codePoint -= 0x10000;\n    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);\n    codePoint = 0xdc00 | codePoint & 0x3ff;\n  }\n\n  output += String.fromCharCode(codePoint);\n  return output;\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/lib/decode_codepoint.js?')},"./node_modules/react-html-parser/node_modules/entities/lib/encode.js":function(module,exports,__webpack_require__){eval('var inverseXML = getInverseObj(__webpack_require__(/*! ../maps/xml.json */ "./node_modules/react-html-parser/node_modules/entities/maps/xml.json")),\n    xmlReplacer = getInverseReplacer(inverseXML);\nexports.XML = getInverse(inverseXML, xmlReplacer);\nvar inverseHTML = getInverseObj(__webpack_require__(/*! ../maps/entities.json */ "./node_modules/react-html-parser/node_modules/entities/maps/entities.json")),\n    htmlReplacer = getInverseReplacer(inverseHTML);\nexports.HTML = getInverse(inverseHTML, htmlReplacer);\n\nfunction getInverseObj(obj) {\n  return Object.keys(obj).sort().reduce(function (inverse, name) {\n    inverse[obj[name]] = "&" + name + ";";\n    return inverse;\n  }, {});\n}\n\nfunction getInverseReplacer(inverse) {\n  var single = [],\n      multiple = [];\n  Object.keys(inverse).forEach(function (k) {\n    if (k.length === 1) {\n      single.push("\\\\" + k);\n    } else {\n      multiple.push(k);\n    }\n  }); //TODO add ranges\n\n  multiple.unshift("[" + single.join("") + "]");\n  return new RegExp(multiple.join("|"), "g");\n}\n\nvar re_nonASCII = /[^\\0-\\x7F]/g,\n    re_astralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction singleCharReplacer(c) {\n  return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";\n}\n\nfunction astralReplacer(c) {\n  // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n  var high = c.charCodeAt(0);\n  var low = c.charCodeAt(1);\n  var codePoint = (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;\n  return "&#x" + codePoint.toString(16).toUpperCase() + ";";\n}\n\nfunction getInverse(inverse, re) {\n  function func(name) {\n    return inverse[name];\n  }\n\n  return function (data) {\n    return data.replace(re, func).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);\n  };\n}\n\nvar re_xmlChars = getInverseReplacer(inverseXML);\n\nfunction escapeXML(data) {\n  return data.replace(re_xmlChars, singleCharReplacer).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);\n}\n\nexports.escape = escapeXML;\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/lib/encode.js?')},"./node_modules/react-html-parser/node_modules/entities/maps/decode.json":function(module){eval('module.exports = {"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/maps/decode.json?')},"./node_modules/react-html-parser/node_modules/entities/maps/entities.json":function(module){eval('module.exports = {"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"\'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\\"","QUOT":"\\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/maps/entities.json?')},"./node_modules/react-html-parser/node_modules/entities/maps/legacy.json":function(module){eval('module.exports = {"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\\"","QUOT":"\\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/maps/legacy.json?')},"./node_modules/react-html-parser/node_modules/entities/maps/xml.json":function(module){eval('module.exports = {"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/entities/maps/xml.json?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/CollectingHandler.js":function(module,exports,__webpack_require__){eval('module.exports = CollectingHandler;\n\nfunction CollectingHandler(cbs) {\n  this._cbs = cbs || {};\n  this.events = [];\n}\n\nvar EVENTS = __webpack_require__(/*! ./ */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js").EVENTS;\n\nObject.keys(EVENTS).forEach(function (name) {\n  if (EVENTS[name] === 0) {\n    name = "on" + name;\n\n    CollectingHandler.prototype[name] = function () {\n      this.events.push([name]);\n      if (this._cbs[name]) this._cbs[name]();\n    };\n  } else if (EVENTS[name] === 1) {\n    name = "on" + name;\n\n    CollectingHandler.prototype[name] = function (a) {\n      this.events.push([name, a]);\n      if (this._cbs[name]) this._cbs[name](a);\n    };\n  } else if (EVENTS[name] === 2) {\n    name = "on" + name;\n\n    CollectingHandler.prototype[name] = function (a, b) {\n      this.events.push([name, a, b]);\n      if (this._cbs[name]) this._cbs[name](a, b);\n    };\n  } else {\n    throw Error("wrong number of arguments");\n  }\n});\n\nCollectingHandler.prototype.onreset = function () {\n  this.events = [];\n  if (this._cbs.onreset) this._cbs.onreset();\n};\n\nCollectingHandler.prototype.restart = function () {\n  if (this._cbs.onreset) this._cbs.onreset();\n\n  for (var i = 0, len = this.events.length; i < len; i++) {\n    if (this._cbs[this.events[i][0]]) {\n      var num = this.events[i].length;\n\n      if (num === 1) {\n        this._cbs[this.events[i][0]]();\n      } else if (num === 2) {\n        this._cbs[this.events[i][0]](this.events[i][1]);\n      } else {\n        this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/CollectingHandler.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/FeedHandler.js":function(module,exports,__webpack_require__){eval('var DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/react-html-parser/node_modules/domhandler/index.js");\n\nvar DomUtils = __webpack_require__(/*! domutils */ "./node_modules/react-html-parser/node_modules/domutils/index.js"); //TODO: make this a streamable handler\n\n\nfunction FeedHandler(callback, options) {\n  this.init(callback, options);\n}\n\n__webpack_require__(/*! inherits */ "./node_modules/react-html-parser/node_modules/inherits/inherits_browser.js")(FeedHandler, DomHandler);\n\nFeedHandler.prototype.init = DomHandler;\n\nfunction getElements(what, where) {\n  return DomUtils.getElementsByTagName(what, where, true);\n}\n\nfunction getOneElement(what, where) {\n  return DomUtils.getElementsByTagName(what, where, true, 1)[0];\n}\n\nfunction fetch(what, where, recurse) {\n  return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();\n}\n\nfunction addConditionally(obj, prop, what, where, recurse) {\n  var tmp = fetch(what, where, recurse);\n  if (tmp) obj[prop] = tmp;\n}\n\nvar isValidFeed = function isValidFeed(value) {\n  return value === "rss" || value === "feed" || value === "rdf:RDF";\n};\n\nFeedHandler.prototype.onend = function () {\n  var feed = {},\n      feedRoot = getOneElement(isValidFeed, this.dom),\n      tmp,\n      childs;\n\n  if (feedRoot) {\n    if (feedRoot.name === "feed") {\n      childs = feedRoot.children;\n      feed.type = "atom";\n      addConditionally(feed, "id", "id", childs);\n      addConditionally(feed, "title", "title", childs);\n      if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;\n      addConditionally(feed, "description", "subtitle", childs);\n      if (tmp = fetch("updated", childs)) feed.updated = new Date(tmp);\n      addConditionally(feed, "author", "email", childs, true);\n      feed.items = getElements("entry", childs).map(function (item) {\n        var entry = {},\n            tmp;\n        item = item.children;\n        addConditionally(entry, "id", "id", item);\n        addConditionally(entry, "title", "title", item);\n        if ((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;\n        if (tmp = fetch("summary", item) || fetch("content", item)) entry.description = tmp;\n        if (tmp = fetch("updated", item)) entry.pubDate = new Date(tmp);\n        return entry;\n      });\n    } else {\n      childs = getOneElement("channel", feedRoot.children).children;\n      feed.type = feedRoot.name.substr(0, 3);\n      feed.id = "";\n      addConditionally(feed, "title", "title", childs);\n      addConditionally(feed, "link", "link", childs);\n      addConditionally(feed, "description", "description", childs);\n      if (tmp = fetch("lastBuildDate", childs)) feed.updated = new Date(tmp);\n      addConditionally(feed, "author", "managingEditor", childs, true);\n      feed.items = getElements("item", feedRoot.children).map(function (item) {\n        var entry = {},\n            tmp;\n        item = item.children;\n        addConditionally(entry, "id", "guid", item);\n        addConditionally(entry, "title", "title", item);\n        addConditionally(entry, "link", "link", item);\n        addConditionally(entry, "description", "description", item);\n        if (tmp = fetch("pubDate", item)) entry.pubDate = new Date(tmp);\n        return entry;\n      });\n    }\n  }\n\n  this.dom = feed;\n\n  DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn\'t find root of feed"));\n};\n\nmodule.exports = FeedHandler;\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/FeedHandler.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/Parser.js":function(module,exports,__webpack_require__){eval('var Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/Tokenizer.js");\n/*\n\tOptions:\n\n\txmlMode: Disables the special behavior for script/style tags (false by default)\n\tlowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)\n\tlowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)\n*/\n\n/*\n\tCallbacks:\n\n\toncdataend,\n\toncdatastart,\n\tonclosetag,\n\toncomment,\n\toncommentend,\n\tonerror,\n\tonopentag,\n\tonprocessinginstruction,\n\tonreset,\n\tontext\n*/\n\n\nvar formTags = {\n  input: true,\n  option: true,\n  optgroup: true,\n  select: true,\n  button: true,\n  datalist: true,\n  textarea: true\n};\nvar openImpliesClose = {\n  tr: {\n    tr: true,\n    th: true,\n    td: true\n  },\n  th: {\n    th: true\n  },\n  td: {\n    thead: true,\n    th: true,\n    td: true\n  },\n  body: {\n    head: true,\n    link: true,\n    script: true\n  },\n  li: {\n    li: true\n  },\n  p: {\n    p: true\n  },\n  h1: {\n    p: true\n  },\n  h2: {\n    p: true\n  },\n  h3: {\n    p: true\n  },\n  h4: {\n    p: true\n  },\n  h5: {\n    p: true\n  },\n  h6: {\n    p: true\n  },\n  select: formTags,\n  input: formTags,\n  output: formTags,\n  button: formTags,\n  datalist: formTags,\n  textarea: formTags,\n  option: {\n    option: true\n  },\n  optgroup: {\n    optgroup: true\n  }\n};\nvar voidElements = {\n  __proto__: null,\n  area: true,\n  base: true,\n  basefont: true,\n  br: true,\n  col: true,\n  command: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  isindex: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\nvar foreignContextElements = {\n  __proto__: null,\n  math: true,\n  svg: true\n};\nvar htmlIntegrationElements = {\n  __proto__: null,\n  mi: true,\n  mo: true,\n  mn: true,\n  ms: true,\n  mtext: true,\n  "annotation-xml": true,\n  foreignObject: true,\n  desc: true,\n  title: true\n};\nvar re_nameEnd = /\\s|\\//;\n\nfunction Parser(cbs, options) {\n  this._options = options || {};\n  this._cbs = cbs || {};\n  this._tagname = "";\n  this._attribname = "";\n  this._attribvalue = "";\n  this._attribs = null;\n  this._stack = [];\n  this._foreignContext = [];\n  this.startIndex = 0;\n  this.endIndex = null;\n  this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;\n  this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;\n\n  if (this._options.Tokenizer) {\n    Tokenizer = this._options.Tokenizer;\n  }\n\n  this._tokenizer = new Tokenizer(this._options, this);\n  if (this._cbs.onparserinit) this._cbs.onparserinit(this);\n}\n\n__webpack_require__(/*! inherits */ "./node_modules/react-html-parser/node_modules/inherits/inherits_browser.js")(Parser, __webpack_require__(/*! events */ "./node_modules/webpack/node_modules/events/events.js").EventEmitter);\n\nParser.prototype._updatePosition = function (initialOffset) {\n  if (this.endIndex === null) {\n    if (this._tokenizer._sectionStart <= initialOffset) {\n      this.startIndex = 0;\n    } else {\n      this.startIndex = this._tokenizer._sectionStart - initialOffset;\n    }\n  } else this.startIndex = this.endIndex + 1;\n\n  this.endIndex = this._tokenizer.getAbsoluteIndex();\n}; //Tokenizer event handlers\n\n\nParser.prototype.ontext = function (data) {\n  this._updatePosition(1);\n\n  this.endIndex--;\n  if (this._cbs.ontext) this._cbs.ontext(data);\n};\n\nParser.prototype.onopentagname = function (name) {\n  if (this._lowerCaseTagNames) {\n    name = name.toLowerCase();\n  }\n\n  this._tagname = name;\n\n  if (!this._options.xmlMode && name in openImpliesClose) {\n    for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el)) {\n      ;\n    }\n  }\n\n  if (this._options.xmlMode || !(name in voidElements)) {\n    this._stack.push(name);\n\n    if (name in foreignContextElements) this._foreignContext.push(true);else if (name in htmlIntegrationElements) this._foreignContext.push(false);\n  }\n\n  if (this._cbs.onopentagname) this._cbs.onopentagname(name);\n  if (this._cbs.onopentag) this._attribs = {};\n};\n\nParser.prototype.onopentagend = function () {\n  this._updatePosition(1);\n\n  if (this._attribs) {\n    if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);\n    this._attribs = null;\n  }\n\n  if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {\n    this._cbs.onclosetag(this._tagname);\n  }\n\n  this._tagname = "";\n};\n\nParser.prototype.onclosetag = function (name) {\n  this._updatePosition(1);\n\n  if (this._lowerCaseTagNames) {\n    name = name.toLowerCase();\n  }\n\n  if (name in foreignContextElements || name in htmlIntegrationElements) {\n    this._foreignContext.pop();\n  }\n\n  if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {\n    var pos = this._stack.lastIndexOf(name);\n\n    if (pos !== -1) {\n      if (this._cbs.onclosetag) {\n        pos = this._stack.length - pos;\n\n        while (pos--) {\n          this._cbs.onclosetag(this._stack.pop());\n        }\n      } else this._stack.length = pos;\n    } else if (name === "p" && !this._options.xmlMode) {\n      this.onopentagname(name);\n\n      this._closeCurrentTag();\n    }\n  } else if (!this._options.xmlMode && (name === "br" || name === "p")) {\n    this.onopentagname(name);\n\n    this._closeCurrentTag();\n  }\n};\n\nParser.prototype.onselfclosingtag = function () {\n  if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {\n    this._closeCurrentTag();\n  } else {\n    this.onopentagend();\n  }\n};\n\nParser.prototype._closeCurrentTag = function () {\n  var name = this._tagname;\n  this.onopentagend(); //self-closing tags will be on the top of the stack\n  //(cheaper check than in onclosetag)\n\n  if (this._stack[this._stack.length - 1] === name) {\n    if (this._cbs.onclosetag) {\n      this._cbs.onclosetag(name);\n    }\n\n    this._stack.pop();\n  }\n};\n\nParser.prototype.onattribname = function (name) {\n  if (this._lowerCaseAttributeNames) {\n    name = name.toLowerCase();\n  }\n\n  this._attribname = name;\n};\n\nParser.prototype.onattribdata = function (value) {\n  this._attribvalue += value;\n};\n\nParser.prototype.onattribend = function () {\n  if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);\n\n  if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {\n    this._attribs[this._attribname] = this._attribvalue;\n  }\n\n  this._attribname = "";\n  this._attribvalue = "";\n};\n\nParser.prototype._getInstructionName = function (value) {\n  var idx = value.search(re_nameEnd),\n      name = idx < 0 ? value : value.substr(0, idx);\n\n  if (this._lowerCaseTagNames) {\n    name = name.toLowerCase();\n  }\n\n  return name;\n};\n\nParser.prototype.ondeclaration = function (value) {\n  if (this._cbs.onprocessinginstruction) {\n    var name = this._getInstructionName(value);\n\n    this._cbs.onprocessinginstruction("!" + name, "!" + value);\n  }\n};\n\nParser.prototype.onprocessinginstruction = function (value) {\n  if (this._cbs.onprocessinginstruction) {\n    var name = this._getInstructionName(value);\n\n    this._cbs.onprocessinginstruction("?" + name, "?" + value);\n  }\n};\n\nParser.prototype.oncomment = function (value) {\n  this._updatePosition(4);\n\n  if (this._cbs.oncomment) this._cbs.oncomment(value);\n  if (this._cbs.oncommentend) this._cbs.oncommentend();\n};\n\nParser.prototype.oncdata = function (value) {\n  this._updatePosition(1);\n\n  if (this._options.xmlMode || this._options.recognizeCDATA) {\n    if (this._cbs.oncdatastart) this._cbs.oncdatastart();\n    if (this._cbs.ontext) this._cbs.ontext(value);\n    if (this._cbs.oncdataend) this._cbs.oncdataend();\n  } else {\n    this.oncomment("[CDATA[" + value + "]]");\n  }\n};\n\nParser.prototype.onerror = function (err) {\n  if (this._cbs.onerror) this._cbs.onerror(err);\n};\n\nParser.prototype.onend = function () {\n  if (this._cbs.onclosetag) {\n    for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i])) {\n      ;\n    }\n  }\n\n  if (this._cbs.onend) this._cbs.onend();\n}; //Resets the parser to a blank state, ready to parse a new HTML document\n\n\nParser.prototype.reset = function () {\n  if (this._cbs.onreset) this._cbs.onreset();\n\n  this._tokenizer.reset();\n\n  this._tagname = "";\n  this._attribname = "";\n  this._attribs = null;\n  this._stack = [];\n  if (this._cbs.onparserinit) this._cbs.onparserinit(this);\n}; //Parses a complete HTML document and pushes it to the handler\n\n\nParser.prototype.parseComplete = function (data) {\n  this.reset();\n  this.end(data);\n};\n\nParser.prototype.write = function (chunk) {\n  this._tokenizer.write(chunk);\n};\n\nParser.prototype.end = function (chunk) {\n  this._tokenizer.end(chunk);\n};\n\nParser.prototype.pause = function () {\n  this._tokenizer.pause();\n};\n\nParser.prototype.resume = function () {\n  this._tokenizer.resume();\n}; //alias for backwards compat\n\n\nParser.prototype.parseChunk = Parser.prototype.write;\nParser.prototype.done = Parser.prototype.end;\nmodule.exports = Parser;\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/Parser.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/ProxyHandler.js":function(module,exports,__webpack_require__){eval('module.exports = ProxyHandler;\n\nfunction ProxyHandler(cbs) {\n  this._cbs = cbs || {};\n}\n\nvar EVENTS = __webpack_require__(/*! ./ */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js").EVENTS;\n\nObject.keys(EVENTS).forEach(function (name) {\n  if (EVENTS[name] === 0) {\n    name = "on" + name;\n\n    ProxyHandler.prototype[name] = function () {\n      if (this._cbs[name]) this._cbs[name]();\n    };\n  } else if (EVENTS[name] === 1) {\n    name = "on" + name;\n\n    ProxyHandler.prototype[name] = function (a) {\n      if (this._cbs[name]) this._cbs[name](a);\n    };\n  } else if (EVENTS[name] === 2) {\n    name = "on" + name;\n\n    ProxyHandler.prototype[name] = function (a, b) {\n      if (this._cbs[name]) this._cbs[name](a, b);\n    };\n  } else {\n    throw Error("wrong number of arguments");\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/ProxyHandler.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/Stream.js":function(module,exports,__webpack_require__){eval('module.exports = Stream;\n\nvar Parser = __webpack_require__(/*! ./WritableStream.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/WritableStream.js");\n\nfunction Stream(options) {\n  Parser.call(this, new Cbs(this), options);\n}\n\n__webpack_require__(/*! inherits */ "./node_modules/react-html-parser/node_modules/inherits/inherits_browser.js")(Stream, Parser);\n\nStream.prototype.readable = true;\n\nfunction Cbs(scope) {\n  this.scope = scope;\n}\n\nvar EVENTS = __webpack_require__(/*! ../ */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js").EVENTS;\n\nObject.keys(EVENTS).forEach(function (name) {\n  if (EVENTS[name] === 0) {\n    Cbs.prototype["on" + name] = function () {\n      this.scope.emit(name);\n    };\n  } else if (EVENTS[name] === 1) {\n    Cbs.prototype["on" + name] = function (a) {\n      this.scope.emit(name, a);\n    };\n  } else if (EVENTS[name] === 2) {\n    Cbs.prototype["on" + name] = function (a, b) {\n      this.scope.emit(name, a, b);\n    };\n  } else {\n    throw Error("wrong number of arguments!");\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/Stream.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/Tokenizer.js":function(module,exports,__webpack_require__){eval('module.exports = Tokenizer;\n\nvar decodeCodePoint = __webpack_require__(/*! entities/lib/decode_codepoint.js */ "./node_modules/react-html-parser/node_modules/entities/lib/decode_codepoint.js");\n\nvar entityMap = __webpack_require__(/*! entities/maps/entities.json */ "./node_modules/react-html-parser/node_modules/entities/maps/entities.json");\n\nvar legacyMap = __webpack_require__(/*! entities/maps/legacy.json */ "./node_modules/react-html-parser/node_modules/entities/maps/legacy.json");\n\nvar xmlMap = __webpack_require__(/*! entities/maps/xml.json */ "./node_modules/react-html-parser/node_modules/entities/maps/xml.json");\n\nvar i = 0;\nvar TEXT = i++;\nvar BEFORE_TAG_NAME = i++; //after <\n\nvar IN_TAG_NAME = i++;\nvar IN_SELF_CLOSING_TAG = i++;\nvar BEFORE_CLOSING_TAG_NAME = i++;\nvar IN_CLOSING_TAG_NAME = i++;\nvar AFTER_CLOSING_TAG_NAME = i++; //attributes\n\nvar BEFORE_ATTRIBUTE_NAME = i++;\nvar IN_ATTRIBUTE_NAME = i++;\nvar AFTER_ATTRIBUTE_NAME = i++;\nvar BEFORE_ATTRIBUTE_VALUE = i++;\nvar IN_ATTRIBUTE_VALUE_DQ = i++; // "\n\nvar IN_ATTRIBUTE_VALUE_SQ = i++; // \'\n\nvar IN_ATTRIBUTE_VALUE_NQ = i++; //declarations\n\nvar BEFORE_DECLARATION = i++; // !\n\nvar IN_DECLARATION = i++; //processing instructions\n\nvar IN_PROCESSING_INSTRUCTION = i++; // ?\n//comments\n\nvar BEFORE_COMMENT = i++;\nvar IN_COMMENT = i++;\nvar AFTER_COMMENT_1 = i++;\nvar AFTER_COMMENT_2 = i++; //cdata\n\nvar BEFORE_CDATA_1 = i++; // [\n\nvar BEFORE_CDATA_2 = i++; // C\n\nvar BEFORE_CDATA_3 = i++; // D\n\nvar BEFORE_CDATA_4 = i++; // A\n\nvar BEFORE_CDATA_5 = i++; // T\n\nvar BEFORE_CDATA_6 = i++; // A\n\nvar IN_CDATA = i++; // [\n\nvar AFTER_CDATA_1 = i++; // ]\n\nvar AFTER_CDATA_2 = i++; // ]\n//special tags\n\nvar BEFORE_SPECIAL = i++; //S\n\nvar BEFORE_SPECIAL_END = i++; //S\n\nvar BEFORE_SCRIPT_1 = i++; //C\n\nvar BEFORE_SCRIPT_2 = i++; //R\n\nvar BEFORE_SCRIPT_3 = i++; //I\n\nvar BEFORE_SCRIPT_4 = i++; //P\n\nvar BEFORE_SCRIPT_5 = i++; //T\n\nvar AFTER_SCRIPT_1 = i++; //C\n\nvar AFTER_SCRIPT_2 = i++; //R\n\nvar AFTER_SCRIPT_3 = i++; //I\n\nvar AFTER_SCRIPT_4 = i++; //P\n\nvar AFTER_SCRIPT_5 = i++; //T\n\nvar BEFORE_STYLE_1 = i++; //T\n\nvar BEFORE_STYLE_2 = i++; //Y\n\nvar BEFORE_STYLE_3 = i++; //L\n\nvar BEFORE_STYLE_4 = i++; //E\n\nvar AFTER_STYLE_1 = i++; //T\n\nvar AFTER_STYLE_2 = i++; //Y\n\nvar AFTER_STYLE_3 = i++; //L\n\nvar AFTER_STYLE_4 = i++; //E\n\nvar BEFORE_ENTITY = i++; //&\n\nvar BEFORE_NUMERIC_ENTITY = i++; //#\n\nvar IN_NAMED_ENTITY = i++;\nvar IN_NUMERIC_ENTITY = i++;\nvar IN_HEX_ENTITY = i++; //X\n\nvar j = 0;\nvar SPECIAL_NONE = j++;\nvar SPECIAL_SCRIPT = j++;\nvar SPECIAL_STYLE = j++;\n\nfunction whitespace(c) {\n  return c === " " || c === "\\n" || c === "\\t" || c === "\\f" || c === "\\r";\n}\n\nfunction ifElseState(upper, SUCCESS, FAILURE) {\n  var lower = upper.toLowerCase();\n\n  if (upper === lower) {\n    return function (c) {\n      if (c === lower) {\n        this._state = SUCCESS;\n      } else {\n        this._state = FAILURE;\n        this._index--;\n      }\n    };\n  } else {\n    return function (c) {\n      if (c === lower || c === upper) {\n        this._state = SUCCESS;\n      } else {\n        this._state = FAILURE;\n        this._index--;\n      }\n    };\n  }\n}\n\nfunction consumeSpecialNameChar(upper, NEXT_STATE) {\n  var lower = upper.toLowerCase();\n  return function (c) {\n    if (c === lower || c === upper) {\n      this._state = NEXT_STATE;\n    } else {\n      this._state = IN_TAG_NAME;\n      this._index--; //consume the token again\n    }\n  };\n}\n\nfunction Tokenizer(options, cbs) {\n  this._state = TEXT;\n  this._buffer = "";\n  this._sectionStart = 0;\n  this._index = 0;\n  this._bufferOffset = 0; //chars removed from _buffer\n\n  this._baseState = TEXT;\n  this._special = SPECIAL_NONE;\n  this._cbs = cbs;\n  this._running = true;\n  this._ended = false;\n  this._xmlMode = !!(options && options.xmlMode);\n  this._decodeEntities = !!(options && options.decodeEntities);\n}\n\nTokenizer.prototype._stateText = function (c) {\n  if (c === "<") {\n    if (this._index > this._sectionStart) {\n      this._cbs.ontext(this._getSection());\n    }\n\n    this._state = BEFORE_TAG_NAME;\n    this._sectionStart = this._index;\n  } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {\n    if (this._index > this._sectionStart) {\n      this._cbs.ontext(this._getSection());\n    }\n\n    this._baseState = TEXT;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateBeforeTagName = function (c) {\n  if (c === "/") {\n    this._state = BEFORE_CLOSING_TAG_NAME;\n  } else if (c === "<") {\n    this._cbs.ontext(this._getSection());\n\n    this._sectionStart = this._index;\n  } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {\n    this._state = TEXT;\n  } else if (c === "!") {\n    this._state = BEFORE_DECLARATION;\n    this._sectionStart = this._index + 1;\n  } else if (c === "?") {\n    this._state = IN_PROCESSING_INSTRUCTION;\n    this._sectionStart = this._index + 1;\n  } else {\n    this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateInTagName = function (c) {\n  if (c === "/" || c === ">" || whitespace(c)) {\n    this._emitToken("onopentagname");\n\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  }\n};\n\nTokenizer.prototype._stateBeforeCloseingTagName = function (c) {\n  if (whitespace(c)) ;else if (c === ">") {\n    this._state = TEXT;\n  } else if (this._special !== SPECIAL_NONE) {\n    if (c === "s" || c === "S") {\n      this._state = BEFORE_SPECIAL_END;\n    } else {\n      this._state = TEXT;\n      this._index--;\n    }\n  } else {\n    this._state = IN_CLOSING_TAG_NAME;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateInCloseingTagName = function (c) {\n  if (c === ">" || whitespace(c)) {\n    this._emitToken("onclosetag");\n\n    this._state = AFTER_CLOSING_TAG_NAME;\n    this._index--;\n  }\n};\n\nTokenizer.prototype._stateAfterCloseingTagName = function (c) {\n  //skip everything until ">"\n  if (c === ">") {\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  }\n};\n\nTokenizer.prototype._stateBeforeAttributeName = function (c) {\n  if (c === ">") {\n    this._cbs.onopentagend();\n\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (c === "/") {\n    this._state = IN_SELF_CLOSING_TAG;\n  } else if (!whitespace(c)) {\n    this._state = IN_ATTRIBUTE_NAME;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateInSelfClosingTag = function (c) {\n  if (c === ">") {\n    this._cbs.onselfclosingtag();\n\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (!whitespace(c)) {\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  }\n};\n\nTokenizer.prototype._stateInAttributeName = function (c) {\n  if (c === "=" || c === "/" || c === ">" || whitespace(c)) {\n    this._cbs.onattribname(this._getSection());\n\n    this._sectionStart = -1;\n    this._state = AFTER_ATTRIBUTE_NAME;\n    this._index--;\n  }\n};\n\nTokenizer.prototype._stateAfterAttributeName = function (c) {\n  if (c === "=") {\n    this._state = BEFORE_ATTRIBUTE_VALUE;\n  } else if (c === "/" || c === ">") {\n    this._cbs.onattribend();\n\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  } else if (!whitespace(c)) {\n    this._cbs.onattribend();\n\n    this._state = IN_ATTRIBUTE_NAME;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateBeforeAttributeValue = function (c) {\n  if (c === \'"\') {\n    this._state = IN_ATTRIBUTE_VALUE_DQ;\n    this._sectionStart = this._index + 1;\n  } else if (c === "\'") {\n    this._state = IN_ATTRIBUTE_VALUE_SQ;\n    this._sectionStart = this._index + 1;\n  } else if (!whitespace(c)) {\n    this._state = IN_ATTRIBUTE_VALUE_NQ;\n    this._sectionStart = this._index;\n    this._index--; //reconsume token\n  }\n};\n\nTokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) {\n  if (c === \'"\') {\n    this._emitToken("onattribdata");\n\n    this._cbs.onattribend();\n\n    this._state = BEFORE_ATTRIBUTE_NAME;\n  } else if (this._decodeEntities && c === "&") {\n    this._emitToken("onattribdata");\n\n    this._baseState = this._state;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) {\n  if (c === "\'") {\n    this._emitToken("onattribdata");\n\n    this._cbs.onattribend();\n\n    this._state = BEFORE_ATTRIBUTE_NAME;\n  } else if (this._decodeEntities && c === "&") {\n    this._emitToken("onattribdata");\n\n    this._baseState = this._state;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateInAttributeValueNoQuotes = function (c) {\n  if (whitespace(c) || c === ">") {\n    this._emitToken("onattribdata");\n\n    this._cbs.onattribend();\n\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  } else if (this._decodeEntities && c === "&") {\n    this._emitToken("onattribdata");\n\n    this._baseState = this._state;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\n\nTokenizer.prototype._stateBeforeDeclaration = function (c) {\n  this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;\n};\n\nTokenizer.prototype._stateInDeclaration = function (c) {\n  if (c === ">") {\n    this._cbs.ondeclaration(this._getSection());\n\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  }\n};\n\nTokenizer.prototype._stateInProcessingInstruction = function (c) {\n  if (c === ">") {\n    this._cbs.onprocessinginstruction(this._getSection());\n\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  }\n};\n\nTokenizer.prototype._stateBeforeComment = function (c) {\n  if (c === "-") {\n    this._state = IN_COMMENT;\n    this._sectionStart = this._index + 1;\n  } else {\n    this._state = IN_DECLARATION;\n  }\n};\n\nTokenizer.prototype._stateInComment = function (c) {\n  if (c === "-") this._state = AFTER_COMMENT_1;\n};\n\nTokenizer.prototype._stateAfterComment1 = function (c) {\n  if (c === "-") {\n    this._state = AFTER_COMMENT_2;\n  } else {\n    this._state = IN_COMMENT;\n  }\n};\n\nTokenizer.prototype._stateAfterComment2 = function (c) {\n  if (c === ">") {\n    //remove 2 trailing chars\n    this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));\n\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (c !== "-") {\n    this._state = IN_COMMENT;\n  } // else: stay in AFTER_COMMENT_2 (`---\x3e`)\n\n};\n\nTokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);\nTokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);\nTokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);\nTokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);\nTokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);\n\nTokenizer.prototype._stateBeforeCdata6 = function (c) {\n  if (c === "[") {\n    this._state = IN_CDATA;\n    this._sectionStart = this._index + 1;\n  } else {\n    this._state = IN_DECLARATION;\n    this._index--;\n  }\n};\n\nTokenizer.prototype._stateInCdata = function (c) {\n  if (c === "]") this._state = AFTER_CDATA_1;\n};\n\nTokenizer.prototype._stateAfterCdata1 = function (c) {\n  if (c === "]") this._state = AFTER_CDATA_2;else this._state = IN_CDATA;\n};\n\nTokenizer.prototype._stateAfterCdata2 = function (c) {\n  if (c === ">") {\n    //remove 2 trailing chars\n    this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));\n\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (c !== "]") {\n    this._state = IN_CDATA;\n  } //else: stay in AFTER_CDATA_2 (`]]]>`)\n\n};\n\nTokenizer.prototype._stateBeforeSpecial = function (c) {\n  if (c === "c" || c === "C") {\n    this._state = BEFORE_SCRIPT_1;\n  } else if (c === "t" || c === "T") {\n    this._state = BEFORE_STYLE_1;\n  } else {\n    this._state = IN_TAG_NAME;\n    this._index--; //consume the token again\n  }\n};\n\nTokenizer.prototype._stateBeforeSpecialEnd = function (c) {\n  if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {\n    this._state = AFTER_SCRIPT_1;\n  } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {\n    this._state = AFTER_STYLE_1;\n  } else this._state = TEXT;\n};\n\nTokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);\nTokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);\nTokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);\nTokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);\n\nTokenizer.prototype._stateBeforeScript5 = function (c) {\n  if (c === "/" || c === ">" || whitespace(c)) {\n    this._special = SPECIAL_SCRIPT;\n  }\n\n  this._state = IN_TAG_NAME;\n  this._index--; //consume the token again\n};\n\nTokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);\nTokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);\nTokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);\nTokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);\n\nTokenizer.prototype._stateAfterScript5 = function (c) {\n  if (c === ">" || whitespace(c)) {\n    this._special = SPECIAL_NONE;\n    this._state = IN_CLOSING_TAG_NAME;\n    this._sectionStart = this._index - 6;\n    this._index--; //reconsume the token\n  } else this._state = TEXT;\n};\n\nTokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);\nTokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);\nTokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);\n\nTokenizer.prototype._stateBeforeStyle4 = function (c) {\n  if (c === "/" || c === ">" || whitespace(c)) {\n    this._special = SPECIAL_STYLE;\n  }\n\n  this._state = IN_TAG_NAME;\n  this._index--; //consume the token again\n};\n\nTokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);\nTokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);\nTokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);\n\nTokenizer.prototype._stateAfterStyle4 = function (c) {\n  if (c === ">" || whitespace(c)) {\n    this._special = SPECIAL_NONE;\n    this._state = IN_CLOSING_TAG_NAME;\n    this._sectionStart = this._index - 5;\n    this._index--; //reconsume the token\n  } else this._state = TEXT;\n};\n\nTokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);\nTokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY); //for entities terminated with a semicolon\n\nTokenizer.prototype._parseNamedEntityStrict = function () {\n  //offset = 1\n  if (this._sectionStart + 1 < this._index) {\n    var entity = this._buffer.substring(this._sectionStart + 1, this._index),\n        map = this._xmlMode ? xmlMap : entityMap;\n\n    if (map.hasOwnProperty(entity)) {\n      this._emitPartial(map[entity]);\n\n      this._sectionStart = this._index + 1;\n    }\n  }\n}; //parses legacy entities (without trailing semicolon)\n\n\nTokenizer.prototype._parseLegacyEntity = function () {\n  var start = this._sectionStart + 1,\n      limit = this._index - start;\n  if (limit > 6) limit = 6; //the max length of legacy entities is 6\n\n  while (limit >= 2) {\n    //the min length of legacy entities is 2\n    var entity = this._buffer.substr(start, limit);\n\n    if (legacyMap.hasOwnProperty(entity)) {\n      this._emitPartial(legacyMap[entity]);\n\n      this._sectionStart += limit + 1;\n      return;\n    } else {\n      limit--;\n    }\n  }\n};\n\nTokenizer.prototype._stateInNamedEntity = function (c) {\n  if (c === ";") {\n    this._parseNamedEntityStrict();\n\n    if (this._sectionStart + 1 < this._index && !this._xmlMode) {\n      this._parseLegacyEntity();\n    }\n\n    this._state = this._baseState;\n  } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {\n    if (this._xmlMode) ;else if (this._sectionStart + 1 === this._index) ;else if (this._baseState !== TEXT) {\n      if (c !== "=") {\n        this._parseNamedEntityStrict();\n      }\n    } else {\n      this._parseLegacyEntity();\n    }\n    this._state = this._baseState;\n    this._index--;\n  }\n};\n\nTokenizer.prototype._decodeNumericEntity = function (offset, base) {\n  var sectionStart = this._sectionStart + offset;\n\n  if (sectionStart !== this._index) {\n    //parse entity\n    var entity = this._buffer.substring(sectionStart, this._index);\n\n    var parsed = parseInt(entity, base);\n\n    this._emitPartial(decodeCodePoint(parsed));\n\n    this._sectionStart = this._index;\n  } else {\n    this._sectionStart--;\n  }\n\n  this._state = this._baseState;\n};\n\nTokenizer.prototype._stateInNumericEntity = function (c) {\n  if (c === ";") {\n    this._decodeNumericEntity(2, 10);\n\n    this._sectionStart++;\n  } else if (c < "0" || c > "9") {\n    if (!this._xmlMode) {\n      this._decodeNumericEntity(2, 10);\n    } else {\n      this._state = this._baseState;\n    }\n\n    this._index--;\n  }\n};\n\nTokenizer.prototype._stateInHexEntity = function (c) {\n  if (c === ";") {\n    this._decodeNumericEntity(3, 16);\n\n    this._sectionStart++;\n  } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {\n    if (!this._xmlMode) {\n      this._decodeNumericEntity(3, 16);\n    } else {\n      this._state = this._baseState;\n    }\n\n    this._index--;\n  }\n};\n\nTokenizer.prototype._cleanup = function () {\n  if (this._sectionStart < 0) {\n    this._buffer = "";\n    this._bufferOffset += this._index;\n    this._index = 0;\n  } else if (this._running) {\n    if (this._state === TEXT) {\n      if (this._sectionStart !== this._index) {\n        this._cbs.ontext(this._buffer.substr(this._sectionStart));\n      }\n\n      this._buffer = "";\n      this._bufferOffset += this._index;\n      this._index = 0;\n    } else if (this._sectionStart === this._index) {\n      //the section just started\n      this._buffer = "";\n      this._bufferOffset += this._index;\n      this._index = 0;\n    } else {\n      //remove everything unnecessary\n      this._buffer = this._buffer.substr(this._sectionStart);\n      this._index -= this._sectionStart;\n      this._bufferOffset += this._sectionStart;\n    }\n\n    this._sectionStart = 0;\n  }\n}; //TODO make events conditional\n\n\nTokenizer.prototype.write = function (chunk) {\n  if (this._ended) this._cbs.onerror(Error(".write() after done!"));\n  this._buffer += chunk;\n\n  this._parse();\n};\n\nTokenizer.prototype._parse = function () {\n  while (this._index < this._buffer.length && this._running) {\n    var c = this._buffer.charAt(this._index);\n\n    if (this._state === TEXT) {\n      this._stateText(c);\n    } else if (this._state === BEFORE_TAG_NAME) {\n      this._stateBeforeTagName(c);\n    } else if (this._state === IN_TAG_NAME) {\n      this._stateInTagName(c);\n    } else if (this._state === BEFORE_CLOSING_TAG_NAME) {\n      this._stateBeforeCloseingTagName(c);\n    } else if (this._state === IN_CLOSING_TAG_NAME) {\n      this._stateInCloseingTagName(c);\n    } else if (this._state === AFTER_CLOSING_TAG_NAME) {\n      this._stateAfterCloseingTagName(c);\n    } else if (this._state === IN_SELF_CLOSING_TAG) {\n      this._stateInSelfClosingTag(c);\n    } else if (this._state === BEFORE_ATTRIBUTE_NAME) {\n      /*\n      *\tattributes\n      */\n      this._stateBeforeAttributeName(c);\n    } else if (this._state === IN_ATTRIBUTE_NAME) {\n      this._stateInAttributeName(c);\n    } else if (this._state === AFTER_ATTRIBUTE_NAME) {\n      this._stateAfterAttributeName(c);\n    } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {\n      this._stateBeforeAttributeValue(c);\n    } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {\n      this._stateInAttributeValueDoubleQuotes(c);\n    } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {\n      this._stateInAttributeValueSingleQuotes(c);\n    } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {\n      this._stateInAttributeValueNoQuotes(c);\n    } else if (this._state === BEFORE_DECLARATION) {\n      /*\n      *\tdeclarations\n      */\n      this._stateBeforeDeclaration(c);\n    } else if (this._state === IN_DECLARATION) {\n      this._stateInDeclaration(c);\n    } else if (this._state === IN_PROCESSING_INSTRUCTION) {\n      /*\n      *\tprocessing instructions\n      */\n      this._stateInProcessingInstruction(c);\n    } else if (this._state === BEFORE_COMMENT) {\n      /*\n      *\tcomments\n      */\n      this._stateBeforeComment(c);\n    } else if (this._state === IN_COMMENT) {\n      this._stateInComment(c);\n    } else if (this._state === AFTER_COMMENT_1) {\n      this._stateAfterComment1(c);\n    } else if (this._state === AFTER_COMMENT_2) {\n      this._stateAfterComment2(c);\n    } else if (this._state === BEFORE_CDATA_1) {\n      /*\n      *\tcdata\n      */\n      this._stateBeforeCdata1(c);\n    } else if (this._state === BEFORE_CDATA_2) {\n      this._stateBeforeCdata2(c);\n    } else if (this._state === BEFORE_CDATA_3) {\n      this._stateBeforeCdata3(c);\n    } else if (this._state === BEFORE_CDATA_4) {\n      this._stateBeforeCdata4(c);\n    } else if (this._state === BEFORE_CDATA_5) {\n      this._stateBeforeCdata5(c);\n    } else if (this._state === BEFORE_CDATA_6) {\n      this._stateBeforeCdata6(c);\n    } else if (this._state === IN_CDATA) {\n      this._stateInCdata(c);\n    } else if (this._state === AFTER_CDATA_1) {\n      this._stateAfterCdata1(c);\n    } else if (this._state === AFTER_CDATA_2) {\n      this._stateAfterCdata2(c);\n    } else if (this._state === BEFORE_SPECIAL) {\n      /*\n      * special tags\n      */\n      this._stateBeforeSpecial(c);\n    } else if (this._state === BEFORE_SPECIAL_END) {\n      this._stateBeforeSpecialEnd(c);\n    } else if (this._state === BEFORE_SCRIPT_1) {\n      /*\n      * script\n      */\n      this._stateBeforeScript1(c);\n    } else if (this._state === BEFORE_SCRIPT_2) {\n      this._stateBeforeScript2(c);\n    } else if (this._state === BEFORE_SCRIPT_3) {\n      this._stateBeforeScript3(c);\n    } else if (this._state === BEFORE_SCRIPT_4) {\n      this._stateBeforeScript4(c);\n    } else if (this._state === BEFORE_SCRIPT_5) {\n      this._stateBeforeScript5(c);\n    } else if (this._state === AFTER_SCRIPT_1) {\n      this._stateAfterScript1(c);\n    } else if (this._state === AFTER_SCRIPT_2) {\n      this._stateAfterScript2(c);\n    } else if (this._state === AFTER_SCRIPT_3) {\n      this._stateAfterScript3(c);\n    } else if (this._state === AFTER_SCRIPT_4) {\n      this._stateAfterScript4(c);\n    } else if (this._state === AFTER_SCRIPT_5) {\n      this._stateAfterScript5(c);\n    } else if (this._state === BEFORE_STYLE_1) {\n      /*\n      * style\n      */\n      this._stateBeforeStyle1(c);\n    } else if (this._state === BEFORE_STYLE_2) {\n      this._stateBeforeStyle2(c);\n    } else if (this._state === BEFORE_STYLE_3) {\n      this._stateBeforeStyle3(c);\n    } else if (this._state === BEFORE_STYLE_4) {\n      this._stateBeforeStyle4(c);\n    } else if (this._state === AFTER_STYLE_1) {\n      this._stateAfterStyle1(c);\n    } else if (this._state === AFTER_STYLE_2) {\n      this._stateAfterStyle2(c);\n    } else if (this._state === AFTER_STYLE_3) {\n      this._stateAfterStyle3(c);\n    } else if (this._state === AFTER_STYLE_4) {\n      this._stateAfterStyle4(c);\n    } else if (this._state === BEFORE_ENTITY) {\n      /*\n      * entities\n      */\n      this._stateBeforeEntity(c);\n    } else if (this._state === BEFORE_NUMERIC_ENTITY) {\n      this._stateBeforeNumericEntity(c);\n    } else if (this._state === IN_NAMED_ENTITY) {\n      this._stateInNamedEntity(c);\n    } else if (this._state === IN_NUMERIC_ENTITY) {\n      this._stateInNumericEntity(c);\n    } else if (this._state === IN_HEX_ENTITY) {\n      this._stateInHexEntity(c);\n    } else {\n      this._cbs.onerror(Error("unknown _state"), this._state);\n    }\n\n    this._index++;\n  }\n\n  this._cleanup();\n};\n\nTokenizer.prototype.pause = function () {\n  this._running = false;\n};\n\nTokenizer.prototype.resume = function () {\n  this._running = true;\n\n  if (this._index < this._buffer.length) {\n    this._parse();\n  }\n\n  if (this._ended) {\n    this._finish();\n  }\n};\n\nTokenizer.prototype.end = function (chunk) {\n  if (this._ended) this._cbs.onerror(Error(".end() after done!"));\n  if (chunk) this.write(chunk);\n  this._ended = true;\n  if (this._running) this._finish();\n};\n\nTokenizer.prototype._finish = function () {\n  //if there is remaining data, emit it in a reasonable way\n  if (this._sectionStart < this._index) {\n    this._handleTrailingData();\n  }\n\n  this._cbs.onend();\n};\n\nTokenizer.prototype._handleTrailingData = function () {\n  var data = this._buffer.substr(this._sectionStart);\n\n  if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {\n    this._cbs.oncdata(data);\n  } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {\n    this._cbs.oncomment(data);\n  } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {\n    this._parseLegacyEntity();\n\n    if (this._sectionStart < this._index) {\n      this._state = this._baseState;\n\n      this._handleTrailingData();\n    }\n  } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {\n    this._decodeNumericEntity(2, 10);\n\n    if (this._sectionStart < this._index) {\n      this._state = this._baseState;\n\n      this._handleTrailingData();\n    }\n  } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {\n    this._decodeNumericEntity(3, 16);\n\n    if (this._sectionStart < this._index) {\n      this._state = this._baseState;\n\n      this._handleTrailingData();\n    }\n  } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {\n    this._cbs.ontext(data);\n  } //else, ignore remaining data\n  //TODO add a way to remove current tag\n\n};\n\nTokenizer.prototype.reset = function () {\n  Tokenizer.call(this, {\n    xmlMode: this._xmlMode,\n    decodeEntities: this._decodeEntities\n  }, this._cbs);\n};\n\nTokenizer.prototype.getAbsoluteIndex = function () {\n  return this._bufferOffset + this._index;\n};\n\nTokenizer.prototype._getSection = function () {\n  return this._buffer.substring(this._sectionStart, this._index);\n};\n\nTokenizer.prototype._emitToken = function (name) {\n  this._cbs[name](this._getSection());\n\n  this._sectionStart = -1;\n};\n\nTokenizer.prototype._emitPartial = function (value) {\n  if (this._baseState !== TEXT) {\n    this._cbs.onattribdata(value); //TODO implement the new event\n\n  } else {\n    this._cbs.ontext(value);\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/Tokenizer.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/WritableStream.js":function(module,exports,__webpack_require__){eval('module.exports = Stream;\n\nvar Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/Parser.js");\n\nvar WritableStream = __webpack_require__(/*! readable-stream */ 1).Writable;\n\nvar StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/webpack/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;\n\nvar Buffer = __webpack_require__(/*! buffer */ "./node_modules/webpack/node_modules/buffer/index.js").Buffer;\n\nfunction Stream(cbs, options) {\n  var parser = this._parser = new Parser(cbs, options);\n  var decoder = this._decoder = new StringDecoder();\n  WritableStream.call(this, {\n    decodeStrings: false\n  });\n  this.once("finish", function () {\n    parser.end(decoder.end());\n  });\n}\n\n__webpack_require__(/*! inherits */ "./node_modules/react-html-parser/node_modules/inherits/inherits_browser.js")(Stream, WritableStream);\n\nStream.prototype._write = function (chunk, encoding, cb) {\n  if (chunk instanceof Buffer) chunk = this._decoder.write(chunk);\n\n  this._parser.write(chunk);\n\n  cb();\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/WritableStream.js?')},"./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js":function(module,exports,__webpack_require__){eval('var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/Parser.js");\n\nvar DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/react-html-parser/node_modules/domhandler/index.js");\n\nfunction defineProp(name, value) {\n  delete module.exports[name];\n  module.exports[name] = value;\n  return value;\n}\n\nmodule.exports = {\n  Parser: Parser,\n  Tokenizer: __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/Tokenizer.js"),\n  ElementType: __webpack_require__(/*! domelementtype */ "./node_modules/react-html-parser/node_modules/domelementtype/index.js"),\n  DomHandler: DomHandler,\n\n  get FeedHandler() {\n    return defineProp("FeedHandler", __webpack_require__(/*! ./FeedHandler.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/FeedHandler.js"));\n  },\n\n  get Stream() {\n    return defineProp("Stream", __webpack_require__(/*! ./Stream.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/Stream.js"));\n  },\n\n  get WritableStream() {\n    return defineProp("WritableStream", __webpack_require__(/*! ./WritableStream.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/WritableStream.js"));\n  },\n\n  get ProxyHandler() {\n    return defineProp("ProxyHandler", __webpack_require__(/*! ./ProxyHandler.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/ProxyHandler.js"));\n  },\n\n  get DomUtils() {\n    return defineProp("DomUtils", __webpack_require__(/*! domutils */ "./node_modules/react-html-parser/node_modules/domutils/index.js"));\n  },\n\n  get CollectingHandler() {\n    return defineProp("CollectingHandler", __webpack_require__(/*! ./CollectingHandler.js */ "./node_modules/react-html-parser/node_modules/htmlparser2/lib/CollectingHandler.js"));\n  },\n\n  // For legacy support\n  DefaultHandler: DomHandler,\n\n  get RssHandler() {\n    return defineProp("RssHandler", this.FeedHandler);\n  },\n\n  //helper methods\n  parseDOM: function parseDOM(data, options) {\n    var handler = new DomHandler(options);\n    new Parser(handler, options).end(data);\n    return handler.dom;\n  },\n  parseFeed: function parseFeed(feed, options) {\n    var handler = new module.exports.FeedHandler(options);\n    new Parser(handler, options).end(feed);\n    return handler.dom;\n  },\n  createDomStream: function createDomStream(cb, options, elementCb) {\n    var handler = new DomHandler(cb, options, elementCb);\n    return new Parser(handler, options);\n  },\n  // List of all events that the parser emits\n  EVENTS: {\n    /* Format: eventname: number of arguments */\n    attribute: 2,\n    cdatastart: 0,\n    cdataend: 0,\n    text: 1,\n    processinginstruction: 2,\n    comment: 1,\n    commentend: 0,\n    closetag: 1,\n    opentag: 2,\n    opentagname: 1,\n    error: 1,\n    end: 0\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/htmlparser2/lib/index.js?')},"./node_modules/react-html-parser/node_modules/inherits/inherits_browser.js":function(module,exports){eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n\n      var TempCtor = function TempCtor() {};\n\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/react-html-parser/node_modules/inherits/inherits_browser.js?")},"./node_modules/redux-thunk/es/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\nfunction createThunkMiddleware(extraArgument) {\n  return function (_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nvar thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n/* harmony default export */ __webpack_exports__[\"default\"] = (thunk);\n\n//# sourceURL=webpack:///./node_modules/redux-thunk/es/index.js?")},"./node_modules/redux/es/redux.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return createStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return combineReducers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return bindActionCreators; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return applyMiddleware; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return ActionTypes; });\n/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "./node_modules/redux/node_modules/symbol-observable/es/index.js");\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split(\'\').join(\'.\');\n};\n\nvar ActionTypes = {\n  INIT: "@@redux/INIT" + randomString(),\n  REPLACE: "@@redux/REPLACE" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();\n  }\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\n\nfunction isPlainObject(obj) {\n  if (_typeof(obj) !== \'object\' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'function\' || typeof enhancer === \'function\' && typeof arguments[3] === \'function\') {\n    throw new Error(\'It looks like you are passing several store enhancers to \' + \'createStore(). This is not supported. Instead, compose them \' + \'together to a single function\');\n  }\n\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== \'function\') {\n    throw new Error(\'Expected the reducer to be a function.\');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(\'You may not call store.getState() while the reducer is executing. \' + \'The reducer has already received the state as an argument. \' + \'Pass it down from the top reducer instead of reading it from the store.\');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== \'function\') {\n      throw new Error(\'Expected the listener to be a function.\');\n    }\n\n    if (isDispatching) {\n      throw new Error(\'You may not call store.subscribe() while the reducer is executing. \' + \'If you would like to be notified after the store has been updated, subscribe from a \' + \'component and invoke store.getState() in the callback to access the latest state. \' + \'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(\'You may not unsubscribe from a store listener while the reducer is executing. \' + \'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(\'Actions must be plain objects. \' + \'Use custom middleware for async actions.\');\n    }\n\n    if (typeof action.type === \'undefined\') {\n      throw new Error(\'Actions may not have an undefined "type" property. \' + \'Have you misspelled a constant?\');\n    }\n\n    if (isDispatching) {\n      throw new Error(\'Reducers may not dispatch actions.\');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \'function\') {\n      throw new Error(\'Expected the nextReducer to be a function.\');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (_typeof(observer) !== \'object\' || observer === null) {\n          throw new TypeError(\'Expected the observer to be an object.\');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an "INIT" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = observable, _ref2;\n}\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\n\n\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== \'undefined\' && typeof console.error === \'function\') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // "break on all exceptions" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && "action \\"" + String(actionType) + "\\"" || \'an action\';\n  return "Given " + actionDescription + ", reducer \\"" + key + "\\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? \'preloadedState argument passed to createStore\' : \'previous state received by the reducer\';\n\n  if (reducerKeys.length === 0) {\n    return \'Store does not have a valid reducer. Make sure the argument passed \' + \'to combineReducers is an object whose values are reducers.\';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return "The " + argumentName + " has unexpected type of \\"" + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + "\\". Expected argument to be an object with the following " + ("keys: \\"" + reducerKeys.join(\'", "\') + "\\"");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return "Unexpected " + (unexpectedKeys.length > 1 ? \'keys\' : \'key\') + " " + ("\\"" + unexpectedKeys.join(\'", "\') + "\\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\\"" + reducerKeys.join(\'", "\') + "\\". Unexpected keys will be ignored.");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === \'undefined\') {\n      throw new Error("Reducer \\"" + key + "\\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don\'t want to set a value for this reducer, " + "you can use null instead of undefined.");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === \'undefined\') {\n      throw new Error("Reducer \\"" + key + "\\" returned undefined when probed with a random type. " + ("Don\'t try to handle " + ActionTypes.INIT + " or other actions in \\"redux/*\\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {}\n\n    if (typeof reducers[key] === \'function\') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers);\n  var unexpectedKeyCache;\n\n  if (false) {}\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (false) { var warningMessage; }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === \'undefined\') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \'function\') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (_typeof(actionCreators) !== \'object\' || actionCreators === null) {\n    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? \'null\' : _typeof(actionCreators)) + ". " + "Did you write \\"import ActionCreators from\\" instead of \\"import * as ActionCreators from\\"?");\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === \'function\') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \'function\') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== \'production\', warn the user.\n */\n\n\nfunction isCrushed() {}\n\nif (false) {}\n\n\n\n//# sourceURL=webpack:///./node_modules/redux/es/redux.js?')},"./node_modules/redux/node_modules/symbol-observable/es/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/redux/node_modules/symbol-observable/es/ponyfill.js");\n/* global window */\n\nvar root;\n\nif (typeof self !== \'undefined\') {\n  root = self;\n} else if (typeof window !== \'undefined\') {\n  root = window;\n} else if (typeof global !== \'undefined\') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);\n/* harmony default export */ __webpack_exports__["default"] = (result);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))\n\n//# sourceURL=webpack:///./node_modules/redux/node_modules/symbol-observable/es/index.js?')},"./node_modules/redux/node_modules/symbol-observable/es/ponyfill.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return symbolObservablePonyfill; });\nfunction symbolObservablePonyfill(root) {\n  var result;\n  var _Symbol = root.Symbol;\n\n  if (typeof _Symbol === 'function') {\n    if (_Symbol.observable) {\n      result = _Symbol.observable;\n    } else {\n      result = _Symbol('observable');\n      _Symbol.observable = result;\n    }\n  } else {\n    result = '@@observable';\n  }\n\n  return result;\n}\n;\n\n//# sourceURL=webpack:///./node_modules/redux/node_modules/symbol-observable/es/ponyfill.js?")},"./node_modules/scroll-js/dist/scroll.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (f) {\n  if (( false ? undefined : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var g; }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return require(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      (function (process, global) {\n        /*!\n         * @overview es6-promise - a tiny implementation of Promises/A+.\n         * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n         * @license   Licensed under MIT license\n         *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n         * @version   v4.2.4+314e4831\n         */\n        (function (global, factory) {\n          _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ES6Promise = factory();\n        })(this, function () {\n          'use strict';\n\n          function objectOrFunction(x) {\n            var type = _typeof(x);\n\n            return x !== null && (type === 'object' || type === 'function');\n          }\n\n          function isFunction(x) {\n            return typeof x === 'function';\n          }\n\n          var _isArray = void 0;\n\n          if (Array.isArray) {\n            _isArray = Array.isArray;\n          } else {\n            _isArray = function _isArray(x) {\n              return Object.prototype.toString.call(x) === '[object Array]';\n            };\n          }\n\n          var isArray = _isArray;\n          var len = 0;\n          var vertxNext = void 0;\n          var customSchedulerFn = void 0;\n\n          var asap = function asap(callback, arg) {\n            queue[len] = callback;\n            queue[len + 1] = arg;\n            len += 2;\n\n            if (len === 2) {\n              // If len is 2, that means that we need to schedule an async flush.\n              // If additional callbacks are queued before the queue is flushed, they\n              // will be processed by this flush that we are scheduling.\n              if (customSchedulerFn) {\n                customSchedulerFn(flush);\n              } else {\n                scheduleFlush();\n              }\n            }\n          };\n\n          function setScheduler(scheduleFn) {\n            customSchedulerFn = scheduleFn;\n          }\n\n          function setAsap(asapFn) {\n            asap = asapFn;\n          }\n\n          var browserWindow = typeof window !== 'undefined' ? window : undefined;\n          var browserGlobal = browserWindow || {};\n          var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n          var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10\n\n          var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node\n\n          function useNextTick() {\n            // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n            // see https://github.com/cujojs/when/issues/410 for details\n            return function () {\n              return process.nextTick(flush);\n            };\n          } // vertx\n\n\n          function useVertxTimer() {\n            if (typeof vertxNext !== 'undefined') {\n              return function () {\n                vertxNext(flush);\n              };\n            }\n\n            return useSetTimeout();\n          }\n\n          function useMutationObserver() {\n            var iterations = 0;\n            var observer = new BrowserMutationObserver(flush);\n            var node = document.createTextNode('');\n            observer.observe(node, {\n              characterData: true\n            });\n            return function () {\n              node.data = iterations = ++iterations % 2;\n            };\n          } // web worker\n\n\n          function useMessageChannel() {\n            var channel = new MessageChannel();\n            channel.port1.onmessage = flush;\n            return function () {\n              return channel.port2.postMessage(0);\n            };\n          }\n\n          function useSetTimeout() {\n            // Store setTimeout reference so es6-promise will be unaffected by\n            // other code modifying setTimeout (like sinon.useFakeTimers())\n            var globalSetTimeout = setTimeout;\n            return function () {\n              return globalSetTimeout(flush, 1);\n            };\n          }\n\n          var queue = new Array(1000);\n\n          function flush() {\n            for (var i = 0; i < len; i += 2) {\n              var callback = queue[i];\n              var arg = queue[i + 1];\n              callback(arg);\n              queue[i] = undefined;\n              queue[i + 1] = undefined;\n            }\n\n            len = 0;\n          }\n\n          function attemptVertx() {\n            try {\n              var vertx = Function('return this')().require('vertx');\n\n              vertxNext = vertx.runOnLoop || vertx.runOnContext;\n              return useVertxTimer();\n            } catch (e) {\n              return useSetTimeout();\n            }\n          }\n\n          var scheduleFlush = void 0; // Decide what async method to use to triggering processing of queued callbacks:\n\n          if (isNode) {\n            scheduleFlush = useNextTick();\n          } else if (BrowserMutationObserver) {\n            scheduleFlush = useMutationObserver();\n          } else if (isWorker) {\n            scheduleFlush = useMessageChannel();\n          } else if (browserWindow === undefined && typeof require === 'function') {\n            scheduleFlush = attemptVertx();\n          } else {\n            scheduleFlush = useSetTimeout();\n          }\n\n          function then(onFulfillment, onRejection) {\n            var parent = this;\n            var child = new this.constructor(noop);\n\n            if (child[PROMISE_ID] === undefined) {\n              makePromise(child);\n            }\n\n            var _state = parent._state;\n\n            if (_state) {\n              var callback = arguments[_state - 1];\n              asap(function () {\n                return invokeCallback(_state, child, callback, parent._result);\n              });\n            } else {\n              subscribe(parent, child, onFulfillment, onRejection);\n            }\n\n            return child;\n          }\n          /**\n            `Promise.resolve` returns a promise that will become resolved with the\n            passed `value`. It is shorthand for the following:\n          \n            ```javascript\n            let promise = new Promise(function(resolve, reject){\n              resolve(1);\n            });\n          \n            promise.then(function(value){\n              // value === 1\n            });\n            ```\n          \n            Instead of writing the above, your code now simply becomes the following:\n          \n            ```javascript\n            let promise = Promise.resolve(1);\n          \n            promise.then(function(value){\n              // value === 1\n            });\n            ```\n          \n            @method resolve\n            @static\n            @param {Any} value value that the returned promise will be resolved with\n            Useful for tooling.\n            @return {Promise} a promise that will become fulfilled with the given\n            `value`\n          */\n\n\n          function resolve$1(object) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (object && _typeof(object) === 'object' && object.constructor === Constructor) {\n              return object;\n            }\n\n            var promise = new Constructor(noop);\n            resolve(promise, object);\n            return promise;\n          }\n\n          var PROMISE_ID = Math.random().toString(36).substring(2);\n\n          function noop() {}\n\n          var PENDING = void 0;\n          var FULFILLED = 1;\n          var REJECTED = 2;\n          var TRY_CATCH_ERROR = {\n            error: null\n          };\n\n          function selfFulfillment() {\n            return new TypeError(\"You cannot resolve a promise with itself\");\n          }\n\n          function cannotReturnOwn() {\n            return new TypeError('A promises callback cannot return that same promise.');\n          }\n\n          function getThen(promise) {\n            try {\n              return promise.then;\n            } catch (error) {\n              TRY_CATCH_ERROR.error = error;\n              return TRY_CATCH_ERROR;\n            }\n          }\n\n          function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n            try {\n              then$$1.call(value, fulfillmentHandler, rejectionHandler);\n            } catch (e) {\n              return e;\n            }\n          }\n\n          function handleForeignThenable(promise, thenable, then$$1) {\n            asap(function (promise) {\n              var sealed = false;\n              var error = tryThen(then$$1, thenable, function (value) {\n                if (sealed) {\n                  return;\n                }\n\n                sealed = true;\n\n                if (thenable !== value) {\n                  resolve(promise, value);\n                } else {\n                  fulfill(promise, value);\n                }\n              }, function (reason) {\n                if (sealed) {\n                  return;\n                }\n\n                sealed = true;\n                reject(promise, reason);\n              }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n              if (!sealed && error) {\n                sealed = true;\n                reject(promise, error);\n              }\n            }, promise);\n          }\n\n          function handleOwnThenable(promise, thenable) {\n            if (thenable._state === FULFILLED) {\n              fulfill(promise, thenable._result);\n            } else if (thenable._state === REJECTED) {\n              reject(promise, thenable._result);\n            } else {\n              subscribe(thenable, undefined, function (value) {\n                return resolve(promise, value);\n              }, function (reason) {\n                return reject(promise, reason);\n              });\n            }\n          }\n\n          function handleMaybeThenable(promise, maybeThenable, then$$1) {\n            if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n              handleOwnThenable(promise, maybeThenable);\n            } else {\n              if (then$$1 === TRY_CATCH_ERROR) {\n                reject(promise, TRY_CATCH_ERROR.error);\n                TRY_CATCH_ERROR.error = null;\n              } else if (then$$1 === undefined) {\n                fulfill(promise, maybeThenable);\n              } else if (isFunction(then$$1)) {\n                handleForeignThenable(promise, maybeThenable, then$$1);\n              } else {\n                fulfill(promise, maybeThenable);\n              }\n            }\n          }\n\n          function resolve(promise, value) {\n            if (promise === value) {\n              reject(promise, selfFulfillment());\n            } else if (objectOrFunction(value)) {\n              handleMaybeThenable(promise, value, getThen(value));\n            } else {\n              fulfill(promise, value);\n            }\n          }\n\n          function publishRejection(promise) {\n            if (promise._onerror) {\n              promise._onerror(promise._result);\n            }\n\n            publish(promise);\n          }\n\n          function fulfill(promise, value) {\n            if (promise._state !== PENDING) {\n              return;\n            }\n\n            promise._result = value;\n            promise._state = FULFILLED;\n\n            if (promise._subscribers.length !== 0) {\n              asap(publish, promise);\n            }\n          }\n\n          function reject(promise, reason) {\n            if (promise._state !== PENDING) {\n              return;\n            }\n\n            promise._state = REJECTED;\n            promise._result = reason;\n            asap(publishRejection, promise);\n          }\n\n          function subscribe(parent, child, onFulfillment, onRejection) {\n            var _subscribers = parent._subscribers;\n            var length = _subscribers.length;\n            parent._onerror = null;\n            _subscribers[length] = child;\n            _subscribers[length + FULFILLED] = onFulfillment;\n            _subscribers[length + REJECTED] = onRejection;\n\n            if (length === 0 && parent._state) {\n              asap(publish, parent);\n            }\n          }\n\n          function publish(promise) {\n            var subscribers = promise._subscribers;\n            var settled = promise._state;\n\n            if (subscribers.length === 0) {\n              return;\n            }\n\n            var child = void 0,\n                callback = void 0,\n                detail = promise._result;\n\n            for (var i = 0; i < subscribers.length; i += 3) {\n              child = subscribers[i];\n              callback = subscribers[i + settled];\n\n              if (child) {\n                invokeCallback(settled, child, callback, detail);\n              } else {\n                callback(detail);\n              }\n            }\n\n            promise._subscribers.length = 0;\n          }\n\n          function tryCatch(callback, detail) {\n            try {\n              return callback(detail);\n            } catch (e) {\n              TRY_CATCH_ERROR.error = e;\n              return TRY_CATCH_ERROR;\n            }\n          }\n\n          function invokeCallback(settled, promise, callback, detail) {\n            var hasCallback = isFunction(callback),\n                value = void 0,\n                error = void 0,\n                succeeded = void 0,\n                failed = void 0;\n\n            if (hasCallback) {\n              value = tryCatch(callback, detail);\n\n              if (value === TRY_CATCH_ERROR) {\n                failed = true;\n                error = value.error;\n                value.error = null;\n              } else {\n                succeeded = true;\n              }\n\n              if (promise === value) {\n                reject(promise, cannotReturnOwn());\n                return;\n              }\n            } else {\n              value = detail;\n              succeeded = true;\n            }\n\n            if (promise._state !== PENDING) {// noop\n            } else if (hasCallback && succeeded) {\n              resolve(promise, value);\n            } else if (failed) {\n              reject(promise, error);\n            } else if (settled === FULFILLED) {\n              fulfill(promise, value);\n            } else if (settled === REJECTED) {\n              reject(promise, value);\n            }\n          }\n\n          function initializePromise(promise, resolver) {\n            try {\n              resolver(function resolvePromise(value) {\n                resolve(promise, value);\n              }, function rejectPromise(reason) {\n                reject(promise, reason);\n              });\n            } catch (e) {\n              reject(promise, e);\n            }\n          }\n\n          var id = 0;\n\n          function nextId() {\n            return id++;\n          }\n\n          function makePromise(promise) {\n            promise[PROMISE_ID] = id++;\n            promise._state = undefined;\n            promise._result = undefined;\n            promise._subscribers = [];\n          }\n\n          function validationError() {\n            return new Error('Array Methods must be provided an Array');\n          }\n\n          var Enumerator = function () {\n            function Enumerator(Constructor, input) {\n              this._instanceConstructor = Constructor;\n              this.promise = new Constructor(noop);\n\n              if (!this.promise[PROMISE_ID]) {\n                makePromise(this.promise);\n              }\n\n              if (isArray(input)) {\n                this.length = input.length;\n                this._remaining = input.length;\n                this._result = new Array(this.length);\n\n                if (this.length === 0) {\n                  fulfill(this.promise, this._result);\n                } else {\n                  this.length = this.length || 0;\n\n                  this._enumerate(input);\n\n                  if (this._remaining === 0) {\n                    fulfill(this.promise, this._result);\n                  }\n                }\n              } else {\n                reject(this.promise, validationError());\n              }\n            }\n\n            Enumerator.prototype._enumerate = function _enumerate(input) {\n              for (var i = 0; this._state === PENDING && i < input.length; i++) {\n                this._eachEntry(input[i], i);\n              }\n            };\n\n            Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n              var c = this._instanceConstructor;\n              var resolve$$1 = c.resolve;\n\n              if (resolve$$1 === resolve$1) {\n                var _then = getThen(entry);\n\n                if (_then === then && entry._state !== PENDING) {\n                  this._settledAt(entry._state, i, entry._result);\n                } else if (typeof _then !== 'function') {\n                  this._remaining--;\n                  this._result[i] = entry;\n                } else if (c === Promise$1) {\n                  var promise = new c(noop);\n                  handleMaybeThenable(promise, entry, _then);\n\n                  this._willSettleAt(promise, i);\n                } else {\n                  this._willSettleAt(new c(function (resolve$$1) {\n                    return resolve$$1(entry);\n                  }), i);\n                }\n              } else {\n                this._willSettleAt(resolve$$1(entry), i);\n              }\n            };\n\n            Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n              var promise = this.promise;\n\n              if (promise._state === PENDING) {\n                this._remaining--;\n\n                if (state === REJECTED) {\n                  reject(promise, value);\n                } else {\n                  this._result[i] = value;\n                }\n              }\n\n              if (this._remaining === 0) {\n                fulfill(promise, this._result);\n              }\n            };\n\n            Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n              var enumerator = this;\n              subscribe(promise, undefined, function (value) {\n                return enumerator._settledAt(FULFILLED, i, value);\n              }, function (reason) {\n                return enumerator._settledAt(REJECTED, i, reason);\n              });\n            };\n\n            return Enumerator;\n          }();\n          /**\n            `Promise.all` accepts an array of promises, and returns a new promise which\n            is fulfilled with an array of fulfillment values for the passed promises, or\n            rejected with the reason of the first passed promise to be rejected. It casts all\n            elements of the passed iterable to promises as it runs this algorithm.\n          \n            Example:\n          \n            ```javascript\n            let promise1 = resolve(1);\n            let promise2 = resolve(2);\n            let promise3 = resolve(3);\n            let promises = [ promise1, promise2, promise3 ];\n          \n            Promise.all(promises).then(function(array){\n              // The array here would be [ 1, 2, 3 ];\n            });\n            ```\n          \n            If any of the `promises` given to `all` are rejected, the first promise\n            that is rejected will be given as an argument to the returned promises's\n            rejection handler. For example:\n          \n            Example:\n          \n            ```javascript\n            let promise1 = resolve(1);\n            let promise2 = reject(new Error(\"2\"));\n            let promise3 = reject(new Error(\"3\"));\n            let promises = [ promise1, promise2, promise3 ];\n          \n            Promise.all(promises).then(function(array){\n              // Code here never runs because there are rejected promises!\n            }, function(error) {\n              // error.message === \"2\"\n            });\n            ```\n          \n            @method all\n            @static\n            @param {Array} entries array of promises\n            @param {String} label optional string for labeling the promise.\n            Useful for tooling.\n            @return {Promise} promise that is fulfilled when all `promises` have been\n            fulfilled, or rejected if any of them become rejected.\n            @static\n          */\n\n\n          function all(entries) {\n            return new Enumerator(this, entries).promise;\n          }\n          /**\n            `Promise.race` returns a new promise which is settled in the same way as the\n            first passed promise to settle.\n          \n            Example:\n          \n            ```javascript\n            let promise1 = new Promise(function(resolve, reject){\n              setTimeout(function(){\n                resolve('promise 1');\n              }, 200);\n            });\n          \n            let promise2 = new Promise(function(resolve, reject){\n              setTimeout(function(){\n                resolve('promise 2');\n              }, 100);\n            });\n          \n            Promise.race([promise1, promise2]).then(function(result){\n              // result === 'promise 2' because it was resolved before promise1\n              // was resolved.\n            });\n            ```\n          \n            `Promise.race` is deterministic in that only the state of the first\n            settled promise matters. For example, even if other promises given to the\n            `promises` array argument are resolved, but the first settled promise has\n            become rejected before the other promises became fulfilled, the returned\n            promise will become rejected:\n          \n            ```javascript\n            let promise1 = new Promise(function(resolve, reject){\n              setTimeout(function(){\n                resolve('promise 1');\n              }, 200);\n            });\n          \n            let promise2 = new Promise(function(resolve, reject){\n              setTimeout(function(){\n                reject(new Error('promise 2'));\n              }, 100);\n            });\n          \n            Promise.race([promise1, promise2]).then(function(result){\n              // Code here never runs\n            }, function(reason){\n              // reason.message === 'promise 2' because promise 2 became rejected before\n              // promise 1 became fulfilled\n            });\n            ```\n          \n            An example real-world use case is implementing timeouts:\n          \n            ```javascript\n            Promise.race([ajax('foo.json'), timeout(5000)])\n            ```\n          \n            @method race\n            @static\n            @param {Array} promises array of promises to observe\n            Useful for tooling.\n            @return {Promise} a promise which settles in the same way as the first passed\n            promise to settle.\n          */\n\n\n          function race(entries) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (!isArray(entries)) {\n              return new Constructor(function (_, reject) {\n                return reject(new TypeError('You must pass an array to race.'));\n              });\n            } else {\n              return new Constructor(function (resolve, reject) {\n                var length = entries.length;\n\n                for (var i = 0; i < length; i++) {\n                  Constructor.resolve(entries[i]).then(resolve, reject);\n                }\n              });\n            }\n          }\n          /**\n            `Promise.reject` returns a promise rejected with the passed `reason`.\n            It is shorthand for the following:\n          \n            ```javascript\n            let promise = new Promise(function(resolve, reject){\n              reject(new Error('WHOOPS'));\n            });\n          \n            promise.then(function(value){\n              // Code here doesn't run because the promise is rejected!\n            }, function(reason){\n              // reason.message === 'WHOOPS'\n            });\n            ```\n          \n            Instead of writing the above, your code now simply becomes the following:\n          \n            ```javascript\n            let promise = Promise.reject(new Error('WHOOPS'));\n          \n            promise.then(function(value){\n              // Code here doesn't run because the promise is rejected!\n            }, function(reason){\n              // reason.message === 'WHOOPS'\n            });\n            ```\n          \n            @method reject\n            @static\n            @param {Any} reason value that the returned promise will be rejected with.\n            Useful for tooling.\n            @return {Promise} a promise rejected with the given `reason`.\n          */\n\n\n          function reject$1(reason) {\n            /*jshint validthis:true */\n            var Constructor = this;\n            var promise = new Constructor(noop);\n            reject(promise, reason);\n            return promise;\n          }\n\n          function needsResolver() {\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n          }\n\n          function needsNew() {\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n          }\n          /**\n            Promise objects represent the eventual result of an asynchronous operation. The\n            primary way of interacting with a promise is through its `then` method, which\n            registers callbacks to receive either a promise's eventual value or the reason\n            why the promise cannot be fulfilled.\n          \n            Terminology\n            -----------\n          \n            - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n            - `thenable` is an object or function that defines a `then` method.\n            - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n            - `exception` is a value that is thrown using the throw statement.\n            - `reason` is a value that indicates why a promise was rejected.\n            - `settled` the final resting state of a promise, fulfilled or rejected.\n          \n            A promise can be in one of three states: pending, fulfilled, or rejected.\n          \n            Promises that are fulfilled have a fulfillment value and are in the fulfilled\n            state.  Promises that are rejected have a rejection reason and are in the\n            rejected state.  A fulfillment value is never a thenable.\n          \n            Promises can also be said to *resolve* a value.  If this value is also a\n            promise, then the original promise's settled state will match the value's\n            settled state.  So a promise that *resolves* a promise that rejects will\n            itself reject, and a promise that *resolves* a promise that fulfills will\n            itself fulfill.\n          \n          \n            Basic Usage:\n            ------------\n          \n            ```js\n            let promise = new Promise(function(resolve, reject) {\n              // on success\n              resolve(value);\n          \n              // on failure\n              reject(reason);\n            });\n          \n            promise.then(function(value) {\n              // on fulfillment\n            }, function(reason) {\n              // on rejection\n            });\n            ```\n          \n            Advanced Usage:\n            ---------------\n          \n            Promises shine when abstracting away asynchronous interactions such as\n            `XMLHttpRequest`s.\n          \n            ```js\n            function getJSON(url) {\n              return new Promise(function(resolve, reject){\n                let xhr = new XMLHttpRequest();\n          \n                xhr.open('GET', url);\n                xhr.onreadystatechange = handler;\n                xhr.responseType = 'json';\n                xhr.setRequestHeader('Accept', 'application/json');\n                xhr.send();\n          \n                function handler() {\n                  if (this.readyState === this.DONE) {\n                    if (this.status === 200) {\n                      resolve(this.response);\n                    } else {\n                      reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n                    }\n                  }\n                };\n              });\n            }\n          \n            getJSON('/posts.json').then(function(json) {\n              // on fulfillment\n            }, function(reason) {\n              // on rejection\n            });\n            ```\n          \n            Unlike callbacks, promises are great composable primitives.\n          \n            ```js\n            Promise.all([\n              getJSON('/posts'),\n              getJSON('/comments')\n            ]).then(function(values){\n              values[0] // => postsJSON\n              values[1] // => commentsJSON\n          \n              return values;\n            });\n            ```\n          \n            @class Promise\n            @param {Function} resolver\n            Useful for tooling.\n            @constructor\n          */\n\n\n          var Promise$1 = function () {\n            function Promise(resolver) {\n              this[PROMISE_ID] = nextId();\n              this._result = this._state = undefined;\n              this._subscribers = [];\n\n              if (noop !== resolver) {\n                typeof resolver !== 'function' && needsResolver();\n                this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n              }\n            }\n            /**\n            The primary way of interacting with a promise is through its `then` method,\n            which registers callbacks to receive either a promise's eventual value or the\n            reason why the promise cannot be fulfilled.\n             ```js\n            findUser().then(function(user){\n              // user is available\n            }, function(reason){\n              // user is unavailable, and you are given the reason why\n            });\n            ```\n             Chaining\n            --------\n             The return value of `then` is itself a promise.  This second, 'downstream'\n            promise is resolved with the return value of the first promise's fulfillment\n            or rejection handler, or rejected if the handler throws an exception.\n             ```js\n            findUser().then(function (user) {\n              return user.name;\n            }, function (reason) {\n              return 'default name';\n            }).then(function (userName) {\n              // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n              // will be `'default name'`\n            });\n             findUser().then(function (user) {\n              throw new Error('Found user, but still unhappy');\n            }, function (reason) {\n              throw new Error('`findUser` rejected and we're unhappy');\n            }).then(function (value) {\n              // never reached\n            }, function (reason) {\n              // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n              // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n            });\n            ```\n            If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n             ```js\n            findUser().then(function (user) {\n              throw new PedagogicalException('Upstream error');\n            }).then(function (value) {\n              // never reached\n            }).then(function (value) {\n              // never reached\n            }, function (reason) {\n              // The `PedgagocialException` is propagated all the way down to here\n            });\n            ```\n             Assimilation\n            ------------\n             Sometimes the value you want to propagate to a downstream promise can only be\n            retrieved asynchronously. This can be achieved by returning a promise in the\n            fulfillment or rejection handler. The downstream promise will then be pending\n            until the returned promise is settled. This is called *assimilation*.\n             ```js\n            findUser().then(function (user) {\n              return findCommentsByAuthor(user);\n            }).then(function (comments) {\n              // The user's comments are now available\n            });\n            ```\n             If the assimliated promise rejects, then the downstream promise will also reject.\n             ```js\n            findUser().then(function (user) {\n              return findCommentsByAuthor(user);\n            }).then(function (comments) {\n              // If `findCommentsByAuthor` fulfills, we'll have the value here\n            }, function (reason) {\n              // If `findCommentsByAuthor` rejects, we'll have the reason here\n            });\n            ```\n             Simple Example\n            --------------\n             Synchronous Example\n             ```javascript\n            let result;\n             try {\n              result = findResult();\n              // success\n            } catch(reason) {\n              // failure\n            }\n            ```\n             Errback Example\n             ```js\n            findResult(function(result, err){\n              if (err) {\n                // failure\n              } else {\n                // success\n              }\n            });\n            ```\n             Promise Example;\n             ```javascript\n            findResult().then(function(result){\n              // success\n            }, function(reason){\n              // failure\n            });\n            ```\n             Advanced Example\n            --------------\n             Synchronous Example\n             ```javascript\n            let author, books;\n             try {\n              author = findAuthor();\n              books  = findBooksByAuthor(author);\n              // success\n            } catch(reason) {\n              // failure\n            }\n            ```\n             Errback Example\n             ```js\n             function foundBooks(books) {\n             }\n             function failure(reason) {\n             }\n             findAuthor(function(author, err){\n              if (err) {\n                failure(err);\n                // failure\n              } else {\n                try {\n                  findBoooksByAuthor(author, function(books, err) {\n                    if (err) {\n                      failure(err);\n                    } else {\n                      try {\n                        foundBooks(books);\n                      } catch(reason) {\n                        failure(reason);\n                      }\n                    }\n                  });\n                } catch(error) {\n                  failure(err);\n                }\n                // success\n              }\n            });\n            ```\n             Promise Example;\n             ```javascript\n            findAuthor().\n              then(findBooksByAuthor).\n              then(function(books){\n                // found books\n            }).catch(function(reason){\n              // something went wrong\n            });\n            ```\n             @method then\n            @param {Function} onFulfilled\n            @param {Function} onRejected\n            Useful for tooling.\n            @return {Promise}\n            */\n\n            /**\n            `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n            as the catch block of a try/catch statement.\n            ```js\n            function findAuthor(){\n            throw new Error('couldn't find that author');\n            }\n            // synchronous\n            try {\n            findAuthor();\n            } catch(reason) {\n            // something went wrong\n            }\n            // async with promises\n            findAuthor().catch(function(reason){\n            // something went wrong\n            });\n            ```\n            @method catch\n            @param {Function} onRejection\n            Useful for tooling.\n            @return {Promise}\n            */\n\n\n            Promise.prototype.catch = function _catch(onRejection) {\n              return this.then(null, onRejection);\n            };\n            /**\n              `finally` will be invoked regardless of the promise's fate just as native\n              try/catch/finally behaves\n            \n              Synchronous example:\n            \n              ```js\n              findAuthor() {\n                if (Math.random() > 0.5) {\n                  throw new Error();\n                }\n                return new Author();\n              }\n            \n              try {\n                return findAuthor(); // succeed or fail\n              } catch(error) {\n                return findOtherAuther();\n              } finally {\n                // always runs\n                // doesn't affect the return value\n              }\n              ```\n            \n              Asynchronous example:\n            \n              ```js\n              findAuthor().catch(function(reason){\n                return findOtherAuther();\n              }).finally(function(){\n                // author was either found, or not\n              });\n              ```\n            \n              @method finally\n              @param {Function} callback\n              @return {Promise}\n            */\n\n\n            Promise.prototype.finally = function _finally(callback) {\n              var promise = this;\n              var constructor = promise.constructor;\n              return promise.then(function (value) {\n                return constructor.resolve(callback()).then(function () {\n                  return value;\n                });\n              }, function (reason) {\n                return constructor.resolve(callback()).then(function () {\n                  throw reason;\n                });\n              });\n            };\n\n            return Promise;\n          }();\n\n          Promise$1.prototype.then = then;\n          Promise$1.all = all;\n          Promise$1.race = race;\n          Promise$1.resolve = resolve$1;\n          Promise$1.reject = reject$1;\n          Promise$1._setScheduler = setScheduler;\n          Promise$1._setAsap = setAsap;\n          Promise$1._asap = asap;\n          /*global self*/\n\n          function polyfill() {\n            var local = void 0;\n\n            if (typeof global !== 'undefined') {\n              local = global;\n            } else if (typeof self !== 'undefined') {\n              local = self;\n            } else {\n              try {\n                local = Function('return this')();\n              } catch (e) {\n                throw new Error('polyfill failed because global object is unavailable in this environment');\n              }\n            }\n\n            var P = local.Promise;\n\n            if (P) {\n              var promiseToString = null;\n\n              try {\n                promiseToString = Object.prototype.toString.call(P.resolve());\n              } catch (e) {// silently ignored\n              }\n\n              if (promiseToString === '[object Promise]' && !P.cast) {\n                return;\n              }\n            }\n\n            local.Promise = Promise$1;\n          } // Strange compat..\n\n\n          Promise$1.polyfill = polyfill;\n          Promise$1.Promise = Promise$1;\n          return Promise$1;\n        });\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"_process\": 2\n    }],\n    2: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    3: [function (require, module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Promise = require('es6-promise').Promise;\n      /**\n       * Map to hold easing functions.\n       * @type {Object}\n       */\n\n\n      var animMap = {\n        linear: function linear(t) {\n          return t;\n        },\n        easeInQuad: function easeInQuad(t) {\n          return t * t;\n        },\n        easeOutQuad: function easeOutQuad(t) {\n          return t * (2 - t);\n        },\n        easeInOutQuad: function easeInOutQuad(t) {\n          return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        },\n        easeInCubic: function easeInCubic(t) {\n          return t * t * t;\n        },\n        easeOutCubic: function easeOutCubic(t) {\n          return --t * t * t + 1;\n        },\n        easeInOutCubic: function easeInOutCubic(t) {\n          return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        },\n        easeInQuart: function easeInQuart(t) {\n          return t * t * t * t;\n        },\n        easeOutQuart: function easeOutQuart(t) {\n          return 1 - --t * t * t * t;\n        },\n        easeInOutQuart: function easeInOutQuart(t) {\n          return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        },\n        easeInQuint: function easeInQuint(t) {\n          return t * t * t * t * t;\n        },\n        easeOutQuint: function easeOutQuint(t) {\n          return 1 + --t * t * t * t * t;\n        },\n        easeInOutQuint: function easeInOutQuint(t) {\n          return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        }\n      };\n      /**\n       * Gets an easing function based on supplied easing string.\n       * @param {String} easing - The easing id\n       * @returns {Function} - Returns the easing function\n       */\n\n      var getEasing = function getEasing(easing) {\n        var defaultEasing = 'linear',\n            easeFunc = animMap[easing || defaultEasing];\n\n        if (!easeFunc) {\n          console.debug('Scroll error: scroller does not support an easing option of ' + easing + '. Using \"' + defaultEasing + '\" instead');\n          easeFunc = animMap[easing];\n        }\n\n        return easeFunc;\n      };\n      /**\n       * Scroll class.\n       * @class Scroll\n       * @param {object} options - Options to pass\n       * @param {HTMLElement} options.el - The element to apply scroll to\n       */\n\n\n      var Scroll = function () {\n        /**\n         * When the scroll is instantiated.\n         * @param {HTMLElement} el - The element to scroll (the viewport)\n         */\n        function Scroll(el) {\n          _classCallCheck(this, Scroll);\n\n          if (el && !(el instanceof Node)) {\n            throw new Error('Scroll error: element passed to Scroll constructor must be a DOM node, you passed ' + el + '!');\n          }\n\n          this.el = el || this.document.body;\n        }\n        /**\n         * Gets the current scroll position of the scroll container.\n         * @returns {number}\n         */\n\n\n        _createClass(Scroll, [{\n          key: 'to',\n\n          /**\n           * Scrolls the element until it's scroll properties match the coordinates provided.\n           * @param {Number} x - The pixel along the horizontal axis of the element that you want displayed in the upper left.\n           * @param {Number} y - The pixel along the vertical axis of the element that you want displayed in the upper left.\n           * @param {Object} [options] - Scroll options\n           * @param {Number} [options.duration]- The amount of time for the animation\n           * @param {string} [options.easing] - The easing function to use\n           * @return {Promise}\n           */\n          value: function to(x, y, options) {\n            var _this = this;\n\n            options = options || {};\n            options.duration = options.duration || 400;\n            /**\n             * Sets element's property to a value.\n             * @param {string} prop - The property to set\n             * @param {Number} value - The number value\n             */\n\n            var moveElement = function moveElement(prop, value) {\n              var el = _this.el;\n              el[prop] = value; // scroll the html element also for cross-browser compatibility\n              // (ie. silly browsers like IE who need the html element to scroll too)\n\n              if (el === _this.document.body) {\n                _this.document.documentElement[prop] = value;\n              }\n            };\n            /**\n             * Does a bit of calculating and scrolls an element.\n             * @param {HTMLElement} el - The element to be scrolled\n             * @param {Number} from - The number of where to scroll from\n             * @param {Number} to - The number of where to scroll to\n             * @param {string} prop - The property to animate\n             * @param {Number} startTime - The timestamp of when the animation should start\n             * @param {Number} duration - The amount of time for the animation\n             * @param {Function} easeFunc - The easing function to use\n             * @param [callback]\n             */\n\n\n            var scroll = function scroll(el, from, to, prop, startTime, duration, easeFunc, callback) {\n              window.requestAnimationFrame(function () {\n                var currentTime = Date.now(),\n                    time = Math.min(1, (currentTime - startTime) / duration);\n\n                if (from === to) {\n                  return callback ? callback() : null;\n                }\n\n                moveElement(prop, easeFunc(time) * (to - from) + from);\n                /* prevent scrolling, if already there, or at end */\n\n                if (time < 1) {\n                  scroll(el, el[prop], to, prop, startTime, duration, easeFunc, callback);\n                } else if (callback) {\n                  callback();\n                }\n              });\n            };\n\n            return new Promise(function (resolve) {\n              scroll(_this.el, _this.scrollPosition, y, 'scrollTop', Date.now(), options.duration, getEasing(options.easing), resolve);\n            });\n          }\n          /**\n           * Returns document element\n           * @returns {HTMLDocument}\n           */\n\n        }, {\n          key: 'toElement',\n\n          /**\n           * Scroll to an element.\n           * @param {HTMLElement} el - The element to scroll to.\n           * @param {Object} [options] - The scroll options\n           */\n          value: function toElement(el, options) {\n            var container = this.el;\n            var currentContainerScrollYPos = 0;\n            var elementScrollYPos = el ? el.offsetTop : 0;\n            var errorMsg = void 0;\n\n            if (!el) {\n              errorMsg = 'The element passed to Scroll.toElement() was undefined';\n              console.error(errorMsg);\n              return Promise.reject(new Error(errorMsg));\n            } // if the container is the document body or document itself, we'll\n            // need a different set of coordinates for accuracy\n\n\n            if (container === this.document.body) {\n              // using pageYOffset for cross-browser compatibility\n              currentContainerScrollYPos = window.pageYOffset; // must add containers scroll y position to ensure an absolute value that does not change\n\n              elementScrollYPos = el.getBoundingClientRect().top + currentContainerScrollYPos;\n            }\n\n            return this.to(0, elementScrollYPos, options);\n          }\n          /**\n           * Use this to clean up the DOM when done.\n           */\n\n        }, {\n          key: 'destroy',\n          value: function destroy() {}\n        }, {\n          key: 'scrollPosition',\n          get: function get() {\n            var el = this.el,\n                document = this.document;\n\n            if (el === document.body) {\n              return document.body.scrollTop || document.documentElement.scrollTop;\n            } else {\n              return el.scrollTop;\n            }\n          }\n        }, {\n          key: 'document',\n          get: function get() {\n            return document;\n          }\n        }]);\n\n        return Scroll;\n      }();\n\n      exports.default = Scroll;\n      module.exports = exports['default'];\n    }, {\n      \"es6-promise\": 1\n    }]\n  }, {}, [3])(3);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/scroll-js/dist/scroll.js?")},"./node_modules/skatejs/dist/es/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/util.js\nfunction dashCase(str) {\n  return typeof str === \'string\' ? str.split(/([_A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? \'\' : \'-\';\n    two = two === \'_\' ? \'\' : two;\n    return \'\' + one + dash + two.toLowerCase();\n  }) : str;\n}\nvar empty = function empty(val) {\n  return val == null;\n};\nfunction keys(obj) {\n  obj = obj || {};\n  var names = Object.getOwnPropertyNames(obj);\n  return Object.getOwnPropertySymbols ? names.concat(Object.getOwnPropertySymbols(obj)) : names;\n}\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/name.js\n\n\nfunction format(prefix, suffix) {\n  return (prefix.indexOf(\'-\') === -1 ? \'x-\' + prefix : prefix) + (suffix ? \'-\' + suffix : \'\');\n}\n\nfunction name_name() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'element\';\n  prefix = dashCase(prefix);\n  var suffix = 0;\n\n  while (customElements.get(format(prefix, suffix))) {\n    ++suffix;\n  }\n\n  return format(prefix, suffix);\n}\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/define.js\n\nfunction define(Ctor) {\n  customElements.define(Ctor.is || name_name(), Ctor);\n  return Ctor;\n}\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/emit.js\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar defs = {\n  bubbles: true,\n  cancelable: true,\n  composed: false\n};\nfunction emit(elem, name, opts) {\n  var eventOptions = _extends({}, defs, opts);\n\n  var e = void 0;\n\n  if (\'composed\' in CustomEvent.prototype) {\n    e = new CustomEvent(name, eventOptions);\n  } else {\n    e = document.createEvent(\'CustomEvent\');\n    e.initCustomEvent(name, eventOptions.bubbles, eventOptions.cancelable, eventOptions.detail);\n    Object.defineProperty(e, \'composed\', {\n      value: eventOptions.composed\n    });\n  }\n\n  return elem.dispatchEvent(e);\n}\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/link.js\nfunction getValue(elem) {\n  var checked = elem.checked,\n      type = elem.type,\n      value = elem.value;\n\n  if (type === \'checkbox\' || type === \'radio\') {\n    return checked ? value || true : false;\n  }\n\n  return value;\n}\n\nfunction link_link(elem) {\n  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \'state.\';\n  return function (e) {\n    // TODO revisit once all browsers have native support.\n    //\n    // We fallback to checking the composed path. Unfortunately this behaviour\n    // is difficult to impossible to reproduce as it seems to be a possible\n    // quirk in the shadydom polyfill that incorrectly returns null for the\n    var localTarget = e.target || e.composedPath && e.composedPath()[0];\n    var value = getValue(localTarget);\n    var localTargetName = target || localTarget.name || \'value\';\n\n    if (localTargetName.indexOf(\'.\') > -1) {\n      var parts = localTargetName.split(\'.\');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev[curr];\n      }, elem);\n      obj[propName || localTarget.name] = value;\n      elem[firstPart] = elem[firstPart];\n    } else {\n      elem[localTargetName] = value;\n    }\n  };\n}\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/shadow.js\nfunction shadow(elem) {\n  return elem._shadowRoot || (elem._shadowRoot = elem.shadowRoot || elem.attachShadow({\n    mode: \'open\'\n  }));\n}\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/with-children.js\nfunction _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }\n\nvar _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if ("value" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _fixBabelExtend = function (O) {\n  var gPO = O.getPrototypeOf || function (o) {\n    return o.__proto__;\n  },\n      sPO = O.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  },\n      construct = (typeof Reflect === \'undefined\' ? \'undefined\' : _typeof(Reflect)) === \'object\' ? Reflect.construct : function (Parent, args, Class) {\n    var Constructor,\n        a = [null];\n    a.push.apply(a, args);\n    Constructor = Parent.bind.apply(Parent, a);\n    return sPO(new Constructor(), Class.prototype);\n  };\n\n  return function fixBabelExtend(Class) {\n    var Parent = gPO(Class);\n    return sPO(Class, sPO(function Super() {\n      return construct(Parent, arguments, gPO(this).constructor);\n    }, Parent));\n  };\n}(Object);\n\nvar withChildren = function withChildren() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return _fixBabelExtend(function (_Base) {\n    _inherits(_class2, _Base);\n\n    function _class2() {\n      _classCallCheck(this, _class2);\n\n      return _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));\n    }\n\n    _createClass(_class2, [{\n      key: \'childrenUpdated\',\n      // We automatically set a prop called children to invoke an update if it\'s\n      // been defined.\n      value: function childrenUpdated() {\n        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'childrenUpdated\', this) && _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'childrenUpdated\', this).call(this);\n\n        if (this.props && this.props.hasOwnProperty(\'children\')) {\n          this.props = {\n            children: this.children\n          };\n        }\n      }\n    }, {\n      key: \'connectedCallback\',\n      value: function connectedCallback() {\n        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'connectedCallback\', this) && _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'connectedCallback\', this).call(this);\n\n        if (this.childrenUpdated) {\n          var fn = this.childrenUpdated.bind(this);\n          this._mo = new MutationObserver(fn);\n\n          this._mo.observe(this, {\n            childList: true\n          });\n\n          fn();\n        }\n      }\n    }, {\n      key: \'disconnectedCallback\',\n      value: function disconnectedCallback() {\n        _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'disconnectedCallback\', this) && _get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'disconnectedCallback\', this).call(this);\n\n        if (this._mo) {\n          this._mo.disconnect();\n        }\n      }\n    }]);\n\n    return _class2;\n  }(Base));\n};\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/with-context.js\nfunction with_context_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { with_context_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { with_context_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return with_context_typeof2(obj); }\n\nvar with_context_typeof = typeof Symbol === "function" && with_context_typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return with_context_typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : with_context_typeof2(obj);\n};\n\nvar with_context_createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction with_context_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction with_context_possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (with_context_typeof2(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction with_context_inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + with_context_typeof2(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar with_context_fixBabelExtend = function (O) {\n  var gPO = O.getPrototypeOf || function (o) {\n    return o.__proto__;\n  },\n      sPO = O.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  },\n      construct = (typeof Reflect === \'undefined\' ? \'undefined\' : with_context_typeof(Reflect)) === \'object\' ? Reflect.construct : function (Parent, args, Class) {\n    var Constructor,\n        a = [null];\n    a.push.apply(a, args);\n    Constructor = Parent.bind.apply(Parent, a);\n    return sPO(new Constructor(), Class.prototype);\n  };\n\n  return function fixBabelExtend(Class) {\n    var Parent = gPO(Class);\n    return sPO(Class, sPO(function Super() {\n      return construct(Parent, arguments, gPO(this).constructor);\n    }, Parent));\n  };\n}(Object);\n\nvar withContext = function withContext() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return with_context_fixBabelExtend(function (_Base) {\n    with_context_inherits(_class, _Base);\n\n    function _class() {\n      with_context_classCallCheck(this, _class);\n\n      return with_context_possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    with_context_createClass(_class, [{\n      key: \'context\',\n      get: function get() {\n        if (this._context) {\n          return this._context;\n        }\n\n        var node = this;\n\n        while (node = node.parentNode || node.host) {\n          if (\'context\' in node) {\n            return node.context;\n          }\n        }\n\n        return {};\n      },\n      set: function set(context) {\n        this._context = context;\n      }\n    }]);\n\n    return _class;\n  }(Base));\n};\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/with-lifecycle.js\nfunction with_lifecycle_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { with_lifecycle_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { with_lifecycle_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return with_lifecycle_typeof2(obj); }\n\nvar with_lifecycle_typeof = typeof Symbol === "function" && with_lifecycle_typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return with_lifecycle_typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : with_lifecycle_typeof2(obj);\n};\n\nvar with_lifecycle_createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar with_lifecycle_get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if ("value" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nfunction with_lifecycle_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction with_lifecycle_possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (with_lifecycle_typeof2(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction with_lifecycle_inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + with_lifecycle_typeof2(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar with_lifecycle_fixBabelExtend = function (O) {\n  var gPO = O.getPrototypeOf || function (o) {\n    return o.__proto__;\n  },\n      sPO = O.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  },\n      construct = (typeof Reflect === "undefined" ? "undefined" : with_lifecycle_typeof(Reflect)) === \'object\' ? Reflect.construct : function (Parent, args, Class) {\n    var Constructor,\n        a = [null];\n    a.push.apply(a, args);\n    Constructor = Parent.bind.apply(Parent, a);\n    return sPO(new Constructor(), Class.prototype);\n  };\n\n  return function fixBabelExtend(Class) {\n    var Parent = gPO(Class);\n    return sPO(Class, sPO(function Super() {\n      return construct(Parent, arguments, gPO(this).constructor);\n    }, Parent));\n  };\n}(Object);\n\nvar withLifecycle = function withLifecycle() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return with_lifecycle_fixBabelExtend(function (_Base) {\n    with_lifecycle_inherits(_class, _Base);\n\n    function _class() {\n      with_lifecycle_classCallCheck(this, _class);\n\n      return with_lifecycle_possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    with_lifecycle_createClass(_class, [{\n      key: "connectedCallback",\n      value: function connectedCallback() {\n        this.connecting && this.connecting();\n        with_lifecycle_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "connectedCallback", this) && with_lifecycle_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);\n        this.connected && this.connected();\n      }\n    }, {\n      key: "disconnectedCallback",\n      value: function disconnectedCallback() {\n        this.disconnecting && this.disconnecting();\n        with_lifecycle_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "disconnectedCallback", this) && with_lifecycle_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);\n        this.disconnected && this.disconnected();\n      }\n    }]);\n\n    return _class;\n  }(Base));\n};\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/with-update.js\nfunction with_update_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { with_update_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { with_update_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return with_update_typeof2(obj); }\n\nvar with_update_createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar with_update_get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if ("value" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar with_update_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar with_update_typeof = typeof Symbol === "function" && with_update_typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return with_update_typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : with_update_typeof2(obj);\n};\n\nfunction with_update_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction with_update_possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (with_update_typeof2(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction with_update_inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + with_update_typeof2(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar with_update_fixBabelExtend = function (O) {\n  var gPO = O.getPrototypeOf || function (o) {\n    return o.__proto__;\n  },\n      sPO = O.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  },\n      construct = (typeof Reflect === \'undefined\' ? \'undefined\' : with_update_typeof(Reflect)) === \'object\' ? Reflect.construct : function (Parent, args, Class) {\n    var Constructor,\n        a = [null];\n    a.push.apply(a, args);\n    Constructor = Parent.bind.apply(Parent, a);\n    return sPO(new Constructor(), Class.prototype);\n  };\n\n  return function fixBabelExtend(Class) {\n    var Parent = gPO(Class);\n    return sPO(Class, sPO(function Super() {\n      return construct(Parent, arguments, gPO(this).constructor);\n    }, Parent));\n  };\n}(Object);\n\n\nfunction normalizeAttributeDefinition(name, prop) {\n  var attribute = prop.attribute;\n  var obj = (typeof attribute === \'undefined\' ? \'undefined\' : with_update_typeof(attribute)) === \'object\' ? with_update_extends({}, attribute) : {\n    source: attribute,\n    target: attribute\n  };\n\n  if (obj.source === true) {\n    obj.source = dashCase(name);\n  }\n\n  if (obj.target === true) {\n    obj.target = dashCase(name);\n  }\n\n  return obj;\n}\n\nfunction identity(v) {\n  return v;\n}\n\nfunction normalizePropertyDefinition(name, prop) {\n  var coerce = prop.coerce,\n      def = prop.default,\n      deserialize = prop.deserialize,\n      serialize = prop.serialize;\n  return {\n    attribute: normalizeAttributeDefinition(name, prop),\n    coerce: coerce || identity,\n    default: def,\n    deserialize: deserialize || identity,\n    serialize: serialize || identity\n  };\n}\nvar defaultTypesMap = new Map();\n\nfunction defineProps(constructor) {\n  if (constructor.hasOwnProperty(\'_propsNormalized\')) return;\n  var props = constructor.props;\n  keys(props).forEach(function (name) {\n    var func = props[name] || props.any;\n    if (defaultTypesMap.has(func)) func = defaultTypesMap.get(func);\n    if (typeof func !== \'function\') func = with_update_prop(func);\n    func({\n      constructor: constructor\n    }, name);\n  });\n}\n\nfunction delay(fn) {\n  if (window.Promise) {\n    Promise.resolve().then(fn);\n  } else {\n    setTimeout(fn);\n  }\n}\n\nfunction with_update_prop(definition) {\n  var propertyDefinition = definition || {}; // Allows decorators, or imperative definitions.\n\n  var func = function func(_ref, name) {\n    var constructor = _ref.constructor;\n    var normalized = normalizePropertyDefinition(name, propertyDefinition); // Ensure that we can cache properties. We have to do this so the _props object literal doesn\'t modify parent\n    // classes or share the instance anywhere where it\'s not intended to be shared explicitly in userland code.\n\n    if (!constructor.hasOwnProperty(\'_propsNormalized\')) {\n      constructor._propsNormalized = {};\n    } // Cache the value so we can reference when syncing the attribute to the property.\n\n\n    constructor._propsNormalized[name] = normalized;\n    var _normalized$attribute = normalized.attribute,\n        source = _normalized$attribute.source,\n        target = _normalized$attribute.target;\n\n    if (source) {\n      constructor._observedAttributes.push(source);\n\n      constructor._attributeToPropertyMap[source] = name;\n\n      if (source !== target) {\n        constructor._attributeToAttributeMap[source] = target;\n      }\n    }\n\n    Object.defineProperty(constructor.prototype, name, {\n      configurable: true,\n      get: function get() {\n        var val = this._props[name];\n        return val == null ? normalized.default : val;\n      },\n      set: function set(val) {\n        var target = normalized.attribute.target,\n            serialize = normalized.serialize;\n\n        if (target) {\n          var serializedVal = serialize ? serialize(val) : val;\n\n          if (serializedVal == null) {\n            this.removeAttribute(target);\n          } else {\n            this.setAttribute(target, serializedVal);\n          }\n        }\n\n        this._props[name] = normalized.coerce(val);\n        this.triggerUpdate();\n      }\n    });\n  }; // Allows easy extension of pre-defined props { ...prop(), ...{} }.\n\n\n  Object.keys(propertyDefinition).forEach(function (key) {\n    return func[key] = propertyDefinition[key];\n  });\n  return func;\n}\nvar with_update_withUpdate = function withUpdate() {\n  var _class, _temp2;\n\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return with_update_fixBabelExtend((_temp2 = _class = function (_Base) {\n    with_update_inherits(_class, _Base);\n\n    function _class() {\n      var _ref2;\n\n      var _temp, _this, _ret;\n\n      with_update_classCallCheck(this, _class);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = with_update_possibleConstructorReturn(this, (_ref2 = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref2, [this].concat(args))), _this), _this._prevProps = {}, _this._prevState = {}, _this._props = {}, _this._state = {}, _temp), with_update_possibleConstructorReturn(_this, _ret);\n    }\n\n    with_update_createClass(_class, [{\n      key: \'attributeChangedCallback\',\n      value: function attributeChangedCallback(name, oldValue, newValue) {\n        var _constructor = this.constructor,\n            _attributeToAttributeMap = _constructor._attributeToAttributeMap,\n            _attributeToPropertyMap = _constructor._attributeToPropertyMap,\n            _propsNormalized = _constructor._propsNormalized;\n\n        if (with_update_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), \'attributeChangedCallback\', this)) {\n          with_update_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), \'attributeChangedCallback\', this).call(this, name, oldValue, newValue);\n        }\n\n        var propertyName = _attributeToPropertyMap[name];\n\n        if (propertyName) {\n          var propertyDefinition = _propsNormalized[propertyName];\n\n          if (propertyDefinition) {\n            var defaultValue = propertyDefinition.default,\n                deserialize = propertyDefinition.deserialize;\n            var propertyValue = deserialize ? deserialize(newValue) : newValue;\n            this._props[propertyName] = propertyValue == null ? defaultValue : propertyValue;\n            this.triggerUpdate();\n          }\n        }\n\n        var targetAttributeName = _attributeToAttributeMap[name];\n\n        if (targetAttributeName) {\n          if (newValue == null) {\n            this.removeAttribute(targetAttributeName);\n          } else {\n            this.setAttribute(targetAttributeName, newValue);\n          }\n        }\n      }\n    }, {\n      key: \'connectedCallback\',\n      value: function connectedCallback() {\n        if (with_update_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), \'connectedCallback\', this)) {\n          with_update_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), \'connectedCallback\', this).call(this);\n        }\n\n        this.triggerUpdate();\n      }\n    }, {\n      key: \'shouldUpdate\',\n      value: function shouldUpdate() {\n        return true;\n      }\n    }, {\n      key: \'triggerUpdate\',\n      value: function triggerUpdate() {\n        var _this2 = this;\n\n        if (this._updating) {\n          return;\n        }\n\n        this._updating = true;\n        delay(function () {\n          var _prevProps = _this2._prevProps,\n              _prevState = _this2._prevState;\n\n          if (_this2.updating) {\n            _this2.updating(_prevProps, _prevState);\n          }\n\n          if (_this2.updated && _this2.shouldUpdate(_prevProps, _prevState)) {\n            _this2.updated(_prevProps, _prevState);\n          }\n\n          _this2._prevProps = _this2.props;\n          _this2._prevState = _this2.state;\n          _this2._updating = false;\n        });\n      }\n    }, {\n      key: \'props\',\n      get: function get() {\n        var _this3 = this;\n\n        return keys(this.constructor.props).reduce(function (prev, curr) {\n          prev[curr] = _this3[curr];\n          return prev;\n        }, {});\n      },\n      set: function set(props) {\n        var _this4 = this;\n\n        var ctorProps = this.constructor.props;\n        keys(props).forEach(function (k) {\n          return k in ctorProps && (_this4[k] = props[k]);\n        });\n      }\n    }, {\n      key: \'state\',\n      get: function get() {\n        return this._state;\n      },\n      set: function set(state) {\n        this._state = state;\n        this.triggerUpdate();\n      }\n    }], [{\n      key: \'observedAttributes\',\n      get: function get() {\n        // We have to define props here because observedAttributes are retrieved\n        // only once when the custom element is defined. If we did this only in\n        // the constructor, then props would not link to attributes.\n        defineProps(this);\n        return this._observedAttributes.concat(with_update_get(_class.__proto__ || Object.getPrototypeOf(_class), \'observedAttributes\', this) || []);\n      }\n    }, {\n      key: \'props\',\n      get: function get() {\n        return this._props;\n      },\n      set: function set(props) {\n        this._props = props;\n      }\n    }]);\n\n    return _class;\n  }(Base), _class._attributeToAttributeMap = {}, _class._attributeToPropertyMap = {}, _class._observedAttributes = [], _class._props = {}, _temp2));\n};\nvar parse = JSON.parse,\n    stringify = JSON.stringify;\nvar with_update_attribute = Object.freeze({\n  source: true\n});\n\nvar with_update_zeroOrNumber = function zeroOrNumber(val) {\n  return empty(val) ? 0 : Number(val);\n};\n\nvar any = with_update_prop({\n  attribute: with_update_attribute\n});\nvar array = with_update_prop({\n  attribute: with_update_attribute,\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : empty(val) ? null : [val];\n  },\n  default: Object.freeze([]),\n  deserialize: parse,\n  serialize: stringify\n});\nvar with_update_boolean = with_update_prop({\n  attribute: with_update_attribute,\n  coerce: Boolean,\n  default: false,\n  deserialize: function deserialize(val) {\n    return !empty(val);\n  },\n  serialize: function serialize(val) {\n    return val ? \'\' : null;\n  }\n});\nvar number = with_update_prop({\n  attribute: with_update_attribute,\n  default: 0,\n  coerce: with_update_zeroOrNumber,\n  deserialize: with_update_zeroOrNumber,\n  serialize: function serialize(val) {\n    return empty(val) ? null : String(Number(val));\n  }\n});\nvar object = with_update_prop({\n  attribute: with_update_attribute,\n  default: Object.freeze({}),\n  deserialize: parse,\n  serialize: stringify\n});\nvar string = with_update_prop({\n  attribute: with_update_attribute,\n  default: \'\',\n  coerce: String,\n  serialize: function serialize(val) {\n    return empty(val) ? null : String(val);\n  }\n});\ndefaultTypesMap.set(Array, array);\ndefaultTypesMap.set(Boolean, with_update_boolean);\ndefaultTypesMap.set(Number, number);\ndefaultTypesMap.set(Object, object);\ndefaultTypesMap.set(String, string);\nvar with_update_props = {\n  any: any,\n  array: array,\n  boolean: with_update_boolean,\n  number: number,\n  object: object,\n  string: string\n};\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/with-renderer.js\nfunction with_renderer_typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { with_renderer_typeof2 = function _typeof2(obj) { return typeof obj; }; } else { with_renderer_typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return with_renderer_typeof2(obj); }\n\nvar with_renderer_typeof = typeof Symbol === "function" && with_renderer_typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return with_renderer_typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : with_renderer_typeof2(obj);\n};\n\nvar with_renderer_createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar with_renderer_get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if ("value" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nfunction with_renderer_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction with_renderer_possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && (with_renderer_typeof2(call) === "object" || typeof call === "function") ? call : self;\n}\n\nfunction with_renderer_inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + with_renderer_typeof2(superClass));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar with_renderer_fixBabelExtend = function (O) {\n  var gPO = O.getPrototypeOf || function (o) {\n    return o.__proto__;\n  },\n      sPO = O.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  },\n      construct = (typeof Reflect === \'undefined\' ? \'undefined\' : with_renderer_typeof(Reflect)) === \'object\' ? Reflect.construct : function (Parent, args, Class) {\n    var Constructor,\n        a = [null];\n    a.push.apply(a, args);\n    Constructor = Parent.bind.apply(Parent, a);\n    return sPO(new Constructor(), Class.prototype);\n  };\n\n  return function fixBabelExtend(Class) {\n    var Parent = gPO(Class);\n    return sPO(Class, sPO(function Super() {\n      return construct(Parent, arguments, gPO(this).constructor);\n    }, Parent));\n  };\n}(Object);\n\n\nvar with_renderer_withRenderer = function withRenderer() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return with_renderer_fixBabelExtend(function (_Base) {\n    with_renderer_inherits(_class2, _Base);\n\n    function _class2() {\n      with_renderer_classCallCheck(this, _class2);\n\n      return with_renderer_possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));\n    }\n\n    with_renderer_createClass(_class2, [{\n      key: \'renderer\',\n      value: function renderer(root, html) {\n        if (with_renderer_get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'renderer\', this)) {\n          with_renderer_get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'renderer\', this).call(this, root, html);\n        } else {\n          root.innerHTML = html() || \'\';\n        }\n      }\n    }, {\n      key: \'updated\',\n      value: function updated(prevProps, prevState) {\n        var _this2 = this;\n\n        with_renderer_get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'updated\', this) && with_renderer_get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'updated\', this).call(this, prevProps, prevState);\n        this.rendering && this.rendering();\n        this.renderer(this.renderRoot, function () {\n          return _this2.render && _this2.render(_this2);\n        });\n        this.rendered && this.rendered();\n      }\n    }, {\n      key: \'renderRoot\',\n      get: function get() {\n        return with_renderer_get(_class2.prototype.__proto__ || Object.getPrototypeOf(_class2.prototype), \'renderRoot\', this) || shadow(this);\n      }\n    }]);\n\n    return _class2;\n  }(Base));\n};\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/with-component.js\n\n\n\n\n\nvar with_component_withComponent = function withComponent() {\n  var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;\n  return withLifecycle(withChildren(withContext(with_update_withUpdate(with_renderer_withRenderer(Base || HTMLElement)))));\n};\n// CONCATENATED MODULE: ./node_modules/skatejs/dist/es/index.js\n/* concated harmony reexport define */__webpack_require__.d(__webpack_exports__, "define", function() { return define; });\n/* concated harmony reexport emit */__webpack_require__.d(__webpack_exports__, "emit", function() { return emit; });\n/* concated harmony reexport link */__webpack_require__.d(__webpack_exports__, "link", function() { return link_link; });\n/* concated harmony reexport name */__webpack_require__.d(__webpack_exports__, "name", function() { return name_name; });\n/* concated harmony reexport shadow */__webpack_require__.d(__webpack_exports__, "shadow", function() { return shadow; });\n/* concated harmony reexport withChildren */__webpack_require__.d(__webpack_exports__, "withChildren", function() { return withChildren; });\n/* concated harmony reexport withContext */__webpack_require__.d(__webpack_exports__, "withContext", function() { return withContext; });\n/* concated harmony reexport withComponent */__webpack_require__.d(__webpack_exports__, "withComponent", function() { return with_component_withComponent; });\n/* concated harmony reexport withLifecycle */__webpack_require__.d(__webpack_exports__, "withLifecycle", function() { return withLifecycle; });\n/* concated harmony reexport normalizeAttributeDefinition */__webpack_require__.d(__webpack_exports__, "normalizeAttributeDefinition", function() { return normalizeAttributeDefinition; });\n/* concated harmony reexport normalizePropertyDefinition */__webpack_require__.d(__webpack_exports__, "normalizePropertyDefinition", function() { return normalizePropertyDefinition; });\n/* concated harmony reexport prop */__webpack_require__.d(__webpack_exports__, "prop", function() { return with_update_prop; });\n/* concated harmony reexport withUpdate */__webpack_require__.d(__webpack_exports__, "withUpdate", function() { return with_update_withUpdate; });\n/* concated harmony reexport props */__webpack_require__.d(__webpack_exports__, "props", function() { return with_update_props; });\n/* concated harmony reexport withRenderer */__webpack_require__.d(__webpack_exports__, "withRenderer", function() { return with_renderer_withRenderer; });\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/skatejs/dist/es/index.js_+_12_modules?')},"./node_modules/webpack/buildin/amd-options.js":function(module,exports){eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?")},"./node_modules/webpack/node_modules/base64-js/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n} // base64 is 4/3 + up to two characters of the original data\n\n\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  for (var i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}\n\n//# sourceURL=webpack:///(webpack)/node_modules/base64-js/index.js?")},"./node_modules/webpack/node_modules/buffer/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n/* eslint-disable no-proto */\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/webpack/node_modules/base64-js/index.js\");\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/webpack/node_modules/ieee754/index.js\");\n\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/webpack/node_modules/isarray/index.js\");\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\n\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n/*\n * Export kMaxLength after typed array support is determined.\n */\n\nexports.kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = {\n      __proto__: Uint8Array.prototype,\n      foo: function foo() {\n        return 42;\n      }\n    };\n    return arr.foo() === 42 && // typed array instances can be augmented\n    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n\n    that.length = length;\n  }\n\n  return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  } // Common case.\n\n\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n\n    return allocUnsafe(this, arg);\n  }\n\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\n\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    });\n  }\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n\n  return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n\n  return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\n\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nBuffer.compare = function compare(a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n\n  if (length === undefined) {\n    length = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0; // Use a for loop to avoid recursion\n\n  var loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n\n      case 'hex':\n        return len >>> 1;\n\n      case 'base64':\n        return base64ToBytes(string).length;\n\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n  if (start === undefined || start < 0) {\n    start = 0;\n  } // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n\n\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\n\n\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n  if (this === target) return 0;\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\n\n\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1; // Normalize byteOffset\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n\n  byteOffset = +byteOffset; // Coerce to Number.\n\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  } // Normalize val\n\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n\n  if (dir) {\n    var foundIndex = -1;\n\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n\n    if (length > remaining) {\n      length = remaining;\n    }\n  } // must be an even number of digits\n\n\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0; // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0; // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n  var loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n  var i = start;\n\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n\n          break;\n\n        case 2:\n          secondByte = buf[i + 1];\n\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n} // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\n\n\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n  var res = '';\n  var i = 0;\n\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n  var out = '';\n\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n  var newBuf;\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n  if (end > this.length) end = this.length;\n\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n}; // Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n\n\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n\n      if (code < 256) {\n        val = code;\n      }\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } // Invalid ranges are not set to a default, so can range check early.\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  var i;\n\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n}; // HELPER FUNCTIONS\n// ================\n\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); // is surrogate component\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } // valid lead\n\n\n        leadSurrogate = codePoint;\n        continue;\n      } // 2 leads in a row\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      } // valid surrogate pair\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null; // encode utf8\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///(webpack)/node_modules/buffer/index.js?")},"./node_modules/webpack/node_modules/events/events.js":function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar R = (typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\n\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\nmodule.exports = EventEmitter; // Backwards-compat with node 0.10.x\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nvar defaultMaxListeners = 10;\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    } // At least give some kind of context to the user\n\n\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      ReflectApply(listeners[i], this, args);\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n\n  events = target._events;\n\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    } // Check for listener leak\n\n\n    m = $getMaxListeners(target);\n\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true; // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  var args = [];\n\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }\n\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\n//# sourceURL=webpack:///(webpack)/node_modules/events/events.js?")},"./node_modules/webpack/node_modules/ieee754/index.js":function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n//# sourceURL=webpack:///(webpack)/node_modules/ieee754/index.js?")},"./node_modules/webpack/node_modules/isarray/index.js":function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n//# sourceURL=webpack:///(webpack)/node_modules/isarray/index.js?")},"./node_modules/webpack/node_modules/safe-buffer/index.js":function(module,exports,__webpack_require__){eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/webpack/node_modules/buffer/index.js\");\n\nvar Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\nfunction copyProps(src, dst) {\n  for (var key in src) {\n    dst[key] = src[key];\n  }\n}\n\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer;\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports);\n  exports.Buffer = SafeBuffer;\n}\n\nfunction SafeBuffer(arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length);\n} // Copy static methods from Buffer\n\n\ncopyProps(Buffer, SafeBuffer);\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number');\n  }\n\n  return Buffer(arg, encodingOrOffset, length);\n};\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n\n  var buf = Buffer(size);\n\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n  } else {\n    buf.fill(0);\n  }\n\n  return buf;\n};\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n\n  return Buffer(size);\n};\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n\n  return buffer.SlowBuffer(size);\n};\n\n//# sourceURL=webpack:///(webpack)/node_modules/safe-buffer/index.js?")},"./node_modules/webpack/node_modules/string_decoder/lib/string_decoder.js":function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/webpack/node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n\n      default:\n        if (retried) return; // undefined\n\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n\n; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\n\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n} // StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\n\n\nexports.StringDecoder = StringDecoder;\n\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\nStringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\n\n\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n} // Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\n\n\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n\n    return nb;\n  }\n\n  return 0;\n} // Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\n\n\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return \"\\uFFFD\";\n  }\n\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return \"\\uFFFD\";\n    }\n\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return \"\\uFFFD\";\n      }\n    }\n  }\n} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\n\n\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n} // For UTF-8, a replacement character is added when ending on a partial\n// character.\n\n\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + \"\\uFFFD\";\n  return r;\n} // UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\n\n\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n\n    return r;\n  }\n\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n} // For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\n\n\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack:///(webpack)/node_modules/string_decoder/lib/string_decoder.js?")}}]);