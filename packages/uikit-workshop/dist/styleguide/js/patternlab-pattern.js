/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./styleguide/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/scripts/patternlab-pattern.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*!\n * clipboard.js v2.0.4\n * https://zenorocha.github.io/clipboard.js\n * \n * Licensed MIT Â© Zeno Rocha\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _clipboardAction = __webpack_require__(1);\n\n      var _clipboardAction2 = _interopRequireDefault(_clipboardAction);\n\n      var _tinyEmitter = __webpack_require__(3);\n\n      var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);\n\n      var _goodListener = __webpack_require__(4);\n\n      var _goodListener2 = _interopRequireDefault(_goodListener);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof2(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof2(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Base class which takes one or more elements, adds event listeners to them,\n       * and instantiates a new `ClipboardAction` on each click.\n       */\n\n\n      var Clipboard = function (_Emitter) {\n        _inherits(Clipboard, _Emitter);\n        /**\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         * @param {Object} options\n         */\n\n\n        function Clipboard(trigger, options) {\n          _classCallCheck(this, Clipboard);\n\n          var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));\n\n          _this.resolveOptions(options);\n\n          _this.listenClick(trigger);\n\n          return _this;\n        }\n        /**\n         * Defines if attributes would be resolved using internal setter functions\n         * or custom functions that were passed in the constructor.\n         * @param {Object} options\n         */\n\n\n        _createClass(Clipboard, [{\n          key: 'resolveOptions',\n          value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;\n            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;\n            this.text = typeof options.text === 'function' ? options.text : this.defaultText;\n            this.container = _typeof(options.container) === 'object' ? options.container : document.body;\n          }\n          /**\n           * Adds a click event listener to the passed trigger.\n           * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n           */\n\n        }, {\n          key: 'listenClick',\n          value: function listenClick(trigger) {\n            var _this2 = this;\n\n            this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {\n              return _this2.onClick(e);\n            });\n          }\n          /**\n           * Defines a new `ClipboardAction` on each click event.\n           * @param {Event} e\n           */\n\n        }, {\n          key: 'onClick',\n          value: function onClick(e) {\n            var trigger = e.delegateTarget || e.currentTarget;\n\n            if (this.clipboardAction) {\n              this.clipboardAction = null;\n            }\n\n            this.clipboardAction = new _clipboardAction2.default({\n              action: this.action(trigger),\n              target: this.target(trigger),\n              text: this.text(trigger),\n              container: this.container,\n              trigger: trigger,\n              emitter: this\n            });\n          }\n          /**\n           * Default `action` lookup function.\n           * @param {Element} trigger\n           */\n\n        }, {\n          key: 'defaultAction',\n          value: function defaultAction(trigger) {\n            return getAttributeValue('action', trigger);\n          }\n          /**\n           * Default `target` lookup function.\n           * @param {Element} trigger\n           */\n\n        }, {\n          key: 'defaultTarget',\n          value: function defaultTarget(trigger) {\n            var selector = getAttributeValue('target', trigger);\n\n            if (selector) {\n              return document.querySelector(selector);\n            }\n          }\n          /**\n           * Returns the support of the given action, or all actions if no action is\n           * given.\n           * @param {String} [action]\n           */\n\n        }, {\n          key: 'defaultText',\n\n          /**\n           * Default `text` lookup function.\n           * @param {Element} trigger\n           */\n          value: function defaultText(trigger) {\n            return getAttributeValue('text', trigger);\n          }\n          /**\n           * Destroy lifecycle.\n           */\n\n        }, {\n          key: 'destroy',\n          value: function destroy() {\n            this.listener.destroy();\n\n            if (this.clipboardAction) {\n              this.clipboardAction.destroy();\n              this.clipboardAction = null;\n            }\n          }\n        }], [{\n          key: 'isSupported',\n          value: function isSupported() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];\n            var actions = typeof action === 'string' ? [action] : action;\n            var support = !!document.queryCommandSupported;\n            actions.forEach(function (action) {\n              support = support && !!document.queryCommandSupported(action);\n            });\n            return support;\n          }\n        }]);\n\n        return Clipboard;\n      }(_tinyEmitter2.default);\n      /**\n       * Helper function to retrieve attribute value.\n       * @param {String} suffix\n       * @param {Element} element\n       */\n\n\n      function getAttributeValue(suffix, element) {\n        var attribute = 'data-clipboard-' + suffix;\n\n        if (!element.hasAttribute(attribute)) {\n          return;\n        }\n\n        return element.getAttribute(attribute);\n      }\n\n      module.exports = Clipboard;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _select = __webpack_require__(2);\n\n      var _select2 = _interopRequireDefault(_select);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Inner class which performs selection from either `text` or `target`\n       * properties and then executes copy or cut operations.\n       */\n\n\n      var ClipboardAction = function () {\n        /**\n         * @param {Object} options\n         */\n        function ClipboardAction(options) {\n          _classCallCheck(this, ClipboardAction);\n\n          this.resolveOptions(options);\n          this.initSelection();\n        }\n        /**\n         * Defines base properties passed from constructor.\n         * @param {Object} options\n         */\n\n\n        _createClass(ClipboardAction, [{\n          key: 'resolveOptions',\n          value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            this.action = options.action;\n            this.container = options.container;\n            this.emitter = options.emitter;\n            this.target = options.target;\n            this.text = options.text;\n            this.trigger = options.trigger;\n            this.selectedText = '';\n          }\n          /**\n           * Decides which selection strategy is going to be applied based\n           * on the existence of `text` and `target` properties.\n           */\n\n        }, {\n          key: 'initSelection',\n          value: function initSelection() {\n            if (this.text) {\n              this.selectFake();\n            } else if (this.target) {\n              this.selectTarget();\n            }\n          }\n          /**\n           * Creates a fake textarea element, sets its value from `text` property,\n           * and makes a selection on it.\n           */\n\n        }, {\n          key: 'selectFake',\n          value: function selectFake() {\n            var _this = this;\n\n            var isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n            this.removeFake();\n\n            this.fakeHandlerCallback = function () {\n              return _this.removeFake();\n            };\n\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n            this.fakeElem = document.createElement('textarea'); // Prevent zooming on iOS\n\n            this.fakeElem.style.fontSize = '12pt'; // Reset box model\n\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0'; // Move element out of screen horizontally\n\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n            var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = yPosition + 'px';\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n            this.container.appendChild(this.fakeElem);\n            this.selectedText = (0, _select2.default)(this.fakeElem);\n            this.copyText();\n          }\n          /**\n           * Only removes the fake element after another click event, that way\n           * a user can hit `Ctrl+C` to copy because selection still exists.\n           */\n\n        }, {\n          key: 'removeFake',\n          value: function removeFake() {\n            if (this.fakeHandler) {\n              this.container.removeEventListener('click', this.fakeHandlerCallback);\n              this.fakeHandler = null;\n              this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n              this.container.removeChild(this.fakeElem);\n              this.fakeElem = null;\n            }\n          }\n          /**\n           * Selects the content from element passed on `target` property.\n           */\n\n        }, {\n          key: 'selectTarget',\n          value: function selectTarget() {\n            this.selectedText = (0, _select2.default)(this.target);\n            this.copyText();\n          }\n          /**\n           * Executes the copy operation based on the current selection.\n           */\n\n        }, {\n          key: 'copyText',\n          value: function copyText() {\n            var succeeded = void 0;\n\n            try {\n              succeeded = document.execCommand(this.action);\n            } catch (err) {\n              succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n          }\n          /**\n           * Fires an event based on the copy operation result.\n           * @param {Boolean} succeeded\n           */\n\n        }, {\n          key: 'handleResult',\n          value: function handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n              action: this.action,\n              text: this.selectedText,\n              trigger: this.trigger,\n              clearSelection: this.clearSelection.bind(this)\n            });\n          }\n          /**\n           * Moves focus away from `target` and back to the trigger, removes current selection.\n           */\n\n        }, {\n          key: 'clearSelection',\n          value: function clearSelection() {\n            if (this.trigger) {\n              this.trigger.focus();\n            }\n\n            window.getSelection().removeAllRanges();\n          }\n          /**\n           * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n           * @param {String} action\n           */\n\n        }, {\n          key: 'destroy',\n\n          /**\n           * Destroy lifecycle.\n           */\n          value: function destroy() {\n            this.removeFake();\n          }\n        }, {\n          key: 'action',\n          set: function set() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n              throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n          }\n          /**\n           * Gets the `action` property.\n           * @return {String}\n           */\n          ,\n          get: function get() {\n            return this._action;\n          }\n          /**\n           * Sets the `target` property using an element\n           * that will be have its content copied.\n           * @param {Element} target\n           */\n\n        }, {\n          key: 'target',\n          set: function set(target) {\n            if (target !== undefined) {\n              if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {\n                if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                  throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                }\n\n                if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                  throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                }\n\n                this._target = target;\n              } else {\n                throw new Error('Invalid \"target\" value, use a valid Element');\n              }\n            }\n          }\n          /**\n           * Gets the `target` property.\n           * @return {String|HTMLElement}\n           */\n          ,\n          get: function get() {\n            return this._target;\n          }\n        }]);\n\n        return ClipboardAction;\n      }();\n\n      module.exports = ClipboardAction;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      function select(element) {\n        var selectedText;\n\n        if (element.nodeName === 'SELECT') {\n          element.focus();\n          selectedText = element.value;\n        } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n          var isReadOnly = element.hasAttribute('readonly');\n\n          if (!isReadOnly) {\n            element.setAttribute('readonly', '');\n          }\n\n          element.select();\n          element.setSelectionRange(0, element.value.length);\n\n          if (!isReadOnly) {\n            element.removeAttribute('readonly');\n          }\n\n          selectedText = element.value;\n        } else {\n          if (element.hasAttribute('contenteditable')) {\n            element.focus();\n          }\n\n          var selection = window.getSelection();\n          var range = document.createRange();\n          range.selectNodeContents(element);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          selectedText = selection.toString();\n        }\n\n        return selectedText;\n      }\n\n      module.exports = select;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      function E() {// Keep this empty so it's easier to inherit from\n        // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n      }\n\n      E.prototype = {\n        on: function on(name, callback, ctx) {\n          var e = this.e || (this.e = {});\n          (e[name] || (e[name] = [])).push({\n            fn: callback,\n            ctx: ctx\n          });\n          return this;\n        },\n        once: function once(name, callback, ctx) {\n          var self = this;\n\n          function listener() {\n            self.off(name, listener);\n            callback.apply(ctx, arguments);\n          }\n\n          ;\n          listener._ = callback;\n          return this.on(name, listener, ctx);\n        },\n        emit: function emit(name) {\n          var data = [].slice.call(arguments, 1);\n          var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n          var i = 0;\n          var len = evtArr.length;\n\n          for (i; i < len; i++) {\n            evtArr[i].fn.apply(evtArr[i].ctx, data);\n          }\n\n          return this;\n        },\n        off: function off(name, callback) {\n          var e = this.e || (this.e = {});\n          var evts = e[name];\n          var liveEvents = [];\n\n          if (evts && callback) {\n            for (var i = 0, len = evts.length; i < len; i++) {\n              if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);\n            }\n          } // Remove event from queue to prevent memory leak\n          // Suggested by https://github.com/lazd\n          // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n\n          liveEvents.length ? e[name] = liveEvents : delete e[name];\n          return this;\n        }\n      };\n      module.exports = E;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var is = __webpack_require__(5);\n\n      var delegate = __webpack_require__(6);\n      /**\n       * Validates all params and calls the right\n       * listener function based on its target type.\n       *\n       * @param {String|HTMLElement|HTMLCollection|NodeList} target\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listen(target, type, callback) {\n        if (!target && !type && !callback) {\n          throw new Error('Missing required arguments');\n        }\n\n        if (!is.string(type)) {\n          throw new TypeError('Second argument must be a String');\n        }\n\n        if (!is.fn(callback)) {\n          throw new TypeError('Third argument must be a Function');\n        }\n\n        if (is.node(target)) {\n          return listenNode(target, type, callback);\n        } else if (is.nodeList(target)) {\n          return listenNodeList(target, type, callback);\n        } else if (is.string(target)) {\n          return listenSelector(target, type, callback);\n        } else {\n          throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');\n        }\n      }\n      /**\n       * Adds an event listener to a HTML element\n       * and returns a remove listener function.\n       *\n       * @param {HTMLElement} node\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenNode(node, type, callback) {\n        node.addEventListener(type, callback);\n        return {\n          destroy: function destroy() {\n            node.removeEventListener(type, callback);\n          }\n        };\n      }\n      /**\n       * Add an event listener to a list of HTML elements\n       * and returns a remove listener function.\n       *\n       * @param {NodeList|HTMLCollection} nodeList\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenNodeList(nodeList, type, callback) {\n        Array.prototype.forEach.call(nodeList, function (node) {\n          node.addEventListener(type, callback);\n        });\n        return {\n          destroy: function destroy() {\n            Array.prototype.forEach.call(nodeList, function (node) {\n              node.removeEventListener(type, callback);\n            });\n          }\n        };\n      }\n      /**\n       * Add an event listener to a selector\n       * and returns a remove listener function.\n       *\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenSelector(selector, type, callback) {\n        return delegate(document.body, selector, type, callback);\n      }\n\n      module.exports = listen;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Check if argument is a HTML element.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n      exports.node = function (value) {\n        return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;\n      };\n      /**\n       * Check if argument is a list of HTML elements.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.nodeList = function (value) {\n        var type = Object.prototype.toString.call(value);\n        return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));\n      };\n      /**\n       * Check if argument is a string.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.string = function (value) {\n        return typeof value === 'string' || value instanceof String;\n      };\n      /**\n       * Check if argument is a function.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.fn = function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Function]';\n      };\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var closest = __webpack_require__(7);\n      /**\n       * Delegates event to a selector.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @param {Boolean} useCapture\n       * @return {Object}\n       */\n\n\n      function _delegate(element, selector, type, callback, useCapture) {\n        var listenerFn = listener.apply(this, arguments);\n        element.addEventListener(type, listenerFn, useCapture);\n        return {\n          destroy: function destroy() {\n            element.removeEventListener(type, listenerFn, useCapture);\n          }\n        };\n      }\n      /**\n       * Delegates event to a selector.\n       *\n       * @param {Element|String|Array} [elements]\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @param {Boolean} useCapture\n       * @return {Object}\n       */\n\n\n      function delegate(elements, selector, type, callback, useCapture) {\n        // Handle the regular Element usage\n        if (typeof elements.addEventListener === 'function') {\n          return _delegate.apply(null, arguments);\n        } // Handle Element-less usage, it defaults to global delegation\n\n\n        if (typeof type === 'function') {\n          // Use `document` as the first parameter, then apply arguments\n          // This is a short way to .unshift `arguments` without running into deoptimizations\n          return _delegate.bind(null, document).apply(null, arguments);\n        } // Handle Selector-based usage\n\n\n        if (typeof elements === 'string') {\n          elements = document.querySelectorAll(elements);\n        } // Handle Array-like based usage\n\n\n        return Array.prototype.map.call(elements, function (element) {\n          return _delegate(element, selector, type, callback, useCapture);\n        });\n      }\n      /**\n       * Finds closest match and invokes callback.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Function}\n       */\n\n\n      function listener(element, selector, type, callback) {\n        return function (e) {\n          e.delegateTarget = closest(e.target, selector);\n\n          if (e.delegateTarget) {\n            callback.call(element, e);\n          }\n        };\n      }\n\n      module.exports = delegate;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports) {\n      var DOCUMENT_NODE_TYPE = 9;\n      /**\n       * A polyfill for Element.matches()\n       */\n\n      if (typeof Element !== 'undefined' && !Element.prototype.matches) {\n        var proto = Element.prototype;\n        proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;\n      }\n      /**\n       * Finds the closest parent that matches a selector.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @return {Function}\n       */\n\n\n      function closest(element, selector) {\n        while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\n          if (typeof element.matches === 'function' && element.matches(selector)) {\n            return element;\n          }\n\n          element = element.parentNode;\n        }\n      }\n\n      module.exports = closest;\n      /***/\n    }])\n  );\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/clipboard/dist/clipboard.js?");

/***/ }),

/***/ "./node_modules/iframe-resizer/js/iframeResizer.contentWindow.min.js":
/*!***************************************************************************!*\
  !*** ./node_modules/iframe-resizer/js/iframeResizer.contentWindow.min.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! iFrame Resizer (iframeSizer.contentWindow.min.js) - v3.6.6 - 2019-02-26\n *  Desc: Include this file in any page being loaded into an iframe\n *        to force the iframe to resize to the content size.\n *  Requires: iframeResizer.min.js on host page.\n *  Copyright: (c) 2019 David J. Bradshaw - dave@bradshaw.net\n *  License: MIT\n */\n!function (d) {\n  \"use strict\";\n\n  if (\"undefined\" != typeof window) {\n    var n = !0,\n        i = 10,\n        o = \"\",\n        r = 0,\n        a = \"\",\n        t = null,\n        u = \"\",\n        c = !1,\n        s = {\n      resize: 1,\n      click: 1\n    },\n        l = 128,\n        f = !0,\n        m = 1,\n        g = \"bodyOffset\",\n        h = g,\n        p = !0,\n        v = \"\",\n        y = {},\n        w = 32,\n        e = null,\n        b = !1,\n        T = \"[iFrameSizer]\",\n        E = T.length,\n        S = \"\",\n        O = {\n      max: 1,\n      min: 1,\n      bodyScroll: 1,\n      documentElementScroll: 1\n    },\n        M = \"child\",\n        I = !0,\n        N = window.parent,\n        C = \"*\",\n        k = 0,\n        A = !1,\n        x = null,\n        z = 16,\n        L = 1,\n        R = \"scroll\",\n        F = R,\n        P = window,\n        D = function D() {\n      ue(\"MessageCallback function not defined\");\n    },\n        q = function q() {},\n        H = function H() {},\n        W = {\n      height: function height() {\n        return ue(\"Custom height calculation function not defined\"), document.documentElement.offsetHeight;\n      },\n      width: function width() {\n        return ue(\"Custom width calculation function not defined\"), document.body.scrollWidth;\n      }\n    },\n        j = {},\n        B = !1;\n\n    try {\n      var V = Object.create({}, {\n        passive: {\n          get: function get() {\n            B = !0;\n          }\n        },\n        once: {\n          get: function get() {\n            !0;\n          }\n        }\n      });\n      window.addEventListener(\"test\", te, V), window.removeEventListener(\"test\", te, V);\n    } catch (e) {}\n\n    var J,\n        U,\n        K,\n        Q,\n        X,\n        Y,\n        $,\n        G = Date.now || function () {\n      return new Date().getTime();\n    },\n        Z = {\n      bodyOffset: function bodyOffset() {\n        return document.body.offsetHeight + ye(\"marginTop\") + ye(\"marginBottom\");\n      },\n      offset: function offset() {\n        return Z.bodyOffset();\n      },\n      bodyScroll: function bodyScroll() {\n        return document.body.scrollHeight;\n      },\n      custom: function custom() {\n        return W.height();\n      },\n      documentElementOffset: function documentElementOffset() {\n        return document.documentElement.offsetHeight;\n      },\n      documentElementScroll: function documentElementScroll() {\n        return document.documentElement.scrollHeight;\n      },\n      max: function max() {\n        return Math.max.apply(null, be(Z));\n      },\n      min: function min() {\n        return Math.min.apply(null, be(Z));\n      },\n      grow: function grow() {\n        return Z.max();\n      },\n      lowestElement: function lowestElement() {\n        return Math.max(Z.bodyOffset() || Z.documentElementOffset(), we(\"bottom\", Ee()));\n      },\n      taggedElement: function taggedElement() {\n        return Te(\"bottom\", \"data-iframe-height\");\n      }\n    },\n        _ = {\n      bodyScroll: function bodyScroll() {\n        return document.body.scrollWidth;\n      },\n      bodyOffset: function bodyOffset() {\n        return document.body.offsetWidth;\n      },\n      custom: function custom() {\n        return W.width();\n      },\n      documentElementScroll: function documentElementScroll() {\n        return document.documentElement.scrollWidth;\n      },\n      documentElementOffset: function documentElementOffset() {\n        return document.documentElement.offsetWidth;\n      },\n      scroll: function scroll() {\n        return Math.max(_.bodyScroll(), _.documentElementScroll());\n      },\n      max: function max() {\n        return Math.max.apply(null, be(_));\n      },\n      min: function min() {\n        return Math.min.apply(null, be(_));\n      },\n      rightMostElement: function rightMostElement() {\n        return we(\"right\", Ee());\n      },\n      taggedElement: function taggedElement() {\n        return Te(\"right\", \"data-iframe-width\");\n      }\n    },\n        ee = (J = Se, X = null, Y = 0, $ = function $() {\n      Y = G(), X = null, Q = J.apply(U, K), X || (U = K = null);\n    }, function () {\n      var e = G();\n      Y || (Y = e);\n      var t = z - (e - Y);\n      return U = this, K = arguments, t <= 0 || z < t ? (X && (clearTimeout(X), X = null), Y = e, Q = J.apply(U, K), X || (U = K = null)) : X || (X = setTimeout($, t)), Q;\n    });\n\n    ne(window, \"message\", ke), ne(window, \"readystatechange\", Ae), Ae();\n  }\n\n  function te() {}\n\n  function ne(e, t, n, o) {\n    \"addEventListener\" in window ? e.addEventListener(t, n, !!B && (o || {})) : \"attachEvent\" in window && e.attachEvent(\"on\" + t, n);\n  }\n\n  function oe(e, t, n) {\n    \"removeEventListener\" in window ? e.removeEventListener(t, n, !1) : \"detachEvent\" in window && e.detachEvent(\"on\" + t, n);\n  }\n\n  function ie(e) {\n    return e.charAt(0).toUpperCase() + e.slice(1);\n  }\n\n  function re(e) {\n    return T + \"[\" + S + \"] \" + e;\n  }\n\n  function ae(e) {\n    b && \"object\" == _typeof(window.console) && console.log(re(e));\n  }\n\n  function ue(e) {\n    \"object\" == _typeof(window.console) && console.warn(re(e));\n  }\n\n  function ce() {\n    var e;\n    !function () {\n      function e(e) {\n        return \"true\" === e;\n      }\n\n      var t = v.substr(E).split(\":\");\n      S = t[0], r = d !== t[1] ? Number(t[1]) : r, c = d !== t[2] ? e(t[2]) : c, b = d !== t[3] ? e(t[3]) : b, w = d !== t[4] ? Number(t[4]) : w, n = d !== t[6] ? e(t[6]) : n, a = t[7], h = d !== t[8] ? t[8] : h, o = t[9], u = t[10], k = d !== t[11] ? Number(t[11]) : k, y.enable = d !== t[12] && e(t[12]), M = d !== t[13] ? t[13] : M, F = d !== t[14] ? t[14] : F;\n    }(), ae(\"Initialising iFrame (\" + location.href + \")\"), function () {\n      function e(e, t) {\n        return \"function\" == typeof e && (ae(\"Setup custom \" + t + \"CalcMethod\"), W[t] = e, e = \"custom\"), e;\n      }\n\n      \"iFrameResizer\" in window && Object === window.iFrameResizer.constructor && (t = window.iFrameResizer, ae(\"Reading data from page: \" + JSON.stringify(t)), D = \"messageCallback\" in t ? t.messageCallback : D, q = \"readyCallback\" in t ? t.readyCallback : q, C = \"targetOrigin\" in t ? t.targetOrigin : C, h = \"heightCalculationMethod\" in t ? t.heightCalculationMethod : h, F = \"widthCalculationMethod\" in t ? t.widthCalculationMethod : F, h = e(h, \"height\"), F = e(F, \"width\"));\n      var t;\n      ae(\"TargetOrigin for parent set to: \" + C);\n    }(), function () {\n      d === a && (a = r + \"px\");\n      se(\"margin\", function (e, t) {\n        -1 !== t.indexOf(\"-\") && (ue(\"Negative CSS value ignored for \" + e), t = \"\");\n        return t;\n      }(\"margin\", a));\n    }(), se(\"background\", o), se(\"padding\", u), (e = document.createElement(\"div\")).style.clear = \"both\", e.style.display = \"block\", document.body.appendChild(e), me(), ge(), document.documentElement.style.height = \"\", document.body.style.height = \"\", ae('HTML & body height set to \"auto\"'), ae(\"Enable public methods\"), P.parentIFrame = {\n      autoResize: function autoResize(e) {\n        return !0 === e && !1 === n ? (n = !0, he()) : !1 === e && !0 === n && (n = !1, pe()), n;\n      },\n      close: function close() {\n        Ce(0, 0, \"close\"), ae(\"Disable outgoing messages\"), I = !1, ae(\"Remove event listener: Message\"), oe(window, \"message\", ke), !0 === n && pe();\n      },\n      getId: function getId() {\n        return S;\n      },\n      getPageInfo: function getPageInfo(e) {\n        \"function\" == typeof e ? (H = e, Ce(0, 0, \"pageInfo\")) : (H = function H() {}, Ce(0, 0, \"pageInfoStop\"));\n      },\n      moveToAnchor: function moveToAnchor(e) {\n        y.findTarget(e);\n      },\n      reset: function reset() {\n        Ne(\"parentIFrame.reset\");\n      },\n      scrollTo: function scrollTo(e, t) {\n        Ce(t, e, \"scrollTo\");\n      },\n      scrollToOffset: function scrollToOffset(e, t) {\n        Ce(t, e, \"scrollToOffset\");\n      },\n      sendMessage: function sendMessage(e, t) {\n        Ce(0, 0, \"message\", JSON.stringify(e), t);\n      },\n      setHeightCalculationMethod: function setHeightCalculationMethod(e) {\n        h = e, me();\n      },\n      setWidthCalculationMethod: function setWidthCalculationMethod(e) {\n        F = e, ge();\n      },\n      setTargetOrigin: function setTargetOrigin(e) {\n        ae(\"Set targetOrigin: \" + e), C = e;\n      },\n      size: function size(e, t) {\n        var n = (e || \"\") + (t ? \",\" + t : \"\");\n        Oe(\"size\", \"parentIFrame.size(\" + n + \")\", e, t);\n      }\n    }, he(), y = function () {\n      function r(e) {\n        var t = e.getBoundingClientRect(),\n            n = {\n          x: window.pageXOffset !== d ? window.pageXOffset : document.documentElement.scrollLeft,\n          y: window.pageYOffset !== d ? window.pageYOffset : document.documentElement.scrollTop\n        };\n        return {\n          x: parseInt(t.left, 10) + parseInt(n.x, 10),\n          y: parseInt(t.top, 10) + parseInt(n.y, 10)\n        };\n      }\n\n      function n(e) {\n        var t,\n            n = e.split(\"#\")[1] || e,\n            o = decodeURIComponent(n),\n            i = document.getElementById(o) || document.getElementsByName(o)[0];\n        d !== i ? (t = r(i), ae(\"Moving to in page link (#\" + n + \") at x: \" + t.x + \" y: \" + t.y), Ce(t.y, t.x, \"scrollToOffset\")) : (ae(\"In page link (#\" + n + \") not found in iFrame, so sending to parent\"), Ce(0, 0, \"inPageLink\", \"#\" + n));\n      }\n\n      function e() {\n        \"\" !== location.hash && \"#\" !== location.hash && n(location.href);\n      }\n\n      function t() {\n        Array.prototype.forEach.call(document.querySelectorAll('a[href^=\"#\"]'), function (e) {\n          function t(e) {\n            e.preventDefault(), n(this.getAttribute(\"href\"));\n          }\n\n          \"#\" !== e.getAttribute(\"href\") && ne(e, \"click\", t);\n        });\n      }\n\n      y.enable ? Array.prototype.forEach && document.querySelectorAll ? (ae(\"Setting up location.hash handlers\"), t(), ne(window, \"hashchange\", e), setTimeout(e, l)) : ue(\"In page linking not fully supported in this browser! (See README.md for IE8 workaround)\") : ae(\"In page linking not enabled\");\n      return {\n        findTarget: n\n      };\n    }(), Oe(\"init\", \"Init message from host page\"), q();\n  }\n\n  function se(e, t) {\n    d !== t && \"\" !== t && \"null\" !== t && ae(\"Body \" + e + ' set to \"' + (document.body.style[e] = t) + '\"');\n  }\n\n  function le(n) {\n    var e = {\n      add: function add(e) {\n        function t() {\n          Oe(n.eventName, n.eventType);\n        }\n\n        j[e] = t, ne(window, e, t, {\n          passive: !0\n        });\n      },\n      remove: function remove(e) {\n        var t = j[e];\n        delete j[e], oe(window, e, t);\n      }\n    };\n    n.eventNames && Array.prototype.map ? (n.eventName = n.eventNames[0], n.eventNames.map(e[n.method])) : e[n.method](n.eventName), ae(ie(n.method) + \" event listener: \" + n.eventType);\n  }\n\n  function de(e) {\n    le({\n      method: e,\n      eventType: \"Animation Start\",\n      eventNames: [\"animationstart\", \"webkitAnimationStart\"]\n    }), le({\n      method: e,\n      eventType: \"Animation Iteration\",\n      eventNames: [\"animationiteration\", \"webkitAnimationIteration\"]\n    }), le({\n      method: e,\n      eventType: \"Animation End\",\n      eventNames: [\"animationend\", \"webkitAnimationEnd\"]\n    }), le({\n      method: e,\n      eventType: \"Input\",\n      eventName: \"input\"\n    }), le({\n      method: e,\n      eventType: \"Mouse Up\",\n      eventName: \"mouseup\"\n    }), le({\n      method: e,\n      eventType: \"Mouse Down\",\n      eventName: \"mousedown\"\n    }), le({\n      method: e,\n      eventType: \"Orientation Change\",\n      eventName: \"orientationchange\"\n    }), le({\n      method: e,\n      eventType: \"Print\",\n      eventName: [\"afterprint\", \"beforeprint\"]\n    }), le({\n      method: e,\n      eventType: \"Ready State Change\",\n      eventName: \"readystatechange\"\n    }), le({\n      method: e,\n      eventType: \"Touch Start\",\n      eventName: \"touchstart\"\n    }), le({\n      method: e,\n      eventType: \"Touch End\",\n      eventName: \"touchend\"\n    }), le({\n      method: e,\n      eventType: \"Touch Cancel\",\n      eventName: \"touchcancel\"\n    }), le({\n      method: e,\n      eventType: \"Transition Start\",\n      eventNames: [\"transitionstart\", \"webkitTransitionStart\", \"MSTransitionStart\", \"oTransitionStart\", \"otransitionstart\"]\n    }), le({\n      method: e,\n      eventType: \"Transition Iteration\",\n      eventNames: [\"transitioniteration\", \"webkitTransitionIteration\", \"MSTransitionIteration\", \"oTransitionIteration\", \"otransitioniteration\"]\n    }), le({\n      method: e,\n      eventType: \"Transition End\",\n      eventNames: [\"transitionend\", \"webkitTransitionEnd\", \"MSTransitionEnd\", \"oTransitionEnd\", \"otransitionend\"]\n    }), \"child\" === M && le({\n      method: e,\n      eventType: \"IFrame Resized\",\n      eventName: \"resize\"\n    });\n  }\n\n  function fe(e, t, n, o) {\n    return t !== e && (e in n || (ue(e + \" is not a valid option for \" + o + \"CalculationMethod.\"), e = t), ae(o + ' calculation method set to \"' + e + '\"')), e;\n  }\n\n  function me() {\n    h = fe(h, g, Z, \"height\");\n  }\n\n  function ge() {\n    F = fe(F, R, _, \"width\");\n  }\n\n  function he() {\n    var e;\n    !0 === n ? (de(\"add\"), e = w < 0, window.MutationObserver || window.WebKitMutationObserver ? e ? ve() : t = function () {\n      function t(e) {\n        function t(e) {\n          !1 === e.complete && (ae(\"Attach listeners to \" + e.src), e.addEventListener(\"load\", i, !1), e.addEventListener(\"error\", r, !1), c.push(e));\n        }\n\n        \"attributes\" === e.type && \"src\" === e.attributeName ? t(e.target) : \"childList\" === e.type && Array.prototype.forEach.call(e.target.querySelectorAll(\"img\"), t);\n      }\n\n      function o(e) {\n        var t;\n        ae(\"Remove listeners from \" + e.src), e.removeEventListener(\"load\", i, !1), e.removeEventListener(\"error\", r, !1), t = e, c.splice(c.indexOf(t), 1);\n      }\n\n      function n(e, t, n) {\n        o(e.target), Oe(t, n + \": \" + e.target.src, d, d);\n      }\n\n      function i(e) {\n        n(e, \"imageLoad\", \"Image loaded\");\n      }\n\n      function r(e) {\n        n(e, \"imageLoadFailed\", \"Image load failed\");\n      }\n\n      function e(e) {\n        Oe(\"mutationObserver\", \"mutationObserver: \" + e[0].target + \" \" + e[0].type), e.forEach(t);\n      }\n\n      var a,\n          u,\n          c = [],\n          s = window.MutationObserver || window.WebKitMutationObserver,\n          l = (a = document.querySelector(\"body\"), u = {\n        attributes: !0,\n        attributeOldValue: !1,\n        characterData: !0,\n        characterDataOldValue: !1,\n        childList: !0,\n        subtree: !0\n      }, l = new s(e), ae(\"Create body MutationObserver\"), l.observe(a, u), l);\n      return {\n        disconnect: function disconnect() {\n          \"disconnect\" in l && (ae(\"Disconnect body MutationObserver\"), l.disconnect(), c.forEach(o));\n        }\n      };\n    }() : (ae(\"MutationObserver not supported in this browser!\"), ve())) : ae(\"Auto Resize disabled\");\n  }\n\n  function pe() {\n    de(\"remove\"), null !== t && t.disconnect(), clearInterval(e);\n  }\n\n  function ve() {\n    0 !== w && (ae(\"setInterval: \" + w + \"ms\"), e = setInterval(function () {\n      Oe(\"interval\", \"setInterval: \" + w);\n    }, Math.abs(w)));\n  }\n\n  function ye(e, o) {\n    var t = 0;\n    return o = o || document.body, t = \"defaultView\" in document && \"getComputedStyle\" in document.defaultView ? null !== (t = document.defaultView.getComputedStyle(o, null)) ? t[e] : 0 : function (e) {\n      if (/^\\d+(px)?$/i.test(e)) return parseInt(e, i);\n      var t = o.style.left,\n          n = o.runtimeStyle.left;\n      return o.runtimeStyle.left = o.currentStyle.left, o.style.left = e || 0, e = o.style.pixelLeft, o.style.left = t, o.runtimeStyle.left = n, e;\n    }(o.currentStyle[e]), parseInt(t, i);\n  }\n\n  function we(e, t) {\n    for (var n, o = t.length, i = 0, r = 0, a = ie(e), u = G(), c = 0; c < o; c++) {\n      r < (i = t[c].getBoundingClientRect()[e] + ye(\"margin\" + a, t[c])) && (r = i);\n    }\n\n    return u = G() - u, ae(\"Parsed \" + o + \" HTML elements\"), ae(\"Element position calculated in \" + u + \"ms\"), z / 2 < (n = u) && ae(\"Event throttle increased to \" + (z = 2 * n) + \"ms\"), r;\n  }\n\n  function be(e) {\n    return [e.bodyOffset(), e.bodyScroll(), e.documentElementOffset(), e.documentElementScroll()];\n  }\n\n  function Te(e, t) {\n    var n = document.querySelectorAll(\"[\" + t + \"]\");\n    return 0 === n.length && (ue(\"No tagged elements (\" + t + \") found on page\"), document.querySelectorAll(\"body *\")), we(e, n);\n  }\n\n  function Ee() {\n    return document.querySelectorAll(\"body *\");\n  }\n\n  function Se(e, t, n, o) {\n    var i, r;\n    !function () {\n      function e(e, t) {\n        return !(Math.abs(e - t) <= k);\n      }\n\n      return i = d !== n ? n : Z[h](), r = d !== o ? o : _[F](), e(m, i) || c && e(L, r);\n    }() && \"init\" !== e ? e in {\n      init: 1,\n      interval: 1,\n      size: 1\n    } || !(h in O || c && F in O) ? e in {\n      interval: 1\n    } || ae(\"No change in size detected\") : Ne(t) : (Me(), Ce(m = i, L = r, e));\n  }\n\n  function Oe(e, t, n, o) {\n    A && e in s ? ae(\"Trigger event cancelled: \" + e) : (e in {\n      reset: 1,\n      resetPage: 1,\n      init: 1\n    } || ae(\"Trigger event: \" + t), \"init\" === e ? Se(e, t, n, o) : ee(e, t, n, o));\n  }\n\n  function Me() {\n    A || (A = !0, ae(\"Trigger event lock on\")), clearTimeout(x), x = setTimeout(function () {\n      A = !1, ae(\"Trigger event lock off\"), ae(\"--\");\n    }, l);\n  }\n\n  function Ie(e) {\n    m = Z[h](), L = _[F](), Ce(m, L, e);\n  }\n\n  function Ne(e) {\n    var t = h;\n    h = g, ae(\"Reset trigger event: \" + e), Me(), Ie(\"reset\"), h = t;\n  }\n\n  function Ce(e, t, n, o, i) {\n    var r;\n    !0 === I && (d === i ? i = C : ae(\"Message targetOrigin: \" + i), ae(\"Sending message to host page (\" + (r = S + \":\" + e + \":\" + t + \":\" + n + (d !== o ? \":\" + o : \"\")) + \")\"), N.postMessage(T + r, i));\n  }\n\n  function ke(t) {\n    var n = {\n      init: function init() {\n        v = t.data, N = t.source, ce(), f = !1, setTimeout(function () {\n          p = !1;\n        }, l);\n      },\n      reset: function reset() {\n        p ? ae(\"Page reset ignored by init\") : (ae(\"Page size reset by host page\"), Ie(\"resetPage\"));\n      },\n      resize: function resize() {\n        Oe(\"resizeParent\", \"Parent window requested size check\");\n      },\n      moveToAnchor: function moveToAnchor() {\n        y.findTarget(i());\n      },\n      inPageLink: function inPageLink() {\n        this.moveToAnchor();\n      },\n      pageInfo: function pageInfo() {\n        var e = i();\n        ae(\"PageInfoFromParent called from parent: \" + e), H(JSON.parse(e)), ae(\" --\");\n      },\n      message: function message() {\n        var e = i();\n        ae(\"MessageCallback called from parent: \" + e), D(JSON.parse(e)), ae(\" --\");\n      }\n    };\n\n    function o() {\n      return t.data.split(\"]\")[1].split(\":\")[0];\n    }\n\n    function i() {\n      return t.data.substr(t.data.indexOf(\":\") + 1);\n    }\n\n    function r() {\n      return t.data.split(\":\")[2] in {\n        true: 1,\n        false: 1\n      };\n    }\n\n    function e() {\n      var e = o();\n      e in n ? n[e]() : (\"undefined\" == typeof module || !module.exports) && \"iFrameResize\" in window || \"jQuery\" in window && \"iFrameResize\" in window.jQuery.prototype || r() || ue(\"Unexpected message (\" + t.data + \")\");\n    }\n\n    T === (\"\" + t.data).substr(0, E) && (!1 === f ? e() : r() ? n.init() : ae('Ignored message of type \"' + o() + '\". Received before initialization.'));\n  }\n\n  function Ae() {\n    \"loading\" !== document.readyState && window.parent.postMessage(\"[iFrameResizerChild]Ready\", \"*\");\n  }\n}();\n\n//# sourceURL=webpack:///./node_modules/iframe-resizer/js/iframeResizer.contentWindow.min.js?");

/***/ }),

/***/ "./node_modules/js-cookie/src/js.cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/js-cookie/src/js.cookie.js ***!
  \*************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * JavaScript Cookie v2.2.0\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;\n\n(function (factory) {\n  var registeredInModuleLoader = false;\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    registeredInModuleLoader = true;\n  }\n\n  if (( false ? undefined : _typeof(exports)) === 'object') {\n    module.exports = factory();\n    registeredInModuleLoader = true;\n  }\n\n  if (!registeredInModuleLoader) {\n    var OldCookies = window.Cookies;\n    var api = window.Cookies = factory();\n\n    api.noConflict = function () {\n      window.Cookies = OldCookies;\n      return api;\n    };\n  }\n})(function () {\n  function extend() {\n    var i = 0;\n    var result = {};\n\n    for (; i < arguments.length; i++) {\n      var attributes = arguments[i];\n\n      for (var key in attributes) {\n        result[key] = attributes[key];\n      }\n    }\n\n    return result;\n  }\n\n  function init(converter) {\n    function api(key, value, attributes) {\n      var result;\n\n      if (typeof document === 'undefined') {\n        return;\n      } // Write\n\n\n      if (arguments.length > 1) {\n        attributes = extend({\n          path: '/'\n        }, api.defaults, attributes);\n\n        if (typeof attributes.expires === 'number') {\n          var expires = new Date();\n          expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);\n          attributes.expires = expires;\n        } // We're using \"expires\" because \"max-age\" is not supported by IE\n\n\n        attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n        try {\n          result = JSON.stringify(value);\n\n          if (/^[\\{\\[]/.test(result)) {\n            value = result;\n          }\n        } catch (e) {}\n\n        if (!converter.write) {\n          value = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n        } else {\n          value = converter.write(value, key);\n        }\n\n        key = encodeURIComponent(String(key));\n        key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);\n        key = key.replace(/[\\(\\)]/g, escape);\n        var stringifiedAttributes = '';\n\n        for (var attributeName in attributes) {\n          if (!attributes[attributeName]) {\n            continue;\n          }\n\n          stringifiedAttributes += '; ' + attributeName;\n\n          if (attributes[attributeName] === true) {\n            continue;\n          }\n\n          stringifiedAttributes += '=' + attributes[attributeName];\n        }\n\n        return document.cookie = key + '=' + value + stringifiedAttributes;\n      } // Read\n\n\n      if (!key) {\n        result = {};\n      } // To prevent the for loop in the first place assign an empty array\n      // in case there are no cookies at all. Also prevents odd result when\n      // calling \"get()\"\n\n\n      var cookies = document.cookie ? document.cookie.split('; ') : [];\n      var rdecode = /(%[0-9A-Z]{2})+/g;\n      var i = 0;\n\n      for (; i < cookies.length; i++) {\n        var parts = cookies[i].split('=');\n        var cookie = parts.slice(1).join('=');\n\n        if (!this.json && cookie.charAt(0) === '\"') {\n          cookie = cookie.slice(1, -1);\n        }\n\n        try {\n          var name = parts[0].replace(rdecode, decodeURIComponent);\n          cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);\n\n          if (this.json) {\n            try {\n              cookie = JSON.parse(cookie);\n            } catch (e) {}\n          }\n\n          if (key === name) {\n            result = cookie;\n            break;\n          }\n\n          if (!key) {\n            result[name] = cookie;\n          }\n        } catch (e) {}\n      }\n\n      return result;\n    }\n\n    api.set = api;\n\n    api.get = function (key) {\n      return api.call(api, key);\n    };\n\n    api.getJSON = function () {\n      return api.apply({\n        json: true\n      }, [].slice.call(arguments));\n    };\n\n    api.defaults = {};\n\n    api.remove = function (key, attributes) {\n      api(key, '', extend(attributes, {\n        expires: -1\n      }));\n    };\n\n    api.withConverter = init;\n    return api;\n  }\n\n  return init(function () {});\n});\n\n//# sourceURL=webpack:///./node_modules/js-cookie/src/js.cookie.js?");

/***/ }),

/***/ "./node_modules/mousetrap/mousetrap.js":
/*!*********************************************!*\
  !*** ./node_modules/mousetrap/mousetrap.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.3\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n\n\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n\n  var _REVERSE_MAP;\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n\n\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n\n\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n\n\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n\n    object.attachEvent('on' + type, callback);\n  }\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n\n\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n\n      return character;\n    } // for non keypress events the special maps are needed\n\n\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    } // if it is not in the special map\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n\n\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n\n\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n\n\n  function _eventModifiers(e) {\n    var modifiers = [];\n\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n\n    return modifiers;\n  }\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n\n    e.returnValue = false;\n  }\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n\n    e.cancelBubble = true;\n  }\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n\n\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n\n    return _REVERSE_MAP;\n  }\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n\n\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    } // modifier keys don't work as expected with keypress,\n    // switch to keydown\n\n\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n\n    return action;\n  }\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n\n\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n\n\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = []; // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n\n    keys = _keysFromString(combination);\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i]; // normalize key names\n\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      } // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n\n\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      } // if this key is a modifier then add it to the list of modifiers\n\n\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    } // depending on what the key combination is\n    // we will try to pick the best event for it\n\n\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n\n    if (element === ancestor) {\n      return true;\n    }\n\n    return _belongsTo(element.parentNode, ancestor);\n  }\n\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n\n\n    self.target = targetElement;\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n\n    self._callbacks = {};\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n\n    self._directMap = {};\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n\n    var _sequenceLevels = {};\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n\n    var _resetTimer;\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n\n\n    var _ignoreNextKeyup = false;\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n\n    var _ignoreNextKeypress = false;\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n\n    var _nextExpectedAction = false;\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n          key;\n\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n\n        _sequenceLevels[key] = 0;\n      }\n\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n\n\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type; // if there are no events related to this keycode\n\n      if (!self._callbacks[character]) {\n        return [];\n      } // if a modifier key is coming up on its own we should allow it\n\n\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      } // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n\n\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        } // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n\n\n        if (action != callback.action) {\n          continue;\n        } // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n\n\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n\n          matches.push(callback);\n        }\n      }\n\n      return matches;\n    }\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n\n        _stopPropagation(e);\n      }\n    }\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      } // loop through matching callbacks for this key event\n\n\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n\n          processedSequenceCallback = true; // keep a list of which sequences were matches for later\n\n          doNotReset[callbacks[i].seq] = 1;\n\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\n          continue;\n        } // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n\n\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      } // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n\n\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n\n      var character = _characterFromEvent(e); // no character found then stop\n\n\n      if (!character) {\n        return;\n      } // need to use === for the character check because the character can be 0\n\n\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n\n\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n\n\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n\n          _resetSequenceTimer();\n        };\n      }\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n\n\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n\n\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        } // weird race condition if a sequence ends with the key\n        // another sequence begins with\n\n\n        setTimeout(_resetSequences, 10);\n      } // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n\n\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n\n\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space\n\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info; // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n\n        return;\n      }\n\n      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time\n      // a callback is added for this key\n\n      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one\n\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level); // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n\n\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n\n\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    }; // start!\n\n\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n\n    self._bindMultiple.call(self, keys, callback, action);\n\n    return self;\n  };\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n\n    return self;\n  };\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this; // if the element has the class \"mousetrap\" then no need to stop\n\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    if (_belongsTo(element, self.target)) {\n      return false;\n    } // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n    // not the initial event target in the shadow tree. Note that not all events cross the\n    // shadow boundary.\n    // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n    // the eventâs composed path. For shadow trees with `mode: 'closed'`, the initial event\n    // target cannot be obtained.\n\n\n    if ('composedPath' in e && typeof e.composedPath === 'function') {\n      // For open shadow trees, update `element` so that the following check works.\n      var initialEventTarget = e.composedPath()[0];\n\n      if (initialEventTarget !== e.target) {\n        element = initialEventTarget;\n      }\n    } // stop for input, select, and textarea\n\n\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n\n\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n  /**\n   * allow custom key mappings\n   */\n\n\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n\n    _REVERSE_MAP = null;\n  };\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n\n\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n\n  Mousetrap.init(); // expose mousetrap to the global object\n\n  window.Mousetrap = Mousetrap; // expose as a common js module\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Mousetrap;\n  } // expose mousetrap as an AMD module\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Mousetrap;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);\n\n//# sourceURL=webpack:///./node_modules/mousetrap/mousetrap.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./node_modules/wolfy87-eventemitter/EventEmitter.js":
/*!***********************************************************!*\
  !*** ./node_modules/wolfy87-eventemitter/EventEmitter.js ***!
  \***********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * EventEmitter v5.2.6 - git.io/ee\n * Unlicense - http://unlicense.org/\n * Oliver Caldwell - https://oli.me.uk/\n * @preserve\n */\n;\n\n(function (exports) {\n  'use strict';\n  /**\n   * Class for managing events.\n   * Can be extended to provide event functionality in other classes.\n   *\n   * @class EventEmitter Manages event registering and emitting.\n   */\n\n  function EventEmitter() {} // Shortcuts to improve speed and size\n\n\n  var proto = EventEmitter.prototype;\n  var originalGlobalValue = exports.EventEmitter;\n  /**\n   * Finds the index of the listener for the event in its storage array.\n   *\n   * @param {Function[]} listeners Array of listeners to search through.\n   * @param {Function} listener Method to look for.\n   * @return {Number} Index of the specified listener, -1 if not found\n   * @api private\n   */\n\n  function indexOfListener(listeners, listener) {\n    var i = listeners.length;\n\n    while (i--) {\n      if (listeners[i].listener === listener) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Alias a method while keeping the context correct, to allow for overwriting of target method.\n   *\n   * @param {String} name The name of the target method.\n   * @return {Function} The aliased method\n   * @api private\n   */\n\n\n  function alias(name) {\n    return function aliasClosure() {\n      return this[name].apply(this, arguments);\n    };\n  }\n  /**\n   * Returns the listener array for the specified event.\n   * Will initialise the event object and listener arrays if required.\n   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n   * Each property in the object response is an array of listener functions.\n   *\n   * @param {String|RegExp} evt Name of the event to return the listeners from.\n   * @return {Function[]|Object} All listener functions for the event.\n   */\n\n\n  proto.getListeners = function getListeners(evt) {\n    var events = this._getEvents();\n\n    var response;\n    var key; // Return a concatenated array of all matching events if\n    // the selector is a regular expression.\n\n    if (evt instanceof RegExp) {\n      response = {};\n\n      for (key in events) {\n        if (events.hasOwnProperty(key) && evt.test(key)) {\n          response[key] = events[key];\n        }\n      }\n    } else {\n      response = events[evt] || (events[evt] = []);\n    }\n\n    return response;\n  };\n  /**\n   * Takes a list of listener objects and flattens it into a list of listener functions.\n   *\n   * @param {Object[]} listeners Raw listener objects.\n   * @return {Function[]} Just the listener functions.\n   */\n\n\n  proto.flattenListeners = function flattenListeners(listeners) {\n    var flatListeners = [];\n    var i;\n\n    for (i = 0; i < listeners.length; i += 1) {\n      flatListeners.push(listeners[i].listener);\n    }\n\n    return flatListeners;\n  };\n  /**\n   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n   *\n   * @param {String|RegExp} evt Name of the event to return the listeners from.\n   * @return {Object} All listener functions for an event in an object.\n   */\n\n\n  proto.getListenersAsObject = function getListenersAsObject(evt) {\n    var listeners = this.getListeners(evt);\n    var response;\n\n    if (listeners instanceof Array) {\n      response = {};\n      response[evt] = listeners;\n    }\n\n    return response || listeners;\n  };\n\n  function isValidListener(listener) {\n    if (typeof listener === 'function' || listener instanceof RegExp) {\n      return true;\n    } else if (listener && _typeof(listener) === 'object') {\n      return isValidListener(listener.listener);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Adds a listener function to the specified event.\n   * The listener will not be added if it is a duplicate.\n   * If the listener returns true then it will be removed after it is called.\n   * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to attach the listener to.\n   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.addListener = function addListener(evt, listener) {\n    if (!isValidListener(listener)) {\n      throw new TypeError('listener must be a function');\n    }\n\n    var listeners = this.getListenersAsObject(evt);\n    var listenerIsWrapped = _typeof(listener) === 'object';\n    var key;\n\n    for (key in listeners) {\n      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n        listeners[key].push(listenerIsWrapped ? listener : {\n          listener: listener,\n          once: false\n        });\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of addListener\n   */\n\n\n  proto.on = alias('addListener');\n  /**\n   * Semi-alias of addListener. It will add a listener that will be\n   * automatically removed after its first execution.\n   *\n   * @param {String|RegExp} evt Name of the event to attach the listener to.\n   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.addOnceListener = function addOnceListener(evt, listener) {\n    return this.addListener(evt, {\n      listener: listener,\n      once: true\n    });\n  };\n  /**\n   * Alias of addOnceListener.\n   */\n\n\n  proto.once = alias('addOnceListener');\n  /**\n   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n   * You need to tell it what event names should be matched by a regex.\n   *\n   * @param {String} evt Name of the event to create.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.defineEvent = function defineEvent(evt) {\n    this.getListeners(evt);\n    return this;\n  };\n  /**\n   * Uses defineEvent to define multiple events.\n   *\n   * @param {String[]} evts An array of event names to define.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.defineEvents = function defineEvents(evts) {\n    for (var i = 0; i < evts.length; i += 1) {\n      this.defineEvent(evts[i]);\n    }\n\n    return this;\n  };\n  /**\n   * Removes a listener function from the specified event.\n   * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to remove the listener from.\n   * @param {Function} listener Method to remove from the event.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeListener = function removeListener(evt, listener) {\n    var listeners = this.getListenersAsObject(evt);\n    var index;\n    var key;\n\n    for (key in listeners) {\n      if (listeners.hasOwnProperty(key)) {\n        index = indexOfListener(listeners[key], listener);\n\n        if (index !== -1) {\n          listeners[key].splice(index, 1);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of removeListener\n   */\n\n\n  proto.off = alias('removeListener');\n  /**\n   * Adds listeners in bulk using the manipulateListeners method.\n   * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n   * You can also pass it a regular expression to add the array of listeners to all events that match it.\n   * Yeah, this function does quite a bit. That's probably a bad thing.\n   *\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to add.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.addListeners = function addListeners(evt, listeners) {\n    // Pass through to manipulateListeners\n    return this.manipulateListeners(false, evt, listeners);\n  };\n  /**\n   * Removes listeners in bulk using the manipulateListeners method.\n   * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n   * You can also pass it an event name and an array of listeners to be removed.\n   * You can also pass it a regular expression to remove the listeners from all events that match it.\n   *\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to remove.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeListeners = function removeListeners(evt, listeners) {\n    // Pass through to manipulateListeners\n    return this.manipulateListeners(true, evt, listeners);\n  };\n  /**\n   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n   * The first argument will determine if the listeners are removed (true) or added (false).\n   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n   * You can also pass it an event name and an array of listeners to be added/removed.\n   * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n   *\n   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n    var i;\n    var value;\n    var single = remove ? this.removeListener : this.addListener;\n    var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method\n\n    if (_typeof(evt) === 'object' && !(evt instanceof RegExp)) {\n      for (i in evt) {\n        if (evt.hasOwnProperty(i) && (value = evt[i])) {\n          // Pass the single listener straight through to the singular method\n          if (typeof value === 'function') {\n            single.call(this, i, value);\n          } else {\n            // Otherwise pass back to the multiple function\n            multiple.call(this, i, value);\n          }\n        }\n      }\n    } else {\n      // So evt must be a string\n      // And listeners must be an array of listeners\n      // Loop over it and pass each one to the multiple method\n      i = listeners.length;\n\n      while (i--) {\n        single.call(this, evt, listeners[i]);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes all listeners from a specified event.\n   * If you do not specify an event then all listeners will be removed.\n   * That means every event will be emptied.\n   * You can also pass a regex to remove all events that match it.\n   *\n   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeEvent = function removeEvent(evt) {\n    var type = _typeof(evt);\n\n    var events = this._getEvents();\n\n    var key; // Remove different things depending on the state of evt\n\n    if (type === 'string') {\n      // Remove all listeners for the specified event\n      delete events[evt];\n    } else if (evt instanceof RegExp) {\n      // Remove all events matching the regex.\n      for (key in events) {\n        if (events.hasOwnProperty(key) && evt.test(key)) {\n          delete events[key];\n        }\n      }\n    } else {\n      // Remove all listeners in all events\n      delete this._events;\n    }\n\n    return this;\n  };\n  /**\n   * Alias of removeEvent.\n   *\n   * Added to mirror the node API.\n   */\n\n\n  proto.removeAllListeners = alias('removeEvent');\n  /**\n   * Emits an event of your choice.\n   * When emitted, every listener attached to that event will be executed.\n   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n   * So they will not arrive within the array on the other side, they will be separate.\n   * You can also pass a regular expression to emit to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n   * @param {Array} [args] Optional array of arguments to be passed to each listener.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.emitEvent = function emitEvent(evt, args) {\n    var listenersMap = this.getListenersAsObject(evt);\n    var listeners;\n    var listener;\n    var i;\n    var key;\n    var response;\n\n    for (key in listenersMap) {\n      if (listenersMap.hasOwnProperty(key)) {\n        listeners = listenersMap[key].slice(0);\n\n        for (i = 0; i < listeners.length; i++) {\n          // If the listener returns true then it shall be removed from the event\n          // The function is executed either with a basic call or an apply if there is an args array\n          listener = listeners[i];\n\n          if (listener.once === true) {\n            this.removeListener(evt, listener.listener);\n          }\n\n          response = listener.listener.apply(this, args || []);\n\n          if (response === this._getOnceReturnValue()) {\n            this.removeListener(evt, listener.listener);\n          }\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of emitEvent\n   */\n\n\n  proto.trigger = alias('emitEvent');\n  /**\n   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n   * @param {...*} Optional additional arguments to be passed to each listener.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.emit = function emit(evt) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return this.emitEvent(evt, args);\n  };\n  /**\n   * Sets the current value to check against when executing listeners. If a\n   * listeners return value matches the one set here then it will be removed\n   * after execution. This value defaults to true.\n   *\n   * @param {*} value The new value to check for when executing listeners.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.setOnceReturnValue = function setOnceReturnValue(value) {\n    this._onceReturnValue = value;\n    return this;\n  };\n  /**\n   * Fetches the current value to check against when executing listeners. If\n   * the listeners return value matches this one then it should be removed\n   * automatically. It will return true by default.\n   *\n   * @return {*|Boolean} The current value to check for or the default, true.\n   * @api private\n   */\n\n\n  proto._getOnceReturnValue = function _getOnceReturnValue() {\n    if (this.hasOwnProperty('_onceReturnValue')) {\n      return this._onceReturnValue;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Fetches the events object and creates one if required.\n   *\n   * @return {Object} The events storage object.\n   * @api private\n   */\n\n\n  proto._getEvents = function _getEvents() {\n    return this._events || (this._events = {});\n  };\n  /**\n   * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n   *\n   * @return {Function} Non conflicting EventEmitter class.\n   */\n\n\n  EventEmitter.noConflict = function noConflict() {\n    exports.EventEmitter = originalGlobalValue;\n    return EventEmitter;\n  }; // Expose the class either via AMD, CommonJS or the global object\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return EventEmitter;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(typeof window !== 'undefined' ? window : this || {});\n\n//# sourceURL=webpack:///./node_modules/wolfy87-eventemitter/EventEmitter.js?");

/***/ }),

/***/ "./src/scripts/components/copy-to-clipboard.js":
/*!*****************************************************!*\
  !*** ./src/scripts/components/copy-to-clipboard.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clipboard */ \"./node_modules/clipboard/dist/clipboard.js\");\n/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Copy to clipboard functionality for code snippet examples\n */\n\nvar clipboard = new clipboard__WEBPACK_IMPORTED_MODULE_0___default.a('.pl-js-code-copy-btn');\nclipboard.on('success', function (e) {\n  var copyButton = document.querySelectorAll('.pl-js-code-copy-btn');\n\n  for (var i = 0; i < copyButton.length; i++) {\n    copyButton[i].innerText = 'Copy';\n  }\n\n  e.trigger.textContent = 'Copied';\n});\n\n//# sourceURL=webpack:///./src/scripts/components/copy-to-clipboard.js?");

/***/ }),

/***/ "./src/scripts/components/panels-util.js":
/*!***********************************************!*\
  !*** ./src/scripts/components/panels-util.js ***!
  \***********************************************/
/*! exports provided: panelsUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"panelsUtil\", function() { return panelsUtil; });\n/**\n * Panels Util - for both styleguide and viewer\n */\nvar panelsUtil = {\n  /**\n   * Add click events to the template that was rendered\n   * @param  {String}      the rendered template for the modal\n   * @param  {String}      the pattern partial for the modal\n   */\n  addClickEvents: function addClickEvents(templateRendered, patternPartial) {\n    var els = templateRendered.querySelectorAll('.pl-js-tab-link');\n\n    for (var i = 0; i < els.length; ++i) {\n      els[i].onclick = function (e) {\n        e.preventDefault();\n        var partial = this.getAttribute('data-patternpartial');\n        var panelID = this.getAttribute('data-panelid');\n        panelsUtil.show(partial, panelID);\n      };\n    }\n\n    return templateRendered;\n  },\n\n  /**\n   * Show a specific modal\n   * @param  {String}      the pattern partial for the modal\n   * @param  {String}      the ID of the panel to be shown\n   */\n  show: function show(patternPartial, panelID) {\n    var activeTabClass = 'pl-is-active-tab'; // turn off all of the active tabs\n\n    var allTabLinks = document.querySelectorAll(\".pl-js-tab-link\"); // hide all of the panels\n\n    var allTabPanels = document.querySelectorAll(\".pl-js-tab-panel\"); // tabLink about to become active\n\n    var activeTabLink = document.querySelector(\"#pl-\".concat(patternPartial, \"-\").concat(panelID, \"-tab\")); // tabPanelabout to become active\n\n    var activeTabPanel = document.querySelector(\"#pl-\".concat(patternPartial, \"-\").concat(panelID, \"-panel\"));\n\n    for (var i = 0; i < allTabLinks.length; ++i) {\n      allTabLinks[i].classList.remove(activeTabClass);\n    }\n\n    for (var _i = 0; _i < allTabPanels.length; ++_i) {\n      allTabPanels[_i].classList.remove(activeTabClass);\n    }\n\n    activeTabLink.classList.add(activeTabClass);\n    activeTabPanel.classList.add(activeTabClass);\n  }\n};\n\n//# sourceURL=webpack:///./src/scripts/components/panels-util.js?");

/***/ }),

/***/ "./src/scripts/patternlab-pattern.js":
/*!*******************************************************!*\
  !*** ./src/scripts/patternlab-pattern.js + 2 modules ***!
  \*******************************************************/
/*! no exports provided */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/mousetrap/mousetrap.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/scripts/components/copy-to-clipboard.js */
/*! ModuleConcatenation bailout: Cannot concat with ./src/scripts/components/panels-util.js */
/*! ModuleConcatenation bailout: Cannot concat with ./src/scripts/utils/index.js */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// EXTERNAL MODULE: ./src/scripts/utils/postmessage.js\nvar postmessage = __webpack_require__(\"./src/scripts/utils/postmessage.js\");\n\n// EXTERNAL MODULE: ./src/scripts/components/panels-util.js\nvar panels_util = __webpack_require__(\"./src/scripts/components/panels-util.js\");\n\n// EXTERNAL MODULE: ./src/scripts/components/copy-to-clipboard.js\nvar copy_to_clipboard = __webpack_require__(\"./src/scripts/components/copy-to-clipboard.js\");\n\n// CONCATENATED MODULE: ./src/scripts/components/modal-styleguide.js\n/**\n * \"Modal\" (aka Panel UI) for the Styleguide Layer - for both annotations and code/info\n */\n\n\nvar modalStyleguide = {\n  // set up some defaults\n  active: [],\n  targetOrigin: window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host,\n\n  /**\n   * initialize the modal window\n   */\n  onReady: function onReady() {\n    // go through the panel toggles and add click event to the pattern extra toggle button\n    var els = document.querySelectorAll('.pl-js-pattern-extra-toggle');\n\n    for (var i = 0; i < els.length; ++i) {\n      els[i].onclick = function (e) {\n        var patternPartial = this.getAttribute('data-patternpartial');\n        modalStyleguide.toggle(patternPartial);\n      };\n    }\n  },\n\n  /**\n   * toggle the modal window open and closed based on clicking the pip\n   * @param  {String}       the patternPartial that identifies what needs to be toggled\n   */\n  toggle: function toggle(patternPartial) {\n    if (modalStyleguide.active[patternPartial] === undefined || !modalStyleguide.active[patternPartial]) {\n      var el = document.getElementById('pl-pattern-data-' + patternPartial);\n      modalStyleguide.collectAndSend(el, true, false);\n    } else {\n      modalStyleguide.highlightsHide();\n      modalStyleguide.close(patternPartial);\n    }\n  },\n\n  /**\n   * open the modal window for a view-all entry\n   * @param  {String}       the patternPartial that identifies what needs to be opened\n   * @param  {String}       the content that should be inserted\n   */\n  open: function open(patternPartial, content) {\n    // make sure templateRendered is modified to be an HTML element\n    var div = document.createElement('div');\n    div.innerHTML = content;\n    content = document.createElement('div').appendChild(div).querySelector('div'); // add click events\n\n    content = panels_util[\"panelsUtil\"].addClickEvents(content, patternPartial); // make sure the modal viewer and other options are off just in case\n\n    modalStyleguide.close(patternPartial); // note it's turned on in the viewer\n\n    modalStyleguide.active[patternPartial] = true; // make sure there's no content\n\n    div = document.getElementById('pl-pattern-extra-' + patternPartial);\n\n    if (div.childNodes.length > 0) {\n      div.removeChild(div.childNodes[0]);\n    } // add the content\n\n\n    document.getElementById('pl-pattern-extra-' + patternPartial).appendChild(content); // show the modal\n\n    document.getElementById('pl-pattern-extra-toggle-' + patternPartial).classList.add('pl-is-active');\n    document.getElementById('pl-pattern-extra-' + patternPartial).classList.add('pl-is-active');\n  },\n\n  /**\n   * close the modal window for a view-all entry\n   * @param  {String}       the patternPartial that identifies what needs to be closed\n   */\n  close: function close(patternPartial) {\n    // note that the modal viewer is no longer active\n    modalStyleguide.active[patternPartial] = false; // hide the modal, look at info-panel.js\n\n    document.getElementById('pl-pattern-extra-toggle-' + patternPartial).classList.remove('pl-is-active');\n    document.getElementById('pl-pattern-extra-' + patternPartial).classList.remove('pl-is-active');\n  },\n\n  /**\n   * get the data that needs to be send to the viewer for rendering\n   * @param  {Element}      the identifier for the element that needs to be collected\n   * @param  {Boolean}      if the refresh is of a view-all view and the content should be sent back\n   * @param  {Boolean}      if the text in the dropdown should be switched\n   */\n  collectAndSend: function collectAndSend(el, iframePassback, switchText) {\n    /**\n     * Verify <script> tag has JSON data available (not just whitespace) - helps prevents JS errors from\n     * getting thrown when certain script tags aren't rendered with partial.patternData content.\n     */\n    if (/\\S/.test(el.innerHTML)) {\n      var patternData = JSON.parse(el.innerHTML);\n\n      if (patternData.patternName !== undefined) {\n        var patternMarkupEl = document.querySelector('#' + patternData.patternPartial + ' > .pl-js-pattern-example');\n        patternData.patternMarkup = patternMarkupEl !== null ? patternMarkupEl.innerHTML : document.querySelector('body').innerHTML;\n        modalStyleguide.patternQueryInfo(patternData, iframePassback, switchText);\n      }\n    } else {// @todo: how are we handling conditional logging for debugging based on the dev environment?\n      // console.log('This <script> tag\\'s JSON is empty for some reason...');\n    }\n  },\n\n  /**\n   * hide the annotation highlights\n   */\n  highlightsHide: function highlightsHide(patternPartial) {\n    var patternPartialSelector = patternPartial !== undefined ? '#' + patternPartial + ' > ' : '';\n    var elsToHide = document.querySelectorAll(patternPartialSelector + '.pl-has-annotation');\n\n    for (var i = 0; i < elsToHide.length; i++) {\n      elsToHide[i].classList.remove('pl-has-annotation');\n    }\n\n    elsToHide = document.querySelectorAll(patternPartialSelector + '.pl-c-annotation-tip');\n\n    for (var _i = 0; _i < elsToHide.length; _i++) {\n      elsToHide[_i].style.display = 'none';\n    }\n  },\n\n  /**\n   * return the pattern info to the top level\n   * @param  {Object}       the content that will be sent to the viewer for rendering\n   * @param  {Boolean}      if the refresh is of a view-all view and the content should be sent back\n   * @param  {Boolean}      if the text in the dropdown should be switched\n   */\n  patternQueryInfo: function patternQueryInfo(patternData, iframePassback, switchText) {\n    // send a message to the pattern\n    try {\n      var obj = JSON.stringify({\n        event: 'patternLab.patternQueryInfo',\n        patternData: patternData,\n        iframePassback: iframePassback,\n        switchText: switchText\n      });\n      window.parent.postMessage(obj, modalStyleguide.targetOrigin);\n    } catch (e) {// @todo: how do we want to handle exceptions here?\n    }\n  },\n\n  /**\n   * toggle the comment pop-up based on a user clicking on the pattern\n   * based on the great MDN docs at https://developer.mozilla.org/en-US/docs/Web/API/window.postMessage\n   * @param  {Object}      event info\n   */\n  receiveIframeMessage: function receiveIframeMessage(event) {\n    // does the origin sending the message match the current host? if not dev/null the request\n    if (window.location.protocol !== 'file:' && event.origin !== window.location.protocol + '//' + window.location.host) {\n      return;\n    }\n\n    var data = {};\n\n    try {\n      data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n    } catch (e) {} // @todo: how do we want to handle exceptions here?\n    // see if it got a path to replace\n\n\n    if (data.event !== undefined && data.event === 'patternLab.patternQuery') {\n      // find all elements related to pattern info\n      var els = document.querySelectorAll('.pl-js-pattern-data');\n      var iframePassback = els.length > 1; // send each up to the parent to be read and compiled into panels\n\n      for (var i = 0; i < els.length; i++) {\n        modalStyleguide.collectAndSend(els[i], iframePassback, data.switchText);\n      }\n    } else if (data.event !== undefined && data.event === 'patternLab.patternModalInsert') {\n      // insert the previously rendered content being passed from the iframe\n      modalStyleguide.open(data.patternPartial, data.modalContent);\n    } else if (data.event !== undefined && data.event === 'patternLab.annotationsHighlightShow') {\n      var elsToHighlight, item, span; // go over the supplied annotations\n\n      for (var _i2 = 0; _i2 < data.annotations.length; _i2++) {\n        item = data.annotations[_i2];\n        elsToHighlight = document.querySelectorAll(item.el);\n\n        if (elsToHighlight.length > 0) {\n          for (var j = 0; j < elsToHighlight.length; j++) {\n            elsToHighlight[j].classList.add('pl-has-annotation');\n            span = document.createElement('span');\n            span.innerHTML = item.displayNumber;\n            span.classList.add('pl-c-annotation-tip');\n\n            if (window.getComputedStyle(elsToHighlight[j], null).getPropertyValue('max-height') === '0px') {\n              span.style.display = 'none';\n            }\n\n            var annotationTip = document.querySelector(item.el + ' > span.pl-c-annotation-tip');\n\n            if (annotationTip === null) {\n              elsToHighlight[j].insertBefore(span, elsToHighlight[j].firstChild);\n            } else {\n              annotationTip.style.display = 'inline-flex';\n            }\n\n            elsToHighlight[j].onclick = function (el) {\n              return function (e) {\n                e.preventDefault();\n                e.stopPropagation();\n                var obj = JSON.stringify({\n                  event: 'patternLab.annotationNumberClicked',\n                  displayNumber: el.displayNumber\n                });\n                window.parent.postMessage(obj, modalStyleguide.targetOrigin);\n              };\n            }(item);\n          }\n        }\n      }\n    } else if (data.event !== undefined && data.event === 'patternLab.annotationsHighlightHide') {\n      modalStyleguide.highlightsHide();\n    } else if (data.event !== undefined && data.event === 'patternLab.patternModalClose') {\n      var keys = [];\n\n      for (var k in modalStyleguide.active) {\n        if (k) {\n          keys.push(k);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < keys.length; _i3++) {\n        var patternPartial = keys[_i3];\n\n        if (modalStyleguide.active[patternPartial]) {\n          modalStyleguide.close(patternPartial);\n        }\n      }\n    }\n  }\n}; // when the document is ready make sure the modal is ready\n\nmodalStyleguide.onReady();\nwindow.addEventListener('message', modalStyleguide.receiveIframeMessage, false);\n// EXTERNAL MODULE: ./node_modules/mousetrap/mousetrap.js\nvar mousetrap = __webpack_require__(\"./node_modules/mousetrap/mousetrap.js\");\nvar mousetrap_default = /*#__PURE__*/__webpack_require__.n(mousetrap);\n\n// EXTERNAL MODULE: ./src/scripts/utils/index.js + 8 modules\nvar utils = __webpack_require__(\"./src/scripts/utils/index.js\");\n\n// CONCATENATED MODULE: ./src/scripts/components/pl-search/pl-search.iframe-helper.js\n// Tiny helper script to listen for keyboard combos and to communicate back to the main Search component (via the Pattern Lab iframe)\n\n\nmousetrap_default.a.bind('command+shift+f', function (e) {\n  e.preventDefault();\n\n  try {\n    var obj = JSON.stringify({\n      event: 'patternLab.keyPress',\n      key: e.key,\n      altKey: e.altKey,\n      ctrlKey: e.ctrlKey,\n      metaKey: e.metaKey,\n      shiftKey: e.shiftKey\n    });\n    window.parent.postMessage(obj, utils[\"targetOrigin\"]);\n  } catch (error) {// @todo: how do we want to handle exceptions here?\n  }\n\n  return false;\n});\n// EXTERNAL MODULE: ./node_modules/iframe-resizer/js/iframeResizer.contentWindow.min.js\nvar iframeResizer_contentWindow_min = __webpack_require__(\"./node_modules/iframe-resizer/js/iframeResizer.contentWindow.min.js\");\n\n// CONCATENATED MODULE: ./src/scripts/patternlab-pattern.js\n\n\n // communicates with the main <pl-search> component via the PL iframe\n\n // automatically syncs inner iFrame height with main Pattern Lab page\n\n//# sourceURL=webpack:///./src/scripts/patternlab-pattern.js_+_2_modules?");

/***/ }),

/***/ "./src/scripts/utils/index.js":
/*!************************************************!*\
  !*** ./src/scripts/utils/index.js + 8 modules ***!
  \************************************************/
/*! exports provided: DataSaver, postmessage, urlHandler, Dispatcher, css, extend, supportsShadowDom, targetOrigin */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/js-cookie/src/js.cookie.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/wolfy87-eventemitter/EventEmitter.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/scripts/utils/postmessage.js (<- Module is not an ECMAScript module) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// EXTERNAL MODULE: ./node_modules/js-cookie/src/js.cookie.js\nvar js_cookie = __webpack_require__(\"./node_modules/js-cookie/src/js.cookie.js\");\nvar js_cookie_default = /*#__PURE__*/__webpack_require__.n(js_cookie);\n\n// CONCATENATED MODULE: ./node_modules/deepmerge/dist/es.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar isMergeableObject = function isMergeableObject(value) {\n  return isNonNullObject(value) && !isSpecial(value);\n};\n\nfunction isNonNullObject(value) {\n  return !!value && _typeof(value) === 'object';\n}\n\nfunction isSpecial(value) {\n  var stringValue = Object.prototype.toString.call(value);\n  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n} // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n  return value.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nfunction emptyTarget(val) {\n  return Array.isArray(val) ? [] : {};\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n}\n\nfunction defaultArrayMerge(target, source, options) {\n  return target.concat(source).map(function (element) {\n    return cloneUnlessOtherwiseSpecified(element, options);\n  });\n}\n\nfunction mergeObject(target, source, options) {\n  var destination = {};\n\n  if (options.isMergeableObject(target)) {\n    Object.keys(target).forEach(function (key) {\n      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n    });\n  }\n\n  Object.keys(source).forEach(function (key) {\n    if (!options.isMergeableObject(source[key]) || !target[key]) {\n      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n    } else {\n      destination[key] = deepmerge(target[key], source[key], options);\n    }\n  });\n  return destination;\n}\n\nfunction deepmerge(target, source, options) {\n  options = options || {};\n  options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n  options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n  var sourceIsArray = Array.isArray(source);\n  var targetIsArray = Array.isArray(target);\n  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n  if (!sourceAndTargetTypesMatch) {\n    return cloneUnlessOtherwiseSpecified(source, options);\n  } else if (sourceIsArray) {\n    return options.arrayMerge(target, source, options);\n  } else {\n    return mergeObject(target, source, options);\n  }\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n  if (!Array.isArray(array)) {\n    throw new Error('first argument should be an array');\n  }\n\n  return array.reduce(function (prev, next) {\n    return deepmerge(prev, next, options);\n  }, {});\n};\n\nvar deepmerge_1 = deepmerge;\n/* harmony default export */ var es = (deepmerge_1);\n// CONCATENATED MODULE: ./src/scripts/utils/data-saver.js\n/*!\n * Data Saver\n */\n\n\nvar DataSaver = {\n  // namespace all cookie names are prefixed with\n  namespace: 'patternlab',\n\n  /**\n   * Add a given value to the cookie\n   * @param  {String}       the name of the key\n   * @param  {String}       the value\n   */\n  addValue: function addValue(name, val) {\n    var newData = {};\n    newData[name] = val;\n    var existingData = {};\n\n    if (js_cookie_default.a.getJSON(DataSaver.namespace)) {\n      existingData = js_cookie_default.a.getJSON(DataSaver.namespace);\n    }\n\n    var mergedData = es(existingData, newData);\n    js_cookie_default.a.set(DataSaver.namespace, mergedData, {\n      expires: 7\n    });\n  },\n\n  /**\n   * Update a value found in the cookie. If the key doesn't exist add the value\n   * @param  {String}       the name of the key\n   * @param  {String}       the value\n   */\n  updateValue: function updateValue(name, val) {\n    DataSaver.addValue(name, val);\n  },\n\n  /**\n   * Remove the given key\n   * @param  {String}       the name of the key\n   */\n  removeValue: function removeValue(name) {\n    var currentData = js_cookie_default.a.getJSON(DataSaver.namespace);\n    var updatedData = delete currentData[name];\n\n    if (updatedData.keys()) {\n      js_cookie_default.a.set(DataSaver.namespace, updatedData, {\n        expires: 7\n      });\n    } else {\n      js_cookie_default.a.remove(DataSaver.namespace);\n    }\n  },\n\n  /**\n   * Find the value using the given key\n   * @param  {String}       the name of the key\n   * @return {String}       the value of the key or false if the value isn't found\n   */\n  findValue: function findValue(name) {\n    var existingData = js_cookie_default.a.getJSON(DataSaver.namespace);\n\n    if (existingData !== undefined) {\n      if (existingData[name] !== undefined) {\n        return existingData[name];\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n};\n// EXTERNAL MODULE: ./src/scripts/utils/postmessage.js\nvar postmessage = __webpack_require__(\"./src/scripts/utils/postmessage.js\");\n\n// CONCATENATED MODULE: ./src/scripts/utils/url-handler.js\n/*!\n * URL Handler\n *\n * Copyright (c) 2013-2014 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Helps handle the initial iFrame source. Parses a string to see if it matches\n * an expected pattern in Pattern Lab. Supports Pattern Lab's fuzzy pattern partial\n * matching style.\n *\n */\nvar urlHandler = {\n  // set-up some default vars\n  skipBack: false,\n  targetOrigin: window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host,\n\n  /**\n   * get the real file name for a given pattern name\n   * @param  {String}       the shorthand partials syntax for a given pattern\n   * @param  {Boolean}      with the file name should be returned with the full rendered suffix or not\n   *\n   * @return {String}       the real file path\n   */\n  getFileName: function getFileName(name, withRenderedSuffix) {\n    var baseDir = 'patterns';\n    var fileName = '';\n\n    if (name === undefined) {\n      return fileName;\n    }\n\n    if (withRenderedSuffix === undefined) {\n      withRenderedSuffix = true;\n    }\n\n    if (name === 'all') {\n      return 'styleguide/html/styleguide.html';\n    } else if (name === 'snapshots') {\n      return 'snapshots/index.html';\n    }\n\n    var paths = name.indexOf('viewall-') !== -1 ? window.viewAllPaths : window.patternPaths;\n    var nameClean = name.replace('viewall-', ''); // look at this as a regular pattern\n\n    var bits = this.getPatternInfo(nameClean, paths);\n    var patternType = bits[0];\n    var pattern = bits[1];\n\n    if (paths[patternType] !== undefined && paths[patternType][pattern] !== undefined) {\n      fileName = paths[patternType][pattern];\n    } else if (paths[patternType] !== undefined) {\n      for (var patternMatchKey in paths[patternType]) {\n        if (patternMatchKey.indexOf(pattern) !== -1) {\n          fileName = paths[patternType][patternMatchKey];\n          break;\n        }\n      }\n    }\n\n    if (fileName === '') {\n      return fileName;\n    }\n\n    var regex = /\\//g;\n\n    if (name.indexOf('viewall-') !== -1 && name.indexOf('viewall-') === 0 && fileName !== '') {\n      fileName = baseDir + '/' + fileName.replace(regex, '-') + '/index.html';\n    } else if (fileName !== '') {\n      fileName = baseDir + '/' + fileName.replace(regex, '-') + '/' + fileName.replace(regex, '-');\n\n      if (withRenderedSuffix) {\n        var fileSuffixRendered = window.config.outputFileSuffixes !== undefined && window.config.outputFileSuffixes.rendered !== undefined ? window.config.outputFileSuffixes.rendered : '';\n        fileName = fileName + fileSuffixRendered + '.html';\n      }\n    }\n\n    return fileName;\n  },\n\n  /**\n   * break up a pattern into its parts, pattern type and pattern name\n   * @param  {String}       the shorthand partials syntax for a given pattern\n   * @param  {Object}       the paths to be compared\n   *\n   * @return {Array}        the pattern type and pattern name\n   */\n  getPatternInfo: function getPatternInfo(name, paths) {\n    var patternBits = name.split('-');\n    var i = 1;\n    var c = patternBits.length;\n    var patternType = patternBits[0];\n\n    while (paths[patternType] === undefined && i < c) {\n      patternType += '-' + patternBits[i];\n      i++;\n    }\n\n    var pattern = name.slice(patternType.length + 1, name.length);\n    return [patternType, pattern];\n  },\n\n  /**\n   * search the request vars for a particular item\n   *\n   * @return {Object}       a search of the window.location.search vars\n   */\n  getRequestVars: function getRequestVars() {\n    // the following is taken from https://developer.mozilla.org/en-US/docs/Web/API/window.location\n    var oGetVars = new function (sSearch) {\n      if (sSearch.length > 1) {\n        for (var aItKey, nKeyId = 0, aCouples = sSearch.substr(1).split('&'); nKeyId < aCouples.length; nKeyId++) {\n          aItKey = aCouples[nKeyId].split('=');\n          this[unescape(aItKey[0])] = aItKey.length > 1 ? unescape(aItKey[1]) : '';\n        }\n      }\n    }(window.location.search);\n    return oGetVars;\n  },\n\n  /**\n   * push a pattern onto the current history based on a click\n   * @param  {String}       the shorthand partials syntax for a given pattern\n   * @param  {String}       the path given by the loaded iframe\n   */\n  pushPattern: function pushPattern(pattern, givenPath) {\n    var data = {\n      pattern: pattern\n    };\n    var fileName = urlHandler.getFileName(pattern);\n    var path = window.location.pathname;\n    path = window.location.protocol === 'file' ? path.replace('/public/index.html', 'public/') : path.replace(/\\/index\\.html/, '/');\n    var expectedPath = window.location.protocol + '//' + window.location.host + path + fileName;\n\n    if (givenPath !== expectedPath) {\n      // make sure to update the iframe because there was a click\n      var obj = JSON.stringify({\n        event: 'patternLab.updatePath',\n        path: fileName\n      });\n      document.querySelector('.pl-js-iframe').contentWindow.postMessage(obj, urlHandler.targetOrigin);\n    } else {\n      // add to the history\n      var addressReplacement = window.location.protocol === 'file:' ? null : window.location.protocol + '//' + window.location.host + window.location.pathname.replace('index.html', '') + '?p=' + pattern;\n\n      if (window.history.pushState !== undefined) {\n        window.history.pushState(data, null, addressReplacement);\n      }\n\n      document.getElementById('title').innerHTML = 'Pattern Lab - ' + pattern; // Open in new window link\n\n      if (document.querySelector('.pl-js-open-new-window') !== undefined) {\n        // Set value of href to the path to the pattern\n        document.querySelector('.pl-js-open-new-window').setAttribute('href', urlHandler.getFileName(pattern));\n      }\n    }\n  },\n\n  /**\n   * based on a click forward or backward modify the url and iframe source\n   * @param  {Object}      event info like state and properties set in pushState()\n   */\n  popPattern: function popPattern(e) {\n    var patternName;\n    var state = e.state;\n\n    if (state === null) {\n      this.skipBack = false;\n      return;\n    } else if (state !== null) {\n      patternName = state.pattern;\n    }\n\n    var iFramePath = '';\n    iFramePath = this.getFileName(patternName);\n\n    if (iFramePath === '') {\n      iFramePath = 'styleguide/html/styleguide.html';\n    }\n\n    var obj = JSON.stringify({\n      event: 'patternLab.updatePath',\n      path: iFramePath\n    });\n    document.querySelector('.pl-js-iframe').contentWindow.postMessage(obj, urlHandler.targetOrigin);\n    document.getElementById('title').innerHTML = 'Pattern Lab - ' + patternName;\n    document.querySelector('.pl-js-open-new-window').setAttribute('href', urlHandler.getFileName(patternName));\n  }\n};\n/**\n * handle the onpopstate event\n */\n\nwindow.onpopstate = function (event) {\n  urlHandler.skipBack = true;\n  urlHandler.popPattern(event);\n};\n// EXTERNAL MODULE: ./node_modules/wolfy87-eventemitter/EventEmitter.js\nvar EventEmitter = __webpack_require__(\"./node_modules/wolfy87-eventemitter/EventEmitter.js\");\nvar EventEmitter_default = /*#__PURE__*/__webpack_require__.n(EventEmitter);\n\n// CONCATENATED MODULE: ./src/scripts/utils/eventemitter.js\n\nvar Dispatcher = new EventEmitter_default.a();\n// CONCATENATED MODULE: ./src/scripts/utils/css.js\n// Utility function used for outputting correctly formatted CSS classes in JSX.\n// Ported over from https://github.com/wc-catalogue/blaze-elements/blob/master/packages/common/css.ts\nfunction css() {\n  var classes = [];\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  for (var _i = 0; _i < args.length; _i++) {\n    var arg = args[_i];\n\n    if (arg) {\n      if (typeof arg === 'string') {\n        classes.push(arg);\n      } else {\n        for (var key in arg) {\n          if (arg[key]) {\n            classes.push(key);\n          }\n        }\n      }\n    }\n  }\n\n  return classes.join(' ');\n}\n// CONCATENATED MODULE: ./src/scripts/utils/extend.js\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./src/scripts/utils/supports-shadow-dom.js\nfunction hasShadowDomSupport() {\n  if ('attachShadow' in Element.prototype && 'getRootNode' in Element.prototype || window.ShadyDOM) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar supportsShadowDom = hasShadowDomSupport();\n// CONCATENATED MODULE: ./src/scripts/utils/get-target-origin.js\nvar targetOrigin = window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host;\n// CONCATENATED MODULE: ./src/scripts/utils/index.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"DataSaver\", function() { return DataSaver; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"postmessage\", function() { return postmessage[\"postmessage\"]; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"urlHandler\", function() { return urlHandler; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Dispatcher\", function() { return Dispatcher; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"css\", function() { return css; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"supportsShadowDom\", function() { return supportsShadowDom; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"targetOrigin\", function() { return targetOrigin; });\n// Export Utilties + Helpers\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/scripts/utils/index.js_+_8_modules?");

/***/ }),

/***/ "./src/scripts/utils/postmessage.js":
/*!******************************************!*\
  !*** ./src/scripts/utils/postmessage.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("/*!\n * Basic postMessage Support\n *\n * Copyright (c) 2013-2016 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Handles the postMessage stuff in the pattern, view-all, and style guide templates.\n *\n */\n// alert the iframe parent that the pattern has loaded assuming this view was loaded in an iframe\nif (window.self !== window.top) {\n  // handle the options that could be sent to the parent window\n  //   - all get path\n  //   - pattern & view all get a pattern partial, styleguide gets all\n  //   - pattern shares lineage\n  var path = window.location.toString();\n  var parts = path.split('?');\n  var options = {\n    event: 'patternLab.pageLoad',\n    path: parts[0]\n  };\n  window.patternData = document.getElementById('pl-pattern-data-footer').innerHTML;\n  window.patternData = JSON.parse(window.patternData);\n  options.patternpartial = window.patternData.patternPartial !== undefined ? window.patternData.patternPartial : 'all';\n\n  if (window.patternData.lineage !== '') {\n    options.lineage = window.patternData.lineage;\n  }\n\n  var targetOrigin = window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host;\n  window.parent.postMessage(options, targetOrigin); // find all links and add an onclick handler for replacing the iframe address so the history works\n\n  var aTags = document.getElementsByTagName('a');\n\n  for (var i = 0; i < aTags.length; i++) {\n    aTags[i].onclick = function (e) {\n      var href = this.getAttribute('href');\n      var target = this.getAttribute('target');\n\n      if (target !== undefined && (target === '_parent' || target === '_blank')) {// just do normal stuff\n      } else if (href && href !== '#') {\n        e.preventDefault();\n        window.location.replace(href);\n      } else {\n        e.preventDefault();\n        return false;\n      }\n\n      return true;\n    };\n  }\n} // watch the iframe source so that it can be sent back to everyone else.\n\n\nfunction receiveIframeMessage(event) {\n  // does the origin sending the message match the current host? if not dev/null the request\n  if (window.location.protocol !== 'file:' && event.origin !== window.location.protocol + '//' + window.location.host) {\n    return;\n  }\n\n  var path;\n  var data = {};\n\n  try {\n    data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n  } catch (e) {// @todo: how do we want to handle exceptions like these?\n  }\n\n  if (data.event !== undefined && data.event === 'patternLab.updatePath') {\n    if (window.patternData.patternPartial !== undefined) {\n      // handle patterns and the view all page\n      var re = /(patterns|snapshots)\\/(.*)$/;\n      path = window.location.protocol + '//' + window.location.host + window.location.pathname.replace(re, '') + data.path + '?' + Date.now();\n      window.location.replace(path);\n    } else {\n      // handle the style guide\n      path = window.location.protocol + '//' + window.location.host + window.location.pathname.replace('styleguide/html/styleguide.html', '') + data.path + '?' + Date.now();\n      window.location.replace(path);\n    }\n  } else if (data.event !== undefined && data.event === 'patternLab.reload') {\n    // reload the location if there was a message to do so\n    window.location.reload();\n  }\n}\n\nwindow.addEventListener('message', receiveIframeMessage, false);\n\n//# sourceURL=webpack:///./src/scripts/utils/postmessage.js?");

/***/ })

/******/ });