!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="./styleguide/",t(t.s="./src/scripts/patternlab-pattern.js")}({"./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: "normal",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: "throw",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = "GeneratorFunction";\n      }\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {\n          return Promise.resolve(value.__await).then(function (value) {\n            invoke("next", value, resolve, reject);\n          }, function (err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === "throw") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        // Note: ["return"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator["return"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError("The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: "root"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = "next";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" || record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    "catch": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error("illegal catch attempt");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n( false ? undefined : _typeof(module)) === "object" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you\'ve misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you\'re not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function("r", "regeneratorRuntime = r")(runtime);\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js?')},"./node_modules/@babel/runtime/regenerator/index.js":function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js");\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/regenerator/index.js?')},"./node_modules/clipboard/dist/clipboard.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*!\n * clipboard.js v2.0.4\n * https://zenorocha.github.io/clipboard.js\n * \n * Licensed MIT Â© Zeno Rocha\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _clipboardAction = __webpack_require__(1);\n\n      var _clipboardAction2 = _interopRequireDefault(_clipboardAction);\n\n      var _tinyEmitter = __webpack_require__(3);\n\n      var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);\n\n      var _goodListener = __webpack_require__(4);\n\n      var _goodListener2 = _interopRequireDefault(_goodListener);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof2(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof2(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Base class which takes one or more elements, adds event listeners to them,\n       * and instantiates a new `ClipboardAction` on each click.\n       */\n\n\n      var Clipboard = function (_Emitter) {\n        _inherits(Clipboard, _Emitter);\n        /**\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         * @param {Object} options\n         */\n\n\n        function Clipboard(trigger, options) {\n          _classCallCheck(this, Clipboard);\n\n          var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));\n\n          _this.resolveOptions(options);\n\n          _this.listenClick(trigger);\n\n          return _this;\n        }\n        /**\n         * Defines if attributes would be resolved using internal setter functions\n         * or custom functions that were passed in the constructor.\n         * @param {Object} options\n         */\n\n\n        _createClass(Clipboard, [{\n          key: 'resolveOptions',\n          value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;\n            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;\n            this.text = typeof options.text === 'function' ? options.text : this.defaultText;\n            this.container = _typeof(options.container) === 'object' ? options.container : document.body;\n          }\n          /**\n           * Adds a click event listener to the passed trigger.\n           * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n           */\n\n        }, {\n          key: 'listenClick',\n          value: function listenClick(trigger) {\n            var _this2 = this;\n\n            this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {\n              return _this2.onClick(e);\n            });\n          }\n          /**\n           * Defines a new `ClipboardAction` on each click event.\n           * @param {Event} e\n           */\n\n        }, {\n          key: 'onClick',\n          value: function onClick(e) {\n            var trigger = e.delegateTarget || e.currentTarget;\n\n            if (this.clipboardAction) {\n              this.clipboardAction = null;\n            }\n\n            this.clipboardAction = new _clipboardAction2.default({\n              action: this.action(trigger),\n              target: this.target(trigger),\n              text: this.text(trigger),\n              container: this.container,\n              trigger: trigger,\n              emitter: this\n            });\n          }\n          /**\n           * Default `action` lookup function.\n           * @param {Element} trigger\n           */\n\n        }, {\n          key: 'defaultAction',\n          value: function defaultAction(trigger) {\n            return getAttributeValue('action', trigger);\n          }\n          /**\n           * Default `target` lookup function.\n           * @param {Element} trigger\n           */\n\n        }, {\n          key: 'defaultTarget',\n          value: function defaultTarget(trigger) {\n            var selector = getAttributeValue('target', trigger);\n\n            if (selector) {\n              return document.querySelector(selector);\n            }\n          }\n          /**\n           * Returns the support of the given action, or all actions if no action is\n           * given.\n           * @param {String} [action]\n           */\n\n        }, {\n          key: 'defaultText',\n\n          /**\n           * Default `text` lookup function.\n           * @param {Element} trigger\n           */\n          value: function defaultText(trigger) {\n            return getAttributeValue('text', trigger);\n          }\n          /**\n           * Destroy lifecycle.\n           */\n\n        }, {\n          key: 'destroy',\n          value: function destroy() {\n            this.listener.destroy();\n\n            if (this.clipboardAction) {\n              this.clipboardAction.destroy();\n              this.clipboardAction = null;\n            }\n          }\n        }], [{\n          key: 'isSupported',\n          value: function isSupported() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];\n            var actions = typeof action === 'string' ? [action] : action;\n            var support = !!document.queryCommandSupported;\n            actions.forEach(function (action) {\n              support = support && !!document.queryCommandSupported(action);\n            });\n            return support;\n          }\n        }]);\n\n        return Clipboard;\n      }(_tinyEmitter2.default);\n      /**\n       * Helper function to retrieve attribute value.\n       * @param {String} suffix\n       * @param {Element} element\n       */\n\n\n      function getAttributeValue(suffix, element) {\n        var attribute = 'data-clipboard-' + suffix;\n\n        if (!element.hasAttribute(attribute)) {\n          return;\n        }\n\n        return element.getAttribute(attribute);\n      }\n\n      module.exports = Clipboard;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _select = __webpack_require__(2);\n\n      var _select2 = _interopRequireDefault(_select);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Inner class which performs selection from either `text` or `target`\n       * properties and then executes copy or cut operations.\n       */\n\n\n      var ClipboardAction = function () {\n        /**\n         * @param {Object} options\n         */\n        function ClipboardAction(options) {\n          _classCallCheck(this, ClipboardAction);\n\n          this.resolveOptions(options);\n          this.initSelection();\n        }\n        /**\n         * Defines base properties passed from constructor.\n         * @param {Object} options\n         */\n\n\n        _createClass(ClipboardAction, [{\n          key: 'resolveOptions',\n          value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            this.action = options.action;\n            this.container = options.container;\n            this.emitter = options.emitter;\n            this.target = options.target;\n            this.text = options.text;\n            this.trigger = options.trigger;\n            this.selectedText = '';\n          }\n          /**\n           * Decides which selection strategy is going to be applied based\n           * on the existence of `text` and `target` properties.\n           */\n\n        }, {\n          key: 'initSelection',\n          value: function initSelection() {\n            if (this.text) {\n              this.selectFake();\n            } else if (this.target) {\n              this.selectTarget();\n            }\n          }\n          /**\n           * Creates a fake textarea element, sets its value from `text` property,\n           * and makes a selection on it.\n           */\n\n        }, {\n          key: 'selectFake',\n          value: function selectFake() {\n            var _this = this;\n\n            var isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n            this.removeFake();\n\n            this.fakeHandlerCallback = function () {\n              return _this.removeFake();\n            };\n\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n            this.fakeElem = document.createElement('textarea'); // Prevent zooming on iOS\n\n            this.fakeElem.style.fontSize = '12pt'; // Reset box model\n\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0'; // Move element out of screen horizontally\n\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n            var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = yPosition + 'px';\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n            this.container.appendChild(this.fakeElem);\n            this.selectedText = (0, _select2.default)(this.fakeElem);\n            this.copyText();\n          }\n          /**\n           * Only removes the fake element after another click event, that way\n           * a user can hit `Ctrl+C` to copy because selection still exists.\n           */\n\n        }, {\n          key: 'removeFake',\n          value: function removeFake() {\n            if (this.fakeHandler) {\n              this.container.removeEventListener('click', this.fakeHandlerCallback);\n              this.fakeHandler = null;\n              this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n              this.container.removeChild(this.fakeElem);\n              this.fakeElem = null;\n            }\n          }\n          /**\n           * Selects the content from element passed on `target` property.\n           */\n\n        }, {\n          key: 'selectTarget',\n          value: function selectTarget() {\n            this.selectedText = (0, _select2.default)(this.target);\n            this.copyText();\n          }\n          /**\n           * Executes the copy operation based on the current selection.\n           */\n\n        }, {\n          key: 'copyText',\n          value: function copyText() {\n            var succeeded = void 0;\n\n            try {\n              succeeded = document.execCommand(this.action);\n            } catch (err) {\n              succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n          }\n          /**\n           * Fires an event based on the copy operation result.\n           * @param {Boolean} succeeded\n           */\n\n        }, {\n          key: 'handleResult',\n          value: function handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n              action: this.action,\n              text: this.selectedText,\n              trigger: this.trigger,\n              clearSelection: this.clearSelection.bind(this)\n            });\n          }\n          /**\n           * Moves focus away from `target` and back to the trigger, removes current selection.\n           */\n\n        }, {\n          key: 'clearSelection',\n          value: function clearSelection() {\n            if (this.trigger) {\n              this.trigger.focus();\n            }\n\n            window.getSelection().removeAllRanges();\n          }\n          /**\n           * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n           * @param {String} action\n           */\n\n        }, {\n          key: 'destroy',\n\n          /**\n           * Destroy lifecycle.\n           */\n          value: function destroy() {\n            this.removeFake();\n          }\n        }, {\n          key: 'action',\n          set: function set() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n              throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n          }\n          /**\n           * Gets the `action` property.\n           * @return {String}\n           */\n          ,\n          get: function get() {\n            return this._action;\n          }\n          /**\n           * Sets the `target` property using an element\n           * that will be have its content copied.\n           * @param {Element} target\n           */\n\n        }, {\n          key: 'target',\n          set: function set(target) {\n            if (target !== undefined) {\n              if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {\n                if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                  throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                }\n\n                if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                  throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                }\n\n                this._target = target;\n              } else {\n                throw new Error('Invalid \"target\" value, use a valid Element');\n              }\n            }\n          }\n          /**\n           * Gets the `target` property.\n           * @return {String|HTMLElement}\n           */\n          ,\n          get: function get() {\n            return this._target;\n          }\n        }]);\n\n        return ClipboardAction;\n      }();\n\n      module.exports = ClipboardAction;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      function select(element) {\n        var selectedText;\n\n        if (element.nodeName === 'SELECT') {\n          element.focus();\n          selectedText = element.value;\n        } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n          var isReadOnly = element.hasAttribute('readonly');\n\n          if (!isReadOnly) {\n            element.setAttribute('readonly', '');\n          }\n\n          element.select();\n          element.setSelectionRange(0, element.value.length);\n\n          if (!isReadOnly) {\n            element.removeAttribute('readonly');\n          }\n\n          selectedText = element.value;\n        } else {\n          if (element.hasAttribute('contenteditable')) {\n            element.focus();\n          }\n\n          var selection = window.getSelection();\n          var range = document.createRange();\n          range.selectNodeContents(element);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          selectedText = selection.toString();\n        }\n\n        return selectedText;\n      }\n\n      module.exports = select;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      function E() {// Keep this empty so it's easier to inherit from\n        // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n      }\n\n      E.prototype = {\n        on: function on(name, callback, ctx) {\n          var e = this.e || (this.e = {});\n          (e[name] || (e[name] = [])).push({\n            fn: callback,\n            ctx: ctx\n          });\n          return this;\n        },\n        once: function once(name, callback, ctx) {\n          var self = this;\n\n          function listener() {\n            self.off(name, listener);\n            callback.apply(ctx, arguments);\n          }\n\n          ;\n          listener._ = callback;\n          return this.on(name, listener, ctx);\n        },\n        emit: function emit(name) {\n          var data = [].slice.call(arguments, 1);\n          var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n          var i = 0;\n          var len = evtArr.length;\n\n          for (i; i < len; i++) {\n            evtArr[i].fn.apply(evtArr[i].ctx, data);\n          }\n\n          return this;\n        },\n        off: function off(name, callback) {\n          var e = this.e || (this.e = {});\n          var evts = e[name];\n          var liveEvents = [];\n\n          if (evts && callback) {\n            for (var i = 0, len = evts.length; i < len; i++) {\n              if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);\n            }\n          } // Remove event from queue to prevent memory leak\n          // Suggested by https://github.com/lazd\n          // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n\n          liveEvents.length ? e[name] = liveEvents : delete e[name];\n          return this;\n        }\n      };\n      module.exports = E;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var is = __webpack_require__(5);\n\n      var delegate = __webpack_require__(6);\n      /**\n       * Validates all params and calls the right\n       * listener function based on its target type.\n       *\n       * @param {String|HTMLElement|HTMLCollection|NodeList} target\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listen(target, type, callback) {\n        if (!target && !type && !callback) {\n          throw new Error('Missing required arguments');\n        }\n\n        if (!is.string(type)) {\n          throw new TypeError('Second argument must be a String');\n        }\n\n        if (!is.fn(callback)) {\n          throw new TypeError('Third argument must be a Function');\n        }\n\n        if (is.node(target)) {\n          return listenNode(target, type, callback);\n        } else if (is.nodeList(target)) {\n          return listenNodeList(target, type, callback);\n        } else if (is.string(target)) {\n          return listenSelector(target, type, callback);\n        } else {\n          throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');\n        }\n      }\n      /**\n       * Adds an event listener to a HTML element\n       * and returns a remove listener function.\n       *\n       * @param {HTMLElement} node\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenNode(node, type, callback) {\n        node.addEventListener(type, callback);\n        return {\n          destroy: function destroy() {\n            node.removeEventListener(type, callback);\n          }\n        };\n      }\n      /**\n       * Add an event listener to a list of HTML elements\n       * and returns a remove listener function.\n       *\n       * @param {NodeList|HTMLCollection} nodeList\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenNodeList(nodeList, type, callback) {\n        Array.prototype.forEach.call(nodeList, function (node) {\n          node.addEventListener(type, callback);\n        });\n        return {\n          destroy: function destroy() {\n            Array.prototype.forEach.call(nodeList, function (node) {\n              node.removeEventListener(type, callback);\n            });\n          }\n        };\n      }\n      /**\n       * Add an event listener to a selector\n       * and returns a remove listener function.\n       *\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenSelector(selector, type, callback) {\n        return delegate(document.body, selector, type, callback);\n      }\n\n      module.exports = listen;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Check if argument is a HTML element.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n      exports.node = function (value) {\n        return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;\n      };\n      /**\n       * Check if argument is a list of HTML elements.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.nodeList = function (value) {\n        var type = Object.prototype.toString.call(value);\n        return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));\n      };\n      /**\n       * Check if argument is a string.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.string = function (value) {\n        return typeof value === 'string' || value instanceof String;\n      };\n      /**\n       * Check if argument is a function.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.fn = function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Function]';\n      };\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var closest = __webpack_require__(7);\n      /**\n       * Delegates event to a selector.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @param {Boolean} useCapture\n       * @return {Object}\n       */\n\n\n      function _delegate(element, selector, type, callback, useCapture) {\n        var listenerFn = listener.apply(this, arguments);\n        element.addEventListener(type, listenerFn, useCapture);\n        return {\n          destroy: function destroy() {\n            element.removeEventListener(type, listenerFn, useCapture);\n          }\n        };\n      }\n      /**\n       * Delegates event to a selector.\n       *\n       * @param {Element|String|Array} [elements]\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @param {Boolean} useCapture\n       * @return {Object}\n       */\n\n\n      function delegate(elements, selector, type, callback, useCapture) {\n        // Handle the regular Element usage\n        if (typeof elements.addEventListener === 'function') {\n          return _delegate.apply(null, arguments);\n        } // Handle Element-less usage, it defaults to global delegation\n\n\n        if (typeof type === 'function') {\n          // Use `document` as the first parameter, then apply arguments\n          // This is a short way to .unshift `arguments` without running into deoptimizations\n          return _delegate.bind(null, document).apply(null, arguments);\n        } // Handle Selector-based usage\n\n\n        if (typeof elements === 'string') {\n          elements = document.querySelectorAll(elements);\n        } // Handle Array-like based usage\n\n\n        return Array.prototype.map.call(elements, function (element) {\n          return _delegate(element, selector, type, callback, useCapture);\n        });\n      }\n      /**\n       * Finds closest match and invokes callback.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Function}\n       */\n\n\n      function listener(element, selector, type, callback) {\n        return function (e) {\n          e.delegateTarget = closest(e.target, selector);\n\n          if (e.delegateTarget) {\n            callback.call(element, e);\n          }\n        };\n      }\n\n      module.exports = delegate;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports) {\n      var DOCUMENT_NODE_TYPE = 9;\n      /**\n       * A polyfill for Element.matches()\n       */\n\n      if (typeof Element !== 'undefined' && !Element.prototype.matches) {\n        var proto = Element.prototype;\n        proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;\n      }\n      /**\n       * Finds the closest parent that matches a selector.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @return {Function}\n       */\n\n\n      function closest(element, selector) {\n        while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\n          if (typeof element.matches === 'function' && element.matches(selector)) {\n            return element;\n          }\n\n          element = element.parentNode;\n        }\n      }\n\n      module.exports = closest;\n      /***/\n    }\n    /******/\n    ])\n  );\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/clipboard/dist/clipboard.js?")},"./node_modules/get-own-property-symbols/build/get-own-property-symbols.max.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\nCopyright (C) 2015 by WebReflection\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n(function (Object, GOPS) {\n  'use strict'; // (C) Andrea Giammarchi - Mit Style\n\n  if (GOPS in Object) return;\n\n  var setDescriptor,\n      G = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) === _typeof(G) ? window : global,\n      id = 0,\n      random = '' + Math.random(),\n      prefix = '__\\x01symbol:',\n      prefixLength = prefix.length,\n      internalSymbol = '__\\x01symbol@@' + random,\n      DP = 'defineProperty',\n      DPies = 'defineProperties',\n      GOPN = 'getOwnPropertyNames',\n      GOPD = 'getOwnPropertyDescriptor',\n      PIE = 'propertyIsEnumerable',\n      gOPN = Object[GOPN],\n      gOPD = Object[GOPD],\n      create = Object.create,\n      keys = Object.keys,\n      freeze = Object.freeze || Object,\n      defineProperty = Object[DP],\n      $defineProperties = Object[DPies],\n      descriptor = gOPD(Object, GOPN),\n      ObjectProto = Object.prototype,\n      hOP = ObjectProto.hasOwnProperty,\n      pIE = ObjectProto[PIE],\n      toString = ObjectProto.toString,\n      addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {\n    if (!hOP.call(o, internalSymbol)) {\n      defineProperty(o, internalSymbol, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: {}\n      });\n    }\n\n    o[internalSymbol]['@@' + uid] = enumerable;\n  },\n      createWithSymbols = function createWithSymbols(proto, descriptors) {\n    var self = create(proto);\n    gOPN(descriptors).forEach(function (key) {\n      if (propertyIsEnumerable.call(descriptors, key)) {\n        $defineProperty(self, key, descriptors[key]);\n      }\n    });\n    return self;\n  },\n      copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {\n    var newDescriptor = create(descriptor);\n    newDescriptor.enumerable = false;\n    return newDescriptor;\n  },\n      get = function get() {},\n      onlyNonSymbols = function onlyNonSymbols(name) {\n    return name != internalSymbol && !hOP.call(source, name);\n  },\n      onlySymbols = function onlySymbols(name) {\n    return name != internalSymbol && hOP.call(source, name);\n  },\n      propertyIsEnumerable = function propertyIsEnumerable(key) {\n    var uid = '' + key;\n    return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol]['@@' + uid] : pIE.call(this, key);\n  },\n      setAndGetSymbol = function setAndGetSymbol(uid) {\n    var descriptor = {\n      enumerable: false,\n      configurable: true,\n      get: get,\n      set: function set(value) {\n        setDescriptor(this, uid, {\n          enumerable: false,\n          configurable: true,\n          writable: true,\n          value: value\n        });\n        addInternalIfNeeded(this, uid, true);\n      }\n    };\n    defineProperty(ObjectProto, uid, descriptor);\n    return freeze(source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor));\n  },\n      _Symbol = function _Symbol2(description) {\n    if (this instanceof _Symbol2) {\n      throw new TypeError('Symbol is not a constructor');\n    }\n\n    return setAndGetSymbol(prefix.concat(description || '', random, ++id));\n  },\n      source = create(null),\n      sourceConstructor = {\n    value: _Symbol\n  },\n      sourceMap = function sourceMap(uid) {\n    return source[uid];\n  },\n      $defineProperty = function defineProp(o, key, descriptor) {\n    var uid = '' + key;\n\n    if (onlySymbols(uid)) {\n      setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);\n      addInternalIfNeeded(o, uid, !!descriptor.enumerable);\n    } else {\n      defineProperty(o, key, descriptor);\n    }\n\n    return o;\n  },\n      $getOwnPropertySymbols = function getOwnPropertySymbols(o) {\n    return gOPN(o).filter(onlySymbols).map(sourceMap);\n  };\n\n  descriptor.value = $defineProperty;\n  defineProperty(Object, DP, descriptor);\n  descriptor.value = $getOwnPropertySymbols;\n  defineProperty(Object, GOPS, descriptor);\n\n  descriptor.value = function getOwnPropertyNames(o) {\n    return gOPN(o).filter(onlyNonSymbols);\n  };\n\n  defineProperty(Object, GOPN, descriptor);\n\n  descriptor.value = function defineProperties(o, descriptors) {\n    var symbols = $getOwnPropertySymbols(descriptors);\n\n    if (symbols.length) {\n      keys(descriptors).concat(symbols).forEach(function (uid) {\n        if (propertyIsEnumerable.call(descriptors, uid)) {\n          $defineProperty(o, uid, descriptors[uid]);\n        }\n      });\n    } else {\n      $defineProperties(o, descriptors);\n    }\n\n    return o;\n  };\n\n  defineProperty(Object, DPies, descriptor);\n  descriptor.value = propertyIsEnumerable;\n  defineProperty(ObjectProto, PIE, descriptor);\n  descriptor.value = _Symbol;\n  defineProperty(G, 'Symbol', descriptor); // defining `Symbol.for(key)`\n\n  descriptor.value = function (key) {\n    var uid = prefix.concat(prefix, key, random);\n    return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);\n  };\n\n  defineProperty(_Symbol, 'for', descriptor); // defining `Symbol.keyFor(symbol)`\n\n  descriptor.value = function (symbol) {\n    if (onlyNonSymbols(symbol)) throw new TypeError(symbol + ' is not a symbol');\n\n    if (!hOP.call(source, symbol)) {\n      return void 0;\n    }\n\n    var label = symbol.slice(prefixLength);\n\n    if (label.slice(0, prefixLength) !== prefix) {\n      return void 0;\n    }\n\n    label = label.slice(prefixLength);\n\n    if (label === random) {\n      return void 0;\n    }\n\n    label = label.slice(0, label.length - random.length);\n    return label.length > 0 ? label : void 0;\n  };\n\n  defineProperty(_Symbol, 'keyFor', descriptor);\n\n  descriptor.value = function getOwnPropertyDescriptor(o, key) {\n    var descriptor = gOPD(o, key);\n\n    if (descriptor && onlySymbols(key)) {\n      descriptor.enumerable = propertyIsEnumerable.call(o, key);\n    }\n\n    return descriptor;\n  };\n\n  defineProperty(Object, GOPD, descriptor);\n\n  descriptor.value = function (proto, descriptors) {\n    return arguments.length === 1 || typeof descriptors === \"undefined\" ? create(proto) : createWithSymbols(proto, descriptors);\n  };\n\n  defineProperty(Object, 'create', descriptor);\n\n  descriptor.value = function () {\n    var str = toString.call(this);\n    return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;\n  };\n\n  defineProperty(ObjectProto, 'toString', descriptor);\n\n  try {\n    // fails in few pre ES 5.1 engines\n    if (true === create(defineProperty({}, prefix, {\n      get: function get() {\n        return defineProperty(this, prefix, {\n          value: true\n        })[prefix];\n      }\n    }))[prefix]) {\n      setDescriptor = defineProperty;\n    } else {\n      throw 'IE11';\n    }\n  } catch (o_O) {\n    setDescriptor = function setDescriptor(o, key, descriptor) {\n      var protoDescriptor = gOPD(ObjectProto, key);\n      delete ObjectProto[key];\n      defineProperty(o, key, descriptor);\n      defineProperty(ObjectProto, key, protoDescriptor);\n    };\n  }\n})(Object, 'getOwnPropertySymbols');\n\n(function (O, _Symbol3) {\n  'use strict';\n\n  var dP = O.defineProperty,\n      ObjectProto = O.prototype,\n      toString = ObjectProto.toString,\n      toStringTag = 'toStringTag',\n      descriptor;\n  ['iterator', // A method returning the default iterator for an object. Used by for...of.\n  'match', // A method that matches against a string, also used to determine if an object may be used as a regular expression. Used by String.prototype.match().\n  'replace', // A method that replaces matched substrings of a string. Used by String.prototype.replace().\n  'search', // A method that returns the index within a string that matches the regular expression. Used by String.prototype.search().\n  'split', // A method that splits a string at the indices that match a regular expression. Used by String.prototype.split().\n  'hasInstance', // A method determining if a constructor object recognizes an object as its instance. Used by instanceof.\n  'isConcatSpreadable', // A Boolean value indicating if an object should be flattened to its array elements. Used by Array.prototype.concat().\n  'unscopables', // An Array of string values that are property values. These are excluded from the with environment bindings of the associated objects.\n  'species', // A constructor function that is used to create derived objects.\n  'toPrimitive', // A method converting an object to a primitive value.\n  toStringTag // A string value used for the default description of an object. Used by Object.prototype.toString().\n  ].forEach(function (name) {\n    if (!(name in _Symbol3)) {\n      dP(_Symbol3, name, {\n        value: _Symbol3(name)\n      });\n\n      switch (name) {\n        case toStringTag:\n          descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');\n\n          descriptor.value = function () {\n            var str = toString.call(this),\n                tst = this != null ? this[_Symbol3.toStringTag] : this;\n            return tst == null ? str : '[object ' + tst + ']';\n          };\n\n          dP(ObjectProto, 'toString', descriptor);\n          break;\n      }\n    }\n  });\n})(Object, Symbol);\n\n(function (Si, AP, SP) {\n  function returnThis() {\n    return this;\n  } // make Arrays usable as iterators\n  // so that other iterables can copy same logic\n\n\n  if (!AP[Si]) AP[Si] = function () {\n    var i = 0,\n        self = this,\n        iterator = {\n      next: function next() {\n        var done = self.length <= i;\n        return done ? {\n          done: done\n        } : {\n          done: done,\n          value: self[i++]\n        };\n      }\n    };\n    iterator[Si] = returnThis;\n    return iterator;\n  }; // make Strings usable as iterators\n  // to simplify Array.from and for/of like loops\n\n  if (!SP[Si]) SP[Si] = function () {\n    var fromCodePoint = String.fromCodePoint,\n        self = this,\n        i = 0,\n        length = self.length,\n        iterator = {\n      next: function next() {\n        var done = length <= i,\n            c = done ? '' : fromCodePoint(self.codePointAt(i));\n        i += c.length;\n        return done ? {\n          done: done\n        } : {\n          done: done,\n          value: c\n        };\n      }\n    };\n    iterator[Si] = returnThis;\n    return iterator;\n  };\n})(Symbol.iterator, Array.prototype, String.prototype);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/get-own-property-symbols/build/get-own-property-symbols.max.js?")},"./node_modules/mousetrap/mousetrap.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.3\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n\n\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n\n  var _REVERSE_MAP;\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n\n\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n\n\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n\n\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n\n    object.attachEvent('on' + type, callback);\n  }\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n\n\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n\n      return character;\n    } // for non keypress events the special maps are needed\n\n\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    } // if it is not in the special map\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n\n\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n\n\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n\n\n  function _eventModifiers(e) {\n    var modifiers = [];\n\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n\n    return modifiers;\n  }\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n\n    e.returnValue = false;\n  }\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n\n    e.cancelBubble = true;\n  }\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n\n\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n\n    return _REVERSE_MAP;\n  }\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n\n\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    } // modifier keys don't work as expected with keypress,\n    // switch to keydown\n\n\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n\n    return action;\n  }\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n\n\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n\n\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = []; // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n\n    keys = _keysFromString(combination);\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i]; // normalize key names\n\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      } // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n\n\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      } // if this key is a modifier then add it to the list of modifiers\n\n\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    } // depending on what the key combination is\n    // we will try to pick the best event for it\n\n\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n\n    if (element === ancestor) {\n      return true;\n    }\n\n    return _belongsTo(element.parentNode, ancestor);\n  }\n\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n\n\n    self.target = targetElement;\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n\n    self._callbacks = {};\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n\n    self._directMap = {};\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n\n    var _sequenceLevels = {};\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n\n    var _resetTimer;\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n\n\n    var _ignoreNextKeyup = false;\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n\n    var _ignoreNextKeypress = false;\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n\n    var _nextExpectedAction = false;\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n          key;\n\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n\n        _sequenceLevels[key] = 0;\n      }\n\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n\n\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type; // if there are no events related to this keycode\n\n      if (!self._callbacks[character]) {\n        return [];\n      } // if a modifier key is coming up on its own we should allow it\n\n\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      } // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n\n\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        } // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n\n\n        if (action != callback.action) {\n          continue;\n        } // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n\n\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n\n          matches.push(callback);\n        }\n      }\n\n      return matches;\n    }\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n\n        _stopPropagation(e);\n      }\n    }\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      } // loop through matching callbacks for this key event\n\n\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n\n          processedSequenceCallback = true; // keep a list of which sequences were matches for later\n\n          doNotReset[callbacks[i].seq] = 1;\n\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\n          continue;\n        } // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n\n\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      } // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n\n\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n\n      var character = _characterFromEvent(e); // no character found then stop\n\n\n      if (!character) {\n        return;\n      } // need to use === for the character check because the character can be 0\n\n\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n\n\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n\n\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n\n          _resetSequenceTimer();\n        };\n      }\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n\n\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n\n\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        } // weird race condition if a sequence ends with the key\n        // another sequence begins with\n\n\n        setTimeout(_resetSequences, 10);\n      } // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n\n\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n\n\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space\n\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info; // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n\n        return;\n      }\n\n      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time\n      // a callback is added for this key\n\n      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one\n\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level); // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n\n\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n\n\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    }; // start!\n\n\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n\n    self._bindMultiple.call(self, keys, callback, action);\n\n    return self;\n  };\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n\n    return self;\n  };\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this; // if the element has the class \"mousetrap\" then no need to stop\n\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    if (_belongsTo(element, self.target)) {\n      return false;\n    } // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n    // not the initial event target in the shadow tree. Note that not all events cross the\n    // shadow boundary.\n    // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n    // the eventâs composed path. For shadow trees with `mode: 'closed'`, the initial event\n    // target cannot be obtained.\n\n\n    if ('composedPath' in e && typeof e.composedPath === 'function') {\n      // For open shadow trees, update `element` so that the following check works.\n      var initialEventTarget = e.composedPath()[0];\n\n      if (initialEventTarget !== e.target) {\n        element = initialEventTarget;\n      }\n    } // stop for input, select, and textarea\n\n\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n\n\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n  /**\n   * allow custom key mappings\n   */\n\n\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n\n    _REVERSE_MAP = null;\n  };\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n\n\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n\n  Mousetrap.init(); // expose mousetrap to the global object\n\n  window.Mousetrap = Mousetrap; // expose as a common js module\n\n  if ( true && module.exports) {\n    module.exports = Mousetrap;\n  } // expose mousetrap as an AMD module\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Mousetrap;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);\n\n//# sourceURL=webpack:///./node_modules/mousetrap/mousetrap.js?")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./node_modules/webpack/buildin/module.js":function(module,exports){eval('module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, "loaded", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, "id", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?')},"./node_modules/wolfy87-eventemitter/EventEmitter.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * EventEmitter v5.2.8 - git.io/ee\n * Unlicense - http://unlicense.org/\n * Oliver Caldwell - https://oli.me.uk/\n * @preserve\n */\n;\n\n(function (exports) {\n  'use strict';\n  /**\n   * Class for managing events.\n   * Can be extended to provide event functionality in other classes.\n   *\n   * @class EventEmitter Manages event registering and emitting.\n   */\n\n  function EventEmitter() {} // Shortcuts to improve speed and size\n\n\n  var proto = EventEmitter.prototype;\n  var originalGlobalValue = exports.EventEmitter;\n  /**\n   * Finds the index of the listener for the event in its storage array.\n   *\n   * @param {Function[]} listeners Array of listeners to search through.\n   * @param {Function} listener Method to look for.\n   * @return {Number} Index of the specified listener, -1 if not found\n   * @api private\n   */\n\n  function indexOfListener(listeners, listener) {\n    var i = listeners.length;\n\n    while (i--) {\n      if (listeners[i].listener === listener) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Alias a method while keeping the context correct, to allow for overwriting of target method.\n   *\n   * @param {String} name The name of the target method.\n   * @return {Function} The aliased method\n   * @api private\n   */\n\n\n  function alias(name) {\n    return function aliasClosure() {\n      return this[name].apply(this, arguments);\n    };\n  }\n  /**\n   * Returns the listener array for the specified event.\n   * Will initialise the event object and listener arrays if required.\n   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n   * Each property in the object response is an array of listener functions.\n   *\n   * @param {String|RegExp} evt Name of the event to return the listeners from.\n   * @return {Function[]|Object} All listener functions for the event.\n   */\n\n\n  proto.getListeners = function getListeners(evt) {\n    var events = this._getEvents();\n\n    var response;\n    var key; // Return a concatenated array of all matching events if\n    // the selector is a regular expression.\n\n    if (evt instanceof RegExp) {\n      response = {};\n\n      for (key in events) {\n        if (events.hasOwnProperty(key) && evt.test(key)) {\n          response[key] = events[key];\n        }\n      }\n    } else {\n      response = events[evt] || (events[evt] = []);\n    }\n\n    return response;\n  };\n  /**\n   * Takes a list of listener objects and flattens it into a list of listener functions.\n   *\n   * @param {Object[]} listeners Raw listener objects.\n   * @return {Function[]} Just the listener functions.\n   */\n\n\n  proto.flattenListeners = function flattenListeners(listeners) {\n    var flatListeners = [];\n    var i;\n\n    for (i = 0; i < listeners.length; i += 1) {\n      flatListeners.push(listeners[i].listener);\n    }\n\n    return flatListeners;\n  };\n  /**\n   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n   *\n   * @param {String|RegExp} evt Name of the event to return the listeners from.\n   * @return {Object} All listener functions for an event in an object.\n   */\n\n\n  proto.getListenersAsObject = function getListenersAsObject(evt) {\n    var listeners = this.getListeners(evt);\n    var response;\n\n    if (listeners instanceof Array) {\n      response = {};\n      response[evt] = listeners;\n    }\n\n    return response || listeners;\n  };\n\n  function isValidListener(listener) {\n    if (typeof listener === 'function' || listener instanceof RegExp) {\n      return true;\n    } else if (listener && _typeof(listener) === 'object') {\n      return isValidListener(listener.listener);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Adds a listener function to the specified event.\n   * The listener will not be added if it is a duplicate.\n   * If the listener returns true then it will be removed after it is called.\n   * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to attach the listener to.\n   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.addListener = function addListener(evt, listener) {\n    if (!isValidListener(listener)) {\n      throw new TypeError('listener must be a function');\n    }\n\n    var listeners = this.getListenersAsObject(evt);\n    var listenerIsWrapped = _typeof(listener) === 'object';\n    var key;\n\n    for (key in listeners) {\n      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n        listeners[key].push(listenerIsWrapped ? listener : {\n          listener: listener,\n          once: false\n        });\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of addListener\n   */\n\n\n  proto.on = alias('addListener');\n  /**\n   * Semi-alias of addListener. It will add a listener that will be\n   * automatically removed after its first execution.\n   *\n   * @param {String|RegExp} evt Name of the event to attach the listener to.\n   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.addOnceListener = function addOnceListener(evt, listener) {\n    return this.addListener(evt, {\n      listener: listener,\n      once: true\n    });\n  };\n  /**\n   * Alias of addOnceListener.\n   */\n\n\n  proto.once = alias('addOnceListener');\n  /**\n   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n   * You need to tell it what event names should be matched by a regex.\n   *\n   * @param {String} evt Name of the event to create.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.defineEvent = function defineEvent(evt) {\n    this.getListeners(evt);\n    return this;\n  };\n  /**\n   * Uses defineEvent to define multiple events.\n   *\n   * @param {String[]} evts An array of event names to define.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.defineEvents = function defineEvents(evts) {\n    for (var i = 0; i < evts.length; i += 1) {\n      this.defineEvent(evts[i]);\n    }\n\n    return this;\n  };\n  /**\n   * Removes a listener function from the specified event.\n   * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to remove the listener from.\n   * @param {Function} listener Method to remove from the event.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeListener = function removeListener(evt, listener) {\n    var listeners = this.getListenersAsObject(evt);\n    var index;\n    var key;\n\n    for (key in listeners) {\n      if (listeners.hasOwnProperty(key)) {\n        index = indexOfListener(listeners[key], listener);\n\n        if (index !== -1) {\n          listeners[key].splice(index, 1);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of removeListener\n   */\n\n\n  proto.off = alias('removeListener');\n  /**\n   * Adds listeners in bulk using the manipulateListeners method.\n   * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n   * You can also pass it a regular expression to add the array of listeners to all events that match it.\n   * Yeah, this function does quite a bit. That's probably a bad thing.\n   *\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to add.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.addListeners = function addListeners(evt, listeners) {\n    // Pass through to manipulateListeners\n    return this.manipulateListeners(false, evt, listeners);\n  };\n  /**\n   * Removes listeners in bulk using the manipulateListeners method.\n   * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n   * You can also pass it an event name and an array of listeners to be removed.\n   * You can also pass it a regular expression to remove the listeners from all events that match it.\n   *\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to remove.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeListeners = function removeListeners(evt, listeners) {\n    // Pass through to manipulateListeners\n    return this.manipulateListeners(true, evt, listeners);\n  };\n  /**\n   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n   * The first argument will determine if the listeners are removed (true) or added (false).\n   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n   * You can also pass it an event name and an array of listeners to be added/removed.\n   * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n   *\n   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n    var i;\n    var value;\n    var single = remove ? this.removeListener : this.addListener;\n    var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method\n\n    if (_typeof(evt) === 'object' && !(evt instanceof RegExp)) {\n      for (i in evt) {\n        if (evt.hasOwnProperty(i) && (value = evt[i])) {\n          // Pass the single listener straight through to the singular method\n          if (typeof value === 'function') {\n            single.call(this, i, value);\n          } else {\n            // Otherwise pass back to the multiple function\n            multiple.call(this, i, value);\n          }\n        }\n      }\n    } else {\n      // So evt must be a string\n      // And listeners must be an array of listeners\n      // Loop over it and pass each one to the multiple method\n      i = listeners.length;\n\n      while (i--) {\n        single.call(this, evt, listeners[i]);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes all listeners from a specified event.\n   * If you do not specify an event then all listeners will be removed.\n   * That means every event will be emptied.\n   * You can also pass a regex to remove all events that match it.\n   *\n   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeEvent = function removeEvent(evt) {\n    var type = _typeof(evt);\n\n    var events = this._getEvents();\n\n    var key; // Remove different things depending on the state of evt\n\n    if (type === 'string') {\n      // Remove all listeners for the specified event\n      delete events[evt];\n    } else if (evt instanceof RegExp) {\n      // Remove all events matching the regex.\n      for (key in events) {\n        if (events.hasOwnProperty(key) && evt.test(key)) {\n          delete events[key];\n        }\n      }\n    } else {\n      // Remove all listeners in all events\n      delete this._events;\n    }\n\n    return this;\n  };\n  /**\n   * Alias of removeEvent.\n   *\n   * Added to mirror the node API.\n   */\n\n\n  proto.removeAllListeners = alias('removeEvent');\n  /**\n   * Emits an event of your choice.\n   * When emitted, every listener attached to that event will be executed.\n   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n   * So they will not arrive within the array on the other side, they will be separate.\n   * You can also pass a regular expression to emit to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n   * @param {Array} [args] Optional array of arguments to be passed to each listener.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.emitEvent = function emitEvent(evt, args) {\n    var listenersMap = this.getListenersAsObject(evt);\n    var listeners;\n    var listener;\n    var i;\n    var key;\n    var response;\n\n    for (key in listenersMap) {\n      if (listenersMap.hasOwnProperty(key)) {\n        listeners = listenersMap[key].slice(0);\n\n        for (i = 0; i < listeners.length; i++) {\n          // If the listener returns true then it shall be removed from the event\n          // The function is executed either with a basic call or an apply if there is an args array\n          listener = listeners[i];\n\n          if (listener.once === true) {\n            this.removeListener(evt, listener.listener);\n          }\n\n          response = listener.listener.apply(this, args || []);\n\n          if (response === this._getOnceReturnValue()) {\n            this.removeListener(evt, listener.listener);\n          }\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of emitEvent\n   */\n\n\n  proto.trigger = alias('emitEvent');\n  /**\n   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n   * @param {...*} Optional additional arguments to be passed to each listener.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.emit = function emit(evt) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return this.emitEvent(evt, args);\n  };\n  /**\n   * Sets the current value to check against when executing listeners. If a\n   * listeners return value matches the one set here then it will be removed\n   * after execution. This value defaults to true.\n   *\n   * @param {*} value The new value to check for when executing listeners.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.setOnceReturnValue = function setOnceReturnValue(value) {\n    this._onceReturnValue = value;\n    return this;\n  };\n  /**\n   * Fetches the current value to check against when executing listeners. If\n   * the listeners return value matches this one then it should be removed\n   * automatically. It will return true by default.\n   *\n   * @return {*|Boolean} The current value to check for or the default, true.\n   * @api private\n   */\n\n\n  proto._getOnceReturnValue = function _getOnceReturnValue() {\n    if (this.hasOwnProperty('_onceReturnValue')) {\n      return this._onceReturnValue;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Fetches the events object and creates one if required.\n   *\n   * @return {Object} The events storage object.\n   * @api private\n   */\n\n\n  proto._getEvents = function _getEvents() {\n    return this._events || (this._events = {});\n  };\n  /**\n   * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n   *\n   * @return {Function} Non conflicting EventEmitter class.\n   */\n\n\n  EventEmitter.noConflict = function noConflict() {\n    exports.EventEmitter = originalGlobalValue;\n    return EventEmitter;\n  }; // Expose the class either via AMD, CommonJS or the global object\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return EventEmitter;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(typeof window !== 'undefined' ? window : this || {});\n\n//# sourceURL=webpack:///./node_modules/wolfy87-eventemitter/EventEmitter.js?")},"./src/scripts/components/panels-util.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "panelsUtil", function() { return panelsUtil; });\n/* eslint-disable no-unused-vars */\n\n/**\n * Panels Util - for both styleguide and viewer\n */\nvar panelsUtil = {\n  /**\n   * Add click events to the template that was rendered\n   * @param  {String}      the rendered template for the modal\n   * @param  {String}      the pattern partial for the modal\n   */\n  addClickEvents: function addClickEvents(templateRendered, patternPartial) {\n    var els = templateRendered.querySelectorAll(\'.pl-js-tab-link\');\n\n    for (var i = 0; i < els.length; ++i) {\n      els[i].onclick = function (e) {\n        e.preventDefault();\n        var partial = this.getAttribute(\'data-patternpartial\');\n        var panelID = this.getAttribute(\'data-panelid\');\n        panelsUtil.show(partial, panelID);\n      };\n    }\n\n    return templateRendered;\n  },\n\n  /**\n   * Show a specific modal\n   * @param  {String}      the pattern partial for the modal\n   * @param  {String}      the ID of the panel to be shown\n   */\n  show: function show(patternPartial, panelID) {\n    var activeTabClass = \'pl-is-active-tab\'; // tabPanelabout to become active\n\n    var activeTabPanel = document.querySelector("#pl-".concat(patternPartial, "-").concat(panelID, "-panel"));\n    var parentTabs = activeTabPanel.closest(\'.pl-js-tabs\'); // turn off all of the active tabs\n\n    var allTabLinks = parentTabs.querySelectorAll(".pl-js-tab-link"); // hide all of the panels\n\n    var allTabPanels = parentTabs.querySelectorAll(".pl-js-tab-panel"); // tabLink about to become active\n\n    var activeTabLink = parentTabs.querySelector("#pl-".concat(patternPartial, "-").concat(panelID, "-tab"));\n\n    for (var i = 0; i < allTabLinks.length; ++i) {\n      allTabLinks[i].classList.remove(activeTabClass);\n    }\n\n    for (var _i = 0; _i < allTabPanels.length; ++_i) {\n      allTabPanels[_i].classList.remove(activeTabClass);\n    }\n\n    activeTabLink.classList.add(activeTabClass);\n    activeTabPanel.classList.add(activeTabClass);\n  }\n};\n\n//# sourceURL=webpack:///./src/scripts/components/panels-util.js?')},"./src/scripts/components/pl-copy-to-clipboard/pl-copy-to-clipboard.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clipboard */ \"./node_modules/clipboard/dist/clipboard.js\");\n/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Copy to clipboard functionality for code snippet examples\n */\n\nvar clipboard = new clipboard__WEBPACK_IMPORTED_MODULE_0___default.a('.pl-js-code-copy-btn');\nclipboard.on('success', function (e) {\n  var copyButton = document.querySelectorAll('.pl-js-code-copy-btn');\n\n  for (var i = 0; i < copyButton.length; i++) {\n    copyButton[i].innerText = 'Copy';\n  }\n\n  e.trigger.textContent = 'Copied';\n});\n\n//# sourceURL=webpack:///./src/scripts/components/pl-copy-to-clipboard/pl-copy-to-clipboard.js?")},"./src/scripts/patternlab-pattern.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/scripts/utils/polyfills/custom-event-polyfill.js\nvar custom_event_polyfill = __webpack_require__(\"./src/scripts/utils/polyfills/custom-event-polyfill.js\");\n\n// EXTERNAL MODULE: ./src/scripts/utils/polyfills/symbol-polyfill.js\nvar symbol_polyfill = __webpack_require__(\"./src/scripts/utils/polyfills/symbol-polyfill.js\");\n\n// EXTERNAL MODULE: ./src/scripts/components/panels-util.js\nvar panels_util = __webpack_require__(\"./src/scripts/components/panels-util.js\");\n\n// EXTERNAL MODULE: ./src/scripts/components/pl-copy-to-clipboard/pl-copy-to-clipboard.js\nvar pl_copy_to_clipboard = __webpack_require__(\"./src/scripts/components/pl-copy-to-clipboard/pl-copy-to-clipboard.js\");\n\n// CONCATENATED MODULE: ./src/scripts/components/modal-styleguide.js\n/* eslint-disable no-param-reassign, no-unused-vars */\n\n/**\n * \"Modal\" (aka Panel UI) for the Styleguide Layer - for both annotations and code/info\n */\n\n\nvar modalStyleguide = {\n  // set up some defaults\n  active: [],\n  targetOrigin: window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host,\n\n  /**\n   * initialize the modal window\n   */\n  onReady: function onReady() {\n    // go through the panel toggles and add click event to the pattern extra toggle button\n    var toggles = document.querySelectorAll('.pl-js-pattern-extra-toggle');\n    toggles.forEach(function (toggle) {\n      toggle.addEventListener('click', function (e) {\n        var patternPartial = toggle.getAttribute('data-patternpartial');\n        modalStyleguide.toggle(patternPartial);\n      });\n    });\n  },\n\n  /**\n   * toggle the modal window open and closed based on clicking the pip\n   * @param  {String}       the patternPartial that identifies what needs to be toggled\n   */\n  toggle: function toggle(patternPartial) {\n    if (modalStyleguide.active[patternPartial] === undefined || !modalStyleguide.active[patternPartial]) {\n      var el = document.getElementById('pl-pattern-data-' + patternPartial);\n      modalStyleguide.collectAndSend(el, true, false);\n    } else {\n      modalStyleguide.highlightsHide();\n      modalStyleguide.close(patternPartial);\n    }\n  },\n\n  /**\n   * open the modal window for a view-all entry\n   * @param  {String}       the patternPartial that identifies what needs to be opened\n   * @param  {String}       the content that should be inserted\n   */\n  open: function open(patternPartial, content) {\n    // make sure templateRendered is modified to be an HTML element\n    var div = document.createElement('div');\n    div.innerHTML = content;\n    content = document.createElement('div').appendChild(div).querySelector('div'); // add click events\n\n    content = panels_util[\"panelsUtil\"].addClickEvents(content, patternPartial); // make sure the modal viewer and other options are off just in case\n    // modalStyleguide.close(patternPartial);\n    // note it's turned on in the viewer\n\n    modalStyleguide.active[patternPartial] = true; // make sure there's no content\n\n    div = document.getElementById('pl-pattern-extra-' + patternPartial);\n\n    if (div && div.childNodes) {\n      if (div.childNodes.length > 0) {\n        div.removeChild(div.childNodes[0]);\n      }\n    } // add the content\n\n\n    document.getElementById('pl-pattern-extra-' + patternPartial).appendChild(content); // show the modal\n\n    var toggle = document.getElementById('pl-pattern-extra-toggle-' + patternPartial);\n\n    if (toggle) {\n      toggle.classList.add('pl-is-active');\n    }\n\n    document.getElementById('pl-pattern-extra-' + patternPartial).classList.add('pl-is-active');\n  },\n\n  /**\n   * close the modal window for a view-all entry\n   * @param  {String}       the patternPartial that identifies what needs to be closed\n   */\n  close: function close(patternPartial) {\n    // note that the modal viewer is no longer active\n    modalStyleguide.active[patternPartial] = false; // hide the modal, look at info-panel.js\n\n    var toggle = document.getElementById('pl-pattern-extra-toggle-' + patternPartial);\n\n    if (toggle) {\n      toggle.classList.remove('pl-is-active');\n    }\n\n    if (document.getElementById('pl-pattern-extra-' + patternPartial)) {\n      document.getElementById('pl-pattern-extra-' + patternPartial).classList.remove('pl-is-active');\n    }\n  },\n\n  /**\n   * get the data that needs to be send to the viewer for rendering\n   * @param  {Element}      the identifier for the element that needs to be collected\n   * @param  {Boolean}      if the refresh is of a view-all view and the content should be sent back\n   * @param  {Boolean}      if the text in the dropdown should be switched\n   */\n  collectAndSend: function collectAndSend(el, iframePassback, switchText) {\n    /**\n     * Verify <script> tag has JSON data available (not just whitespace) - helps prevents JS errors from\n     * getting thrown when certain script tags aren't rendered with partial.patternData content.\n     */\n    if (/\\S/.test(el.innerHTML)) {\n      var patternData = JSON.parse(el.innerHTML);\n\n      if (patternData.patternName !== undefined) {\n        var patternMarkupEl = document.querySelector('#' + patternData.patternPartial + ' > .pl-js-pattern-example');\n        patternData.patternMarkup = patternMarkupEl !== null ? patternMarkupEl.innerHTML : document.querySelector('body').innerHTML;\n        modalStyleguide.patternQueryInfo(patternData, iframePassback, switchText);\n      }\n    } else {// @todo: how are we handling conditional logging for debugging based on the dev environment?\n      // console.log('This <script> tag\\'s JSON is empty for some reason...');\n    }\n  },\n\n  /**\n   * hide the annotation highlights\n   */\n  highlightsHide: function highlightsHide(patternPartial) {\n    var patternPartialSelector = patternPartial !== undefined ? '#' + patternPartial + ' > ' : '';\n    var elsToHide = document.querySelectorAll(patternPartialSelector + '.pl-has-annotation');\n\n    for (var i = 0; i < elsToHide.length; i++) {\n      elsToHide[i].classList.remove('pl-has-annotation');\n    }\n\n    elsToHide = document.querySelectorAll(patternPartialSelector + '.pl-c-annotation-tip');\n\n    for (var _i = 0; _i < elsToHide.length; _i++) {\n      elsToHide[_i].style.display = 'none';\n    }\n  },\n\n  /**\n   * return the pattern info to the top level\n   * @param  {Object}       the content that will be sent to the viewer for rendering\n   * @param  {Boolean}      if the refresh is of a view-all view and the content should be sent back\n   * @param  {Boolean}      if the text in the dropdown should be switched\n   */\n  patternQueryInfo: function patternQueryInfo(patternData, iframePassback, switchText) {\n    // send a message to the pattern\n    try {\n      var obj = JSON.stringify({\n        event: 'patternLab.patternQueryInfo',\n        patternData: patternData,\n        iframePassback: iframePassback,\n        switchText: switchText\n      });\n      window.parent.postMessage(obj, modalStyleguide.targetOrigin);\n    } catch (e) {// @todo: how do we want to handle exceptions here?\n    }\n  },\n\n  /**\n   * toggle the comment pop-up based on a user clicking on the pattern\n   * based on the great MDN docs at https://developer.mozilla.org/en-US/docs/Web/API/window.postMessage\n   * @param  {Object}      event info\n   */\n  receiveIframeMessage: function receiveIframeMessage(event) {\n    // does the origin sending the message match the current host? if not dev/null the request\n    if (window.location.protocol !== 'file:' && event.origin !== window.location.protocol + '//' + window.location.host) {\n      return;\n    }\n\n    var data = {};\n\n    try {\n      data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n    } catch (e) {} // @todo: how do we want to handle exceptions here?\n    // see if it got a path to replace\n\n\n    if (data.event !== undefined && data.event === 'patternLab.patternQuery') {\n      // find all elements related to pattern info\n      var els = document.querySelectorAll('.pl-js-pattern-data');\n      var iframePassback = els.length > 1; // send each up to the parent to be read and compiled into panels\n\n      for (var i = 0; i < els.length; i++) {\n        modalStyleguide.collectAndSend(els[i], iframePassback, data.switchText);\n      }\n    } else if (data.event !== undefined && data.event === 'patternLab.patternModalInsert') {\n      // insert the previously rendered content being passed from the iframe\n      modalStyleguide.open(data.patternPartial, data.modalContent);\n    } else if (data.event !== undefined && data.event === 'patternLab.annotationsHighlightShow') {\n      var elsToHighlight, item, span; // go over the supplied annotations\n\n      for (var _i2 = 0; _i2 < data.annotations.length; _i2++) {\n        item = data.annotations[_i2];\n        elsToHighlight = document.querySelectorAll(item.el);\n\n        if (elsToHighlight.length > 0) {\n          for (var j = 0; j < elsToHighlight.length; j++) {\n            elsToHighlight[j].classList.add('pl-has-annotation');\n            span = document.createElement('span');\n            span.innerHTML = item.displayNumber;\n            span.classList.add('pl-c-annotation-tip');\n\n            if (window.getComputedStyle(elsToHighlight[j], null).getPropertyValue('max-height') === '0px') {\n              span.style.display = 'none';\n            }\n\n            var annotationTip = document.querySelector(item.el + ' > span.pl-c-annotation-tip');\n\n            if (annotationTip === null) {\n              elsToHighlight[j].insertBefore(span, elsToHighlight[j].firstChild);\n            } else {\n              annotationTip.style.display = 'inline-flex';\n            }\n\n            elsToHighlight[j].onclick = function (el) {\n              return function (e) {\n                e.preventDefault();\n                e.stopPropagation();\n                var obj = JSON.stringify({\n                  event: 'patternLab.annotationNumberClicked',\n                  displayNumber: el.displayNumber\n                });\n                window.parent.postMessage(obj, modalStyleguide.targetOrigin);\n              };\n            }(item);\n          }\n        }\n      }\n    } else if (data.event !== undefined && data.event === 'patternLab.annotationsHighlightHide') {\n      modalStyleguide.highlightsHide();\n    } else if (data.event !== undefined && data.event === 'patternLab.patternModalClose') {\n      var keys = [];\n\n      for (var k in modalStyleguide.active) {\n        if (k) {\n          keys.push(k);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < keys.length; _i3++) {\n        var patternPartial = keys[_i3];\n\n        if (modalStyleguide.active[patternPartial]) {\n          modalStyleguide.close(patternPartial);\n        }\n      }\n    }\n  }\n}; // when the document is ready make sure the modal is ready\n\nmodalStyleguide.onReady();\nwindow.addEventListener('message', modalStyleguide.receiveIframeMessage, false);\n// EXTERNAL MODULE: ./node_modules/mousetrap/mousetrap.js\nvar mousetrap = __webpack_require__(\"./node_modules/mousetrap/mousetrap.js\");\nvar mousetrap_default = /*#__PURE__*/__webpack_require__.n(mousetrap);\n\n// EXTERNAL MODULE: ./src/scripts/utils/index.js + 9 modules\nvar utils = __webpack_require__(\"./src/scripts/utils/index.js\");\n\n// CONCATENATED MODULE: ./src/scripts/components/pl-search/pl-search.iframe-helper.js\n// Tiny helper script to listen for keyboard combos and to communicate back to the main Search component (via the Pattern Lab iframe)\n\n\nmousetrap_default.a.bind('command+shift+f', function (e) {\n  e.preventDefault();\n\n  try {\n    var obj = JSON.stringify({\n      event: 'patternLab.keyPress',\n      key: e.key,\n      altKey: e.altKey,\n      ctrlKey: e.ctrlKey,\n      metaKey: e.metaKey,\n      shiftKey: e.shiftKey\n    });\n    window.parent.postMessage(obj, utils[\"targetOrigin\"]);\n  } catch (error) {// @todo: how do we want to handle exceptions here?\n  }\n\n  return false;\n});\n// CONCATENATED MODULE: ./src/scripts/utils/share-inner-iframe-data.js\n // alert the iframe parent that the pattern has loaded assuming this view was loaded in an iframe\n\nif (window.self !== window.top) {\n  /**\n   * update the current page's drawer / code viewer\n   * @todo: refactor similarly to the new code block below\n   */\n  // handle the options that could be sent to the parent window\n  //   - all get path\n  //   - pattern & view all get a pattern partial, styleguide gets all\n  //   - pattern shares lineage\n  var path = window.location.toString();\n  var parts = path.split('?');\n  var options = {\n    event: 'patternLab.pageLoad',\n    path: parts[0],\n    details: {\n      patternData: window.patternData\n    }\n  };\n  options.patternpartial = window.patternData.patternPartial !== undefined ? window.patternData.patternPartial : 'all';\n\n  if (window.patternData.lineage !== '') {\n    options.lineage = window.patternData.lineage;\n  }\n\n  window.parent.postMessage(options, utils[\"targetOrigin\"]); // tell the parent page which pattern has just loaded\n\n  var currentPattern = {\n    pattern: window.patternData.patternPartial\n  };\n  var share_inner_iframe_data_event = new CustomEvent('patternPartial', {\n    detail: currentPattern\n  });\n  window.parent.document.dispatchEvent(share_inner_iframe_data_event);\n}\n// CONCATENATED MODULE: ./src/scripts/patternlab-pattern.js\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/scripts/patternlab-pattern.js_+_3_modules?")},"./src/scripts/utils/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/scripts/utils/postmessage.js\nvar postmessage = __webpack_require__(\"./src/scripts/utils/postmessage.js\");\n\n// CONCATENATED MODULE: ./src/scripts/utils/url-handler.js\n/*!\n * URL Handler\n *\n * Copyright (c) 2013-2014 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Helps handle the initial iFrame source. Parses a string to see if it matches\n * an expected pattern in Pattern Lab. Supports Pattern Lab's fuzzy pattern partial\n * matching style.\n *\n */\nvar urlHandler = {\n  // set-up some default vars\n  skipBack: false,\n  goBack: false,\n  iframeElement: document.querySelector('.pl-js-iframe'),\n  targetOrigin: window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host,\n\n  /**\n   * get the real file name for a given pattern name\n   * @param  {String}       the shorthand partials syntax for a given pattern\n   * @param  {Boolean}      with the file name should be returned with the full rendered suffix or not\n   *\n   * @return {String}       the real file path\n   */\n  getFileName: function getFileName(name, withRenderedSuffix) {\n    var baseDir = 'patterns';\n    var fileName = '';\n\n    if (name === undefined) {\n      return fileName;\n    }\n\n    if (withRenderedSuffix === undefined) {\n      withRenderedSuffix = true; // eslint-disable-line no-param-reassign\n    }\n\n    if (name === 'all') {\n      return 'styleguide/html/styleguide.html';\n    } else if (name === 'snapshots') {\n      return 'snapshots/index.html';\n    }\n\n    var paths = name.indexOf('viewall-') !== -1 ? window.viewAllPaths : window.patternPaths;\n    var nameClean = name.replace('viewall-', ''); // look at this as a regular pattern\n\n    var bits = this.getPatternInfo(nameClean, paths);\n    var patternType = bits[0];\n    var pattern = bits[1];\n\n    if (paths[patternType] !== undefined && paths[patternType][pattern] !== undefined) {\n      fileName = paths[patternType][pattern];\n    } else if (paths[patternType] !== undefined) {\n      for (var patternMatchKey in paths[patternType]) {\n        if (patternMatchKey.indexOf(pattern) !== -1) {\n          fileName = paths[patternType][patternMatchKey];\n          break;\n        }\n      }\n    }\n\n    if (fileName === '') {\n      return fileName;\n    }\n\n    var regex = /\\//g;\n\n    if (name.indexOf('viewall-') !== -1 && name.indexOf('viewall-') === 0 && fileName !== '') {\n      fileName = baseDir + '/' + fileName.replace(regex, '-') + '/index.html';\n    } else if (fileName !== '') {\n      fileName = baseDir + '/' + fileName.replace(regex, '-') + '/' + fileName.replace(regex, '-');\n\n      if (withRenderedSuffix) {\n        var fileSuffixRendered = window.config.outputFileSuffixes !== undefined && window.config.outputFileSuffixes.rendered !== undefined ? window.config.outputFileSuffixes.rendered : '';\n        fileName = fileName + fileSuffixRendered + '.html';\n      }\n    }\n\n    return fileName;\n  },\n\n  /**\n   * break up a pattern into its parts, pattern type and pattern name\n   * @param  {String}       the shorthand partials syntax for a given pattern\n   * @param  {Object}       the paths to be compared\n   *\n   * @return {Array}        the pattern type and pattern name\n   */\n  getPatternInfo: function getPatternInfo(name, paths) {\n    var patternBits = name.split('-');\n    var i = 1;\n    var c = patternBits.length;\n    var patternType = patternBits[0];\n\n    while (paths[patternType] === undefined && i < c) {\n      patternType += '-' + patternBits[i];\n      i++;\n    }\n\n    var pattern = name.slice(patternType.length + 1, name.length);\n    return [patternType, pattern];\n  },\n\n  /**\n   * search the request vars for a particular item\n   *\n   * @return {Object}       a search of the window.location.search vars\n   */\n  getRequestVars: function getRequestVars() {\n    // the following is taken from https://developer.mozilla.org/en-US/docs/Web/API/window.location\n    var oGetVars = new function (sSearch) {\n      if (sSearch.length > 1) {\n        for (var aItKey, nKeyId = 0, aCouples = sSearch.substr(1).split('&'); nKeyId < aCouples.length; nKeyId++) {\n          aItKey = aCouples[nKeyId].split('=');\n          this[unescape(aItKey[0])] = aItKey.length > 1 ? unescape(aItKey[1]) : '';\n        }\n      }\n    }(window.location.search);\n    return oGetVars;\n  },\n\n  /**\n   * push a pattern onto the current history based on a click\n   * @param  {String}       the shorthand partials syntax for a given pattern\n   * @param  {String}       the path given by the loaded iframe\n   */\n  pushPattern: function pushPattern(pattern, givenPath) {\n    var data = {\n      pattern: pattern\n    };\n    var fileName = urlHandler.getFileName(pattern);\n    var path = window.location.pathname;\n    path = window.location.protocol === 'file' ? path.replace('/public/index.html', 'public/') : path.replace(/\\/index\\.html/, '/');\n    var expectedPath = window.location.protocol + '//' + window.location.host + path + fileName;\n\n    if (givenPath !== expectedPath) {\n      // make sure to update the iframe because there was a click\n      var obj = JSON.stringify({\n        event: 'patternLab.updatePath',\n        path: fileName\n      });\n      document.querySelector('.pl-js-iframe').contentWindow.postMessage(obj, urlHandler.targetOrigin);\n    }\n  },\n\n  /**\n   * based on a click forward or backward modify the url and iframe source\n   * @param  {Object}      event info like state and properties set in pushState()\n   */\n  popPattern: function popPattern(e) {\n    var patternName;\n    var state = e.state;\n\n    if (state === null) {\n      this.skipBack = false;\n      return;\n    } else if (state !== null) {\n      patternName = state.currentPattern;\n    }\n\n    var iFramePath = '';\n    iFramePath = this.getFileName(patternName);\n\n    if (iFramePath === '') {\n      iFramePath = 'styleguide/html/styleguide.html'; // iFramePath = this.getFileName('components-overview'); // @todo: remove if this new approach isn't needed\n    }\n\n    var obj = JSON.stringify({\n      event: 'patternLab.updatePath',\n      path: iFramePath\n    });\n    document.querySelector('.pl-js-iframe').contentWindow.postMessage(obj, urlHandler.targetOrigin);\n  }\n};\n/**\n * handle the onpopstate event\n */\n\nwindow.onpopstate = function (event) {\n  urlHandler.skipBack = true;\n};\n// EXTERNAL MODULE: ./node_modules/wolfy87-eventemitter/EventEmitter.js\nvar EventEmitter = __webpack_require__(\"./node_modules/wolfy87-eventemitter/EventEmitter.js\");\nvar EventEmitter_default = /*#__PURE__*/__webpack_require__.n(EventEmitter);\n\n// CONCATENATED MODULE: ./src/scripts/utils/eventemitter.js\n\nvar Dispatcher = new EventEmitter_default.a();\n// CONCATENATED MODULE: ./src/scripts/utils/css.js\n// Utility function used for outputting correctly formatted CSS classes in JSX.\n// Ported over from https://github.com/wc-catalogue/blaze-elements/blob/master/packages/common/css.ts\nfunction css() {\n  var classes = [];\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  for (var _i = 0, _args = args; _i < _args.length; _i++) {\n    var arg = _args[_i];\n\n    if (arg) {\n      if (typeof arg === 'string') {\n        classes.push(arg);\n      } else {\n        for (var key in arg) {\n          if (arg[key]) {\n            classes.push(key);\n          }\n        }\n      }\n    }\n  }\n\n  return classes.join(' ');\n}\n// CONCATENATED MODULE: ./src/scripts/utils/extend.js\n/* eslint-disable guard-for-in */\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./src/scripts/utils/supports-shadow-dom.js\nfunction hasShadowDomSupport() {\n  if ('attachShadow' in Element.prototype && 'getRootNode' in Element.prototype || window.ShadyDOM) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar supportsShadowDom = hasShadowDomSupport();\n// CONCATENATED MODULE: ./src/scripts/utils/get-target-origin.js\nvar targetOrigin = window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host;\n// CONCATENATED MODULE: ./src/scripts/utils/pattern-name.js\n\nvar patternName = '';\n\nif (window.config) {\n  patternName = window.config.defaultPattern !== undefined && typeof window.config.defaultPattern === 'string' && window.config.defaultPattern.trim().length > 0 ? window.config.defaultPattern : 'all'; // get the request vars\n\n  var oGetVars = urlHandler.getRequestVars();\n\n  if (oGetVars.p !== undefined || oGetVars.pattern !== undefined) {\n    patternName = oGetVars.p !== undefined ? oGetVars.p : oGetVars.pattern;\n  }\n}\n\n\n// CONCATENATED MODULE: ./src/scripts/utils/viewport-sizes.js\nvar minWidth = 240;\nvar maxWidth = 2600;\n\nif (window.config !== undefined) {\n  //set minimum and maximum viewport based on confg\n  if (window.config.ishMinimum !== undefined) {\n    minWidth = parseInt(window.config.ishMinimum, 10); //Minimum Size for Viewport\n  }\n\n  if (window.config.ishMaximum !== undefined) {\n    maxWidth = parseInt(window.config.ishMaximum, 10); //Maxiumum Size for Viewport\n  } //alternatively, use the ishViewportRange object\n\n\n  if (window.config.ishViewportRange !== undefined) {\n    minWidth = window.config.ishViewportRange.s[0];\n    maxWidth = window.config.ishViewportRange.l[1];\n  } //if both are set, then let's use the larger one.\n\n\n  if (window.config.ishViewportRange && window.config.ishMaximum) {\n    var largeRange = parseInt(window.config.ishViewportRange.l[1], 10);\n    var ishMaximum = parseInt(window.config.ishMaximum, 10);\n    maxWidth = largeRange > ishMaximum ? largeRange : ishMaximum;\n  }\n}\n\nvar minViewportWidth = minWidth;\nvar maxViewportWidth = maxWidth;\n// CONCATENATED MODULE: ./src/scripts/utils/get-random.js\n/* Returns a random number between min and max */\nfunction getRandom(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n// CONCATENATED MODULE: ./src/scripts/utils/index.js\n/* concated harmony reexport postmessage */__webpack_require__.d(__webpack_exports__, \"postmessage\", function() { return postmessage[\"postmessage\"]; });\n/* concated harmony reexport urlHandler */__webpack_require__.d(__webpack_exports__, \"urlHandler\", function() { return urlHandler; });\n/* concated harmony reexport Dispatcher */__webpack_require__.d(__webpack_exports__, \"Dispatcher\", function() { return Dispatcher; });\n/* concated harmony reexport css */__webpack_require__.d(__webpack_exports__, \"css\", function() { return css; });\n/* concated harmony reexport extend */__webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* concated harmony reexport supportsShadowDom */__webpack_require__.d(__webpack_exports__, \"supportsShadowDom\", function() { return supportsShadowDom; });\n/* concated harmony reexport targetOrigin */__webpack_require__.d(__webpack_exports__, \"targetOrigin\", function() { return targetOrigin; });\n/* concated harmony reexport patternName */__webpack_require__.d(__webpack_exports__, \"patternName\", function() { return patternName; });\n/* concated harmony reexport minViewportWidth */__webpack_require__.d(__webpack_exports__, \"minViewportWidth\", function() { return minViewportWidth; });\n/* concated harmony reexport maxViewportWidth */__webpack_require__.d(__webpack_exports__, \"maxViewportWidth\", function() { return maxViewportWidth; });\n/* concated harmony reexport getRandom */__webpack_require__.d(__webpack_exports__, \"getRandom\", function() { return getRandom; });\n// Export Utilties + Helpers\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/scripts/utils/index.js_+_9_modules?")},"./src/scripts/utils/polyfills/custom-event-polyfill.js":function(module,exports){eval("// Remove and replace with https://github.com/krambuhl/custom-event-polyfill once this PR (https://github.com/krambuhl/custom-event-polyfill/pull/13) is merged in.\n// Polyfill for creating CustomEvents on IE9/10/11\n// code pulled from:\n// https://github.com/d4tocchini/customevent-polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\ntry {\n  var ce = new window.CustomEvent('test', {\n    cancelable: true\n  });\n  ce.preventDefault();\n\n  if (ce.defaultPrevented !== true) {\n    // IE has problems with .preventDefault() on custom events\n    // http://stackoverflow.com/questions/23349191\n    throw new Error('Could not prevent default');\n  }\n} catch (e) {\n  var CustomEvent = function CustomEvent(event, params) {\n    var evt, origPrevent;\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    origPrevent = evt.preventDefault;\n\n    evt.preventDefault = function () {\n      origPrevent.call(this);\n\n      try {\n        Object.defineProperty(this, 'defaultPrevented', {\n          get: function get() {\n            return true;\n          }\n        });\n      } catch (e) {\n        this.defaultPrevented = true;\n      }\n    };\n\n    return evt;\n  };\n\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent; // expose definition to window\n}\n\n//# sourceURL=webpack:///./src/scripts/utils/polyfills/custom-event-polyfill.js?")},"./src/scripts/utils/polyfills/symbol-polyfill.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var get_own_property_symbols_build_get_own_property_symbols_max_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-own-property-symbols/build/get-own-property-symbols.max.js */ "./node_modules/get-own-property-symbols/build/get-own-property-symbols.max.js");\n/* harmony import */ var get_own_property_symbols_build_get_own_property_symbols_max_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(get_own_property_symbols_build_get_own_property_symbols_max_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/* eslint-disable no-extend-native */\n// import polyfill for Symbol and Object.getOwnPropertySymbols\n // Fix issue in toString patch when compiled into strict mode via closure\n// https://github.com/es-shims/get-own-property-symbols/issues/16\n\nvar toString = Object.prototype.toString;\n\nObject.prototype.toString = function () {\n  if (this === undefined) {\n    return \'[object Undefined]\';\n  } else if (this === null) {\n    return \'[object Null]\';\n  } else {\n    return toString.call(this);\n  }\n}; // overwrite Object.keys to filter out symbols\n\n\nObject.keys = function (obj) {\n  return Object.getOwnPropertyNames(obj).filter(function (name) {\n    var prop = Object.getOwnPropertyDescriptor(obj, name);\n    return prop && prop.enumerable;\n  });\n}; // implement iterators for IE 11\n\n\nvar iterator = window.Symbol.iterator;\n\nif (!String.prototype[iterator] || !String.prototype.codePointAt) {\n  /** @this {String} */\n  String.prototype[iterator] =\n  /*#__PURE__*/\n  _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n    var i;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < this.length)) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 4;\n            return this[i];\n\n          case 4:\n            i++;\n            _context.next = 1;\n            break;\n\n          case 7:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  });\n}\n\nif (!Set.prototype[iterator]) {\n  /** @this {Set} */\n  Set.prototype[iterator] =\n  /*#__PURE__*/\n  _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {\n    var temp, i;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            temp = [];\n            this.forEach(function (value) {\n              temp.push(value);\n            });\n            i = 0;\n\n          case 3:\n            if (!(i < temp.length)) {\n              _context2.next = 9;\n              break;\n            }\n\n            _context2.next = 6;\n            return temp[i];\n\n          case 6:\n            i++;\n            _context2.next = 3;\n            break;\n\n          case 9:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  });\n}\n\nif (!Map.prototype[iterator]) {\n  /** @this {Map} */\n  Map.prototype[iterator] =\n  /*#__PURE__*/\n  _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3() {\n    var entries, i;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            entries = [];\n            this.forEach(function (value, key) {\n              entries.push([key, value]);\n            });\n            i = 0;\n\n          case 3:\n            if (!(i < entries.length)) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.next = 6;\n            return entries[i];\n\n          case 6:\n            i++;\n            _context3.next = 3;\n            break;\n\n          case 9:\n          case "end":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  });\n}\n\n//# sourceURL=webpack:///./src/scripts/utils/polyfills/symbol-polyfill.js?')},"./src/scripts/utils/postmessage.js":function(module,exports){eval("/*!\n * Basic postMessage Support\n *\n * Copyright (c) 2013-2016 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Handles the postMessage stuff in the pattern, view-all, and style guide templates.\n *\n */\nif (window.self !== window.top) {\n  // find all links and add an onclick handler for replacing the iframe address so the history works\n  var aTags = document.getElementsByTagName('a');\n\n  for (var i = 0; i < aTags.length; i++) {\n    aTags[i].onclick = function (e) {\n      var href = this.getAttribute('href');\n      var target = this.getAttribute('target');\n\n      if (target !== undefined && (target === '_parent' || target === '_blank')) {// just do normal stuff\n      } else if (href && href !== '#') {\n        e.preventDefault();\n        window.location.replace(href);\n      } else {\n        e.preventDefault();\n        return false;\n      }\n\n      return true;\n    };\n  }\n} // watch the iframe source so that it can be sent back to everyone else.\n\n\nfunction receiveIframeMessage(event) {\n  // does the origin sending the message match the current host? if not dev/null the request\n  if (window.location.protocol !== 'file:' && event.origin !== window.location.protocol + '//' + window.location.host) {\n    return;\n  }\n\n  var path;\n  var data = {};\n\n  try {\n    data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n  } catch (e) {// @todo: how do we want to handle exceptions like these?\n  }\n\n  if (data.event !== undefined && data.event === 'patternLab.updatePath') {\n    if (window.patternData.patternPartial !== undefined) {\n      // handle patterns and the view all page\n      var re = /(patterns|snapshots)\\/(.*)$/;\n      path = window.location.protocol + '//' + window.location.host + window.location.pathname.replace(re, '') + data.path + '?' + Date.now();\n      window.location.replace(path);\n    } else {\n      // handle the style guide\n      path = window.location.protocol + '//' + window.location.host + window.location.pathname.replace('styleguide/html/styleguide.html', '') + data.path + '?' + Date.now();\n      window.location.replace(path);\n    }\n  } else if (data.event !== undefined && data.event === 'patternLab.reload') {\n    // reload the location if there was a message to do so\n    window.location.reload();\n  }\n}\n\nwindow.addEventListener('message', receiveIframeMessage, false);\n\n//# sourceURL=webpack:///./src/scripts/utils/postmessage.js?")}});