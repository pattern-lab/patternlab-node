(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/@webcomponents/shadydom/src/shadydom.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@webcomponents/shadydom/src/shadydom.js + 28 modules ***!
  \***************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shady-data.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nvar ShadyData =\n/*#__PURE__*/\nfunction () {\n  function ShadyData() {\n    _classCallCheck(this, ShadyData);\n\n    /** @type {ShadowRoot} */\n    this.root = null;\n    /** @type {ShadowRoot} */\n\n    this.publicRoot = null;\n    this.dirty = false;\n    this.observer = null;\n    /** @type {Array<Node>} */\n\n    this.assignedNodes = null;\n    /** @type {Element} */\n\n    this.assignedSlot = null;\n    /** @type {Array<Node>} */\n\n    this._previouslyAssignedNodes = null;\n    /** @type {Element} */\n\n    this._prevAssignedSlot = null;\n    /** @type {Array<Node>} */\n\n    this.flattenedNodes = null;\n    this.ownerShadyRoot = undefined;\n    /** @type {Node|undefined} */\n\n    this.parentNode = undefined;\n    /** @type {Node|undefined} */\n\n    this.firstChild = undefined;\n    /** @type {Node|undefined} */\n\n    this.lastChild = undefined;\n    /** @type {Node|undefined} */\n\n    this.previousSibling = undefined;\n    /** @type {Node|undefined} */\n\n    this.nextSibling = undefined;\n    /** @type {Array<Node>|undefined} */\n\n    this.childNodes = undefined;\n    this.__outsideAccessors = false;\n    this.__insideAccessors = false;\n    this.__onCallbackListeners = {};\n  }\n  /** @override */\n\n\n  _createClass(ShadyData, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {};\n    }\n  }]);\n\n  return ShadyData;\n}();\nfunction ensureShadyDataForNode(node) {\n  if (!node.__shady) {\n    node.__shady = new ShadyData();\n  }\n\n  return node.__shady;\n}\nfunction shadyDataForNode(node) {\n  return node && node.__shady;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/utils.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/** @type {!Object} */\n\nvar settings = window['ShadyDOM'] || {};\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\nvar desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');\nsettings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);\nsettings.inUse = settings['force'] || !settings.hasNativeShadowDOM;\nsettings.noPatch = settings['noPatch'] || false;\nsettings.preferPerformance = settings['preferPerformance'];\nvar utils_isTrackingLogicalChildNodes = function isTrackingLogicalChildNodes(node) {\n  var nodeData = shadyDataForNode(node);\n  return nodeData && nodeData.firstChild !== undefined;\n};\nvar utils_isShadyRoot = function isShadyRoot(obj) {\n  return Boolean(obj._localName === 'ShadyRoot');\n};\nvar utils_hasShadowRootWithSlot = function hasShadowRootWithSlot(node) {\n  var nodeData = shadyDataForNode(node);\n  var root = nodeData && nodeData.root;\n  return root && root._hasInsertionPoint();\n};\nvar utils_p = Element.prototype;\nvar matches = utils_p.matches || utils_p.matchesSelector || utils_p.mozMatchesSelector || utils_p.msMatchesSelector || utils_p.oMatchesSelector || utils_p.webkitMatchesSelector;\nvar matchesSelector = function matchesSelector(element, selector) {\n  return matches.call(element, selector);\n};\nvar mixin = function mixin(target, source) {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n\n  return target;\n}; // NOTE, prefer MutationObserver over Promise for microtask timing\n// for consistency x-platform.\n\nvar twiddle = document.createTextNode('');\nvar utils_content = 0;\nvar queue = [];\nnew MutationObserver(function () {\n  while (queue.length) {\n    // catch errors in user code...\n    try {\n      queue.shift()();\n    } catch (e) {\n      // enqueue another record and throw\n      twiddle.textContent = utils_content++;\n      throw e;\n    }\n  }\n}).observe(twiddle, {\n  characterData: true\n}); // use MutationObserver to get microtask async timing.\n\nvar microtask = function microtask(callback) {\n  queue.push(callback);\n  twiddle.textContent = utils_content++;\n};\nvar hasDocumentContains = Boolean(document.contains);\nvar utils_contains = function contains(container, node) {\n  while (node) {\n    if (node == container) {\n      return true;\n    }\n\n    node = node[SHADY_PREFIX + 'parentNode'];\n  }\n\n  return false;\n};\n\nvar getNodeHTMLCollectionName = function getNodeHTMLCollectionName(node) {\n  return node.getAttribute('id') || node.getAttribute('name');\n};\n\nvar isValidHTMLCollectionName = function isValidHTMLCollectionName(name) {\n  return name !== 'length' && isNaN(name);\n};\n\nvar createPolyfilledHTMLCollection = function createPolyfilledHTMLCollection(nodes) {\n  // Note: loop in reverse so that the first named item matches the named property\n  for (var l = nodes.length - 1; l >= 0; l--) {\n    var node = nodes[l];\n    var name = getNodeHTMLCollectionName(node);\n\n    if (name && isValidHTMLCollectionName(name)) {\n      nodes[name] = node;\n    }\n  }\n\n  nodes.item = function (index) {\n    return nodes[index];\n  };\n\n  nodes.namedItem = function (name) {\n    if (isValidHTMLCollectionName(name) && nodes[name]) {\n      return nodes[name];\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _node = _step.value;\n        var nodeName = getNodeHTMLCollectionName(_node);\n\n        if (nodeName == name) {\n          return _node;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return nodes;\n};\nvar NATIVE_PREFIX = '__shady_native_';\nvar SHADY_PREFIX = '__shady_';\n/**\n * Patch a group of accessors on an object only if it exists or if the `force`\n * argument is true.\n * @param {!Object} proto\n * @param {!Object} descriptors\n * @param {string=} prefix\n * @param {Array=} disallowedPatches\n */\n\nvar patchProperties = function patchProperties(proto, descriptors) {\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var disallowedPatches = arguments.length > 3 ? arguments[3] : undefined;\n\n  for (var _p in descriptors) {\n    var newDescriptor = descriptors[_p];\n\n    if (disallowedPatches && disallowedPatches.indexOf(_p) >= 0) {\n      continue;\n    }\n\n    newDescriptor.configurable = true;\n    var name = prefix + _p; // NOTE: we prefer writing directly because some browsers\n    // have descriptors that are writable but not configurable (e.g.\n    // `appendChild` on older browsers)\n\n    if (newDescriptor.value) {\n      proto[name] = newDescriptor.value;\n    } else {\n      // NOTE: this can throw if 'force' is used so catch the error.\n      try {\n        Object.defineProperty(proto, name, newDescriptor);\n      } catch (e) {// this error is harmless so we just trap it.\n      }\n    }\n  }\n};\n/** @type {!function(new:HTMLElement)} */\n\nvar NativeHTMLElement = window['customElements'] && window['customElements']['nativeHTMLElement'] || HTMLElement; // note, this is not a perfect polyfill since it doesn't include symbols\n\n/** @return {!Object<!ObjectPropertyDescriptor>} */\n\nvar getOwnPropertyDescriptors = function getOwnPropertyDescriptors(obj) {\n  var descriptors = {};\n  Object.getOwnPropertyNames(obj).forEach(function (name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n  });\n  return descriptors;\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/flush.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n // render enqueuer/flusher\n\nvar flushList = [];\nvar scheduled;\nfunction enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    microtask(flush);\n  }\n\n  flushList.push(callback);\n}\nfunction flush() {\n  scheduled = false;\n  var didFlush = Boolean(flushList.length);\n\n  while (flushList.length) {\n    flushList.shift()();\n  }\n\n  return didFlush;\n}\nflush['list'] = flushList;\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/observe-changes.js\nfunction observe_changes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction observe_changes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction observe_changes_createClass(Constructor, protoProps, staticProps) { if (protoProps) observe_changes_defineProperties(Constructor.prototype, protoProps); if (staticProps) observe_changes_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar observe_changes_AsyncObserver =\n/*#__PURE__*/\nfunction () {\n  function AsyncObserver() {\n    observe_changes_classCallCheck(this, AsyncObserver);\n\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  observe_changes_createClass(AsyncObserver, [{\n    key: \"schedule\",\n    value: function schedule() {\n      var _this = this;\n\n      if (!this._scheduled) {\n        this._scheduled = true;\n        microtask(function () {\n          _this.flush();\n        });\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._scheduled) {\n        this._scheduled = false;\n        var mutations = this.takeRecords();\n\n        if (mutations.length) {\n          this.callbacks.forEach(function (cb) {\n            cb(mutations);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"takeRecords\",\n    value: function takeRecords() {\n      if (this.addedNodes.length || this.removedNodes.length) {\n        var mutations = [{\n          addedNodes: this.addedNodes,\n          removedNodes: this.removedNodes\n        }];\n        this.addedNodes = [];\n        this.removedNodes = [];\n        return mutations;\n      }\n\n      return [];\n    }\n  }]);\n\n  return AsyncObserver;\n}(); // TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\n\n\nvar observe_changes_observeChildren = function observeChildren(node, callback) {\n  var sd = ensureShadyDataForNode(node);\n\n  if (!sd.observer) {\n    sd.observer = new observe_changes_AsyncObserver();\n  }\n\n  sd.observer.callbacks.add(callback);\n  var observer = sd.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords: function takeRecords() {\n      return observer.takeRecords();\n    }\n  };\n};\nvar observe_changes_unobserveChildren = function unobserveChildren(handle) {\n  var observer = handle && handle._observer;\n\n  if (observer) {\n    observer.callbacks.delete(handle._callback);\n\n    if (!observer.callbacks.size) {\n      ensureShadyDataForNode(handle._node).observer = null;\n    }\n  }\n};\nfunction filterMutations(mutations, target) {\n  /** @const {Node} */\n  var targetRootNode = target.getRootNode();\n  return mutations.map(function (mutation) {\n    /** @const {boolean} */\n    var mutationInScope = targetRootNode === mutation.target.getRootNode();\n\n    if (mutationInScope && mutation.addedNodes) {\n      var nodes = Array.from(mutation.addedNodes).filter(function (n) {\n        return targetRootNode === n.getRootNode();\n      });\n\n      if (nodes.length) {\n        mutation = Object.create(mutation);\n        Object.defineProperty(mutation, 'addedNodes', {\n          value: nodes,\n          configurable: true\n        });\n        return mutation;\n      }\n    } else if (mutationInScope) {\n      return mutation;\n    }\n  }).filter(function (m) {\n    return m;\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/innerHTML.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n\n    case '<':\n      return '&lt;';\n\n    case '>':\n      return '&gt;';\n\n    case '\"':\n      return '&quot;';\n\n    case \"\\xA0\":\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  var set = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n\n  return set;\n} // http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\n\nvar voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\nvar plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @param {Function=} callback\n */\n\nfunction getOuterHTML(node, parentNode, callback) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      {\n        var tagName = node.localName;\n        var s = '<' + tagName;\n        var attrs = node.attributes;\n\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n\n        s += '>';\n\n        if (voidElements[tagName]) {\n          return s;\n        }\n\n        return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n      }\n\n    case Node.TEXT_NODE:\n      {\n        var data =\n        /** @type {Text} */\n        node.data;\n\n        if (parentNode && plaintextParents[parentNode.localName]) {\n          return data;\n        }\n\n        return escapeData(data);\n      }\n\n    case Node.COMMENT_NODE:\n      {\n        return '<!--' +\n        /** @type {Comment} */\n        node.data + '-->';\n      }\n\n    default:\n      {\n        window.console.error(node);\n        throw new Error('not implemented');\n      }\n  }\n}\n/**\n * @param {Node} node\n * @param {Function=} callback\n */\n\nfunction getInnerHTML(node, callback) {\n  if (node.localName === 'template') {\n    node =\n    /** @type {HTMLTemplateElement} */\n    node.content;\n  }\n\n  var s = '';\n  var c$ = callback ? callback(node) : node.childNodes;\n\n  for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\n    s += getOuterHTML(child, node, callback);\n  }\n\n  return s;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-native.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar hasDescriptors = settings.hasDescriptors;\nvar patch_native_NATIVE_PREFIX = NATIVE_PREFIX; // Object on which raw native methods are stored.\n// e.g. `nativeMethods.querySelector.call(node, selector)`\n// same as `node.querySelector(selector)`\n\nvar nativeMethods = {\n  /** @this {Element} */\n  querySelector: function querySelector(selector) {\n    return this[patch_native_NATIVE_PREFIX + 'querySelector'](selector);\n  },\n\n  /** @this {Element} */\n  querySelectorAll: function querySelectorAll(selector) {\n    return this[patch_native_NATIVE_PREFIX + 'querySelectorAll'](selector);\n  }\n}; // Object on which raw native accessors are available via `accessorName(node)`.\n// e.g. `nativeTree.firstChild(node)`\n// same as `node.firstChild`\n\nvar nativeTree = {};\n\nvar installNativeAccessor = function installNativeAccessor(name) {\n  nativeTree[name] = function (node) {\n    return node[patch_native_NATIVE_PREFIX + name];\n  };\n};\n\nvar installNativeMethod = function installNativeMethod(name, fn) {\n  if (!nativeMethods[name]) {\n    nativeMethods[name] = fn;\n  }\n};\n\nvar patch_native_defineNativeAccessors = function defineNativeAccessors(proto, descriptors) {\n  patchProperties(proto, descriptors, patch_native_NATIVE_PREFIX); // make native accessors available to users\n\n  for (var prop in descriptors) {\n    installNativeAccessor(prop);\n  }\n};\n\nvar copyProperties = function copyProperties(proto) {\n  var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  for (var i = 0; i < list.length; i++) {\n    var name = list[i];\n    var descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\n    if (descriptor) {\n      Object.defineProperty(proto, patch_native_NATIVE_PREFIX + name, descriptor); // make native methods/accessors available to users\n\n      if (descriptor.value) {\n        installNativeMethod(name, descriptor.value);\n      } else {\n        installNativeAccessor(name);\n      }\n    }\n  }\n};\n/** @type {!TreeWalker} */\n\n\nvar nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\n/** @type {!TreeWalker} */\n\nvar elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);\n/** @type {!Document} */\n\nvar inertDoc = document.implementation.createHTMLDocument('inert');\n\nvar clearNode = function clearNode(node) {\n  var firstChild;\n\n  while (firstChild = node[patch_native_NATIVE_PREFIX + 'firstChild']) {\n    node[patch_native_NATIVE_PREFIX + 'removeChild'](firstChild);\n  }\n};\n\nvar ParentNodeAccessors = ['firstElementChild', 'lastElementChild', 'children', 'childElementCount'];\nvar ParentNodeMethods = ['querySelector', 'querySelectorAll' // 'append', 'prepend'\n];\nvar patch_native_addNativePrefixedProperties = function addNativePrefixedProperties() {\n  // EventTarget\n  var eventProps = ['dispatchEvent', 'addEventListener', 'removeEventListener'];\n\n  if (window.EventTarget) {\n    copyProperties(window.EventTarget.prototype, eventProps);\n  } else {\n    copyProperties(Node.prototype, eventProps);\n    copyProperties(Window.prototype, eventProps);\n  } // Node\n\n\n  if (hasDescriptors) {\n    copyProperties(Node.prototype, ['parentNode', 'firstChild', 'lastChild', 'previousSibling', 'nextSibling', 'childNodes', 'parentElement', 'textContent']);\n  } else {\n    patch_native_defineNativeAccessors(Node.prototype, {\n      parentNode: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.parentNode();\n        }\n      },\n      firstChild: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.firstChild();\n        }\n      },\n      lastChild: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.lastChild();\n        }\n      },\n      previousSibling: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.previousSibling();\n        }\n      },\n      nextSibling: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.nextSibling();\n        }\n      },\n      // TODO(sorvell): make this a NodeList or whatever\n      childNodes: {\n        /** @this {Node} */\n        get: function get() {\n          var nodes = [];\n          nodeWalker.currentNode = this;\n          var n = nodeWalker.firstChild();\n\n          while (n) {\n            nodes.push(n);\n            n = nodeWalker.nextSibling();\n          }\n\n          return nodes;\n        }\n      },\n      parentElement: {\n        /** @this {Node} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.parentNode();\n        }\n      },\n      textContent: {\n        /** @this {Node} */\n        get: function get() {\n          /* eslint-disable no-case-declarations */\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              // TODO(sorvell): This cannot be a single TreeWalker that's reused\n              // at least for Safari 9, but it's unclear why.\n              var textWalker = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, false);\n              var content = '',\n                  n;\n\n              while (n = textWalker.nextNode()) {\n                // TODO(sorvell): can't use textContent since we patch it on Node.prototype!\n                // However, should probably patch it only on element.\n                content += n.nodeValue;\n              }\n\n              return content;\n\n            default:\n              return this.nodeValue;\n          }\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n\n        /** @this {Node} */\n        set: function set(value) {\n          if (typeof value === 'undefined' || value === null) {\n            value = '';\n          }\n\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              clearNode(this); // Document fragments must have no childnodes if setting a blank string\n\n              if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n                // Note: old Chrome versions require 2nd argument here\n                this[patch_native_NATIVE_PREFIX + 'insertBefore'](document.createTextNode(value), undefined);\n              }\n\n              break;\n\n            default:\n              // TODO(sorvell): can't do this if patch nodeValue.\n              this.nodeValue = value;\n              break;\n          }\n        }\n      }\n    });\n  }\n\n  copyProperties(Node.prototype, ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'cloneNode', 'contains']);\n  var ParentNodeWalkerDescriptors = {\n    firstElementChild: {\n      /** @this {ParentNode} */\n      get: function get() {\n        elementWalker.currentNode = this;\n        return elementWalker.firstChild();\n      }\n    },\n    lastElementChild: {\n      /** @this {ParentNode} */\n      get: function get() {\n        elementWalker.currentNode = this;\n        return elementWalker.lastChild();\n      }\n    },\n    children: {\n      /** @this {ParentNode} */\n      get: function get() {\n        var nodes = [];\n        elementWalker.currentNode = this;\n        var n = elementWalker.firstChild();\n\n        while (n) {\n          nodes.push(n);\n          n = elementWalker.nextSibling();\n        }\n\n        return createPolyfilledHTMLCollection(nodes);\n      }\n    },\n    childElementCount: {\n      /** @this {ParentNode} */\n      get: function get() {\n        if (this.children) {\n          return this.children.length;\n        }\n\n        return 0;\n      }\n    }\n  }; // Element\n\n  if (hasDescriptors) {\n    copyProperties(Element.prototype, ParentNodeAccessors);\n    copyProperties(Element.prototype, ['previousElementSibling', 'nextElementSibling', 'innerHTML']); // NOTE, on IE 11 / Edge 15 children and/or innerHTML are on HTMLElement instead of Element\n\n    if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'children')) {\n      copyProperties(HTMLElement.prototype, ['children']);\n    }\n\n    if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML')) {\n      copyProperties(HTMLElement.prototype, ['innerHTML']);\n    }\n  } else {\n    patch_native_defineNativeAccessors(Element.prototype, ParentNodeWalkerDescriptors);\n    patch_native_defineNativeAccessors(Element.prototype, {\n      previousElementSibling: {\n        /** @this {Element} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.previousSibling();\n        }\n      },\n      nextElementSibling: {\n        /** @this {Element} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.nextSibling();\n        }\n      },\n      innerHTML: {\n        /** @this {Element} */\n        get: function get() {\n          return getInnerHTML(this, function (n) {\n            return n[patch_native_NATIVE_PREFIX + 'childNodes'];\n          });\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n\n        /** @this {Element} */\n        set: function set(value) {\n          var content = this.localName === 'template' ?\n          /** @type {HTMLTemplateElement} */\n          this.content : this;\n          clearNode(content);\n          var containerName = this.localName || 'div';\n          var htmlContainer;\n\n          if (!this.namespaceURI || this.namespaceURI === inertDoc.namespaceURI) {\n            htmlContainer = inertDoc.createElement(containerName);\n          } else {\n            htmlContainer = inertDoc.createElementNS(this.namespaceURI, containerName);\n          }\n\n          htmlContainer.innerHTML = value;\n          var newContent = this.localName === 'template' ?\n          /** @type {HTMLTemplateElement} */\n          htmlContainer.content : htmlContainer;\n          var firstChild;\n\n          while (firstChild = newContent[patch_native_NATIVE_PREFIX + 'firstChild']) {\n            // Note: old Chrome versions require 2nd argument here\n            content[patch_native_NATIVE_PREFIX + 'insertBefore'](firstChild, undefined);\n          }\n        }\n      }\n    });\n  }\n\n  copyProperties(Element.prototype, ['setAttribute', 'getAttribute', 'hasAttribute', 'removeAttribute', // on older Safari, these are on Element.\n  'focus', 'blur']);\n  copyProperties(Element.prototype, ParentNodeMethods); // HTMLElement\n\n  copyProperties(HTMLElement.prototype, ['focus', 'blur', // On IE these are on HTMLElement\n  'contains']);\n\n  if (hasDescriptors) {\n    copyProperties(HTMLElement.prototype, ['parentElement', 'children', 'innerHTML']);\n  } // HTMLTemplateElement\n\n\n  if (window.HTMLTemplateElement) {\n    copyProperties(window.HTMLTemplateElement.prototype, ['innerHTML']);\n  } // DocumentFragment\n\n\n  if (hasDescriptors) {\n    // NOTE, IE 11 does not have on DocumentFragment\n    // firstElementChild\n    // lastElementChild\n    copyProperties(DocumentFragment.prototype, ParentNodeAccessors);\n  } else {\n    patch_native_defineNativeAccessors(DocumentFragment.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(DocumentFragment.prototype, ParentNodeMethods); // Document\n\n  if (hasDescriptors) {\n    copyProperties(Document.prototype, ParentNodeAccessors);\n    copyProperties(Document.prototype, ['activeElement']);\n  } else {\n    patch_native_defineNativeAccessors(Document.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(Document.prototype, ['importNode', 'getElementById']);\n  copyProperties(Document.prototype, ParentNodeMethods);\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-instances.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar InsideDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get childNodes() {\n    return this[SHADY_PREFIX + 'childNodes'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    return this[SHADY_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    return this[SHADY_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get textContent() {\n    return this[SHADY_PREFIX + 'textContent'];\n  },\n\n  /** @this {Node} */\n  set textContent(value) {\n    this[SHADY_PREFIX + 'textContent'] = value;\n  },\n\n  /** @this {Node} */\n  get childElementCount() {\n    return this[SHADY_PREFIX + 'childElementCount'];\n  },\n\n  /** @this {Node} */\n  get children() {\n    return this[SHADY_PREFIX + 'children'];\n  },\n\n  /** @this {Node} */\n  get firstElementChild() {\n    return this[SHADY_PREFIX + 'firstElementChild'];\n  },\n\n  /** @this {Node} */\n  get lastElementChild() {\n    return this[SHADY_PREFIX + 'lastElementChild'];\n  },\n\n  /** @this {Node} */\n  get innerHTML() {\n    return this[SHADY_PREFIX + 'innerHTML'];\n  },\n\n  /** @this {Node} */\n  set innerHTML(value) {\n    return this[SHADY_PREFIX + 'innerHTML'] = value;\n  },\n\n  /** @this {Node} */\n  get shadowRoot() {\n    return this[SHADY_PREFIX + 'shadowRoot'];\n  }\n\n});\nvar OutsideDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentElement() {\n    return this[SHADY_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get parentNode() {\n    return this[SHADY_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    return this[SHADY_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    return this[SHADY_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get nextElementSibling() {\n    return this[SHADY_PREFIX + 'nextElementSibling'];\n  },\n\n  /** @this {Node} */\n  get previousElementSibling() {\n    return this[SHADY_PREFIX + 'previousElementSibling'];\n  },\n\n  /** @this {Node} */\n  get className() {\n    return this[SHADY_PREFIX + 'className'];\n  },\n\n  /** @this {Node} */\n  set className(value) {\n    return this[SHADY_PREFIX + 'className'] = value;\n  }\n\n});\n\nfor (var patch_instances_prop in InsideDescriptors) {\n  InsideDescriptors[patch_instances_prop].enumerable = false;\n}\n\nfor (var _prop in OutsideDescriptors) {\n  OutsideDescriptors[_prop].enumerable = false;\n}\n\nvar noInstancePatching = settings.hasDescriptors || settings.noPatch; // ensure an element has patched \"outside\" accessors; no-op when not needed\n\nvar patchOutsideElementAccessors = noInstancePatching ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__outsideAccessors) {\n    sd.__outsideAccessors = true;\n    patchProperties(element, OutsideDescriptors);\n  }\n}; // ensure an element has patched \"inside\" accessors; no-op when not needed\n\nvar patchInsideElementAccessors = noInstancePatching ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__insideAccessors) {\n    sd.__insideAccessors = true;\n    patchProperties(element, InsideDescriptors);\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-events.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/*\nMake this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`\nhttps://github.com/webcomponents/shadydom/issues/173\n*/\n\nvar\n/** string */\neventWrappersName = \"__eventWrappers\".concat(Date.now());\n/** @type {?function(!Event): boolean} */\n\nvar composedGetter = function () {\n  var composedProp = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');\n  return composedProp ? function (ev) {\n    return composedProp.get.call(ev);\n  } : null;\n}(); // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\n\nvar alwaysComposed = {\n  'blur': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'click': true,\n  'dblclick': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'wheel': true,\n  'beforeinput': true,\n  'input': true,\n  'keydown': true,\n  'keyup': true,\n  'compositionstart': true,\n  'compositionupdate': true,\n  'compositionend': true,\n  'touchstart': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchcancel': true,\n  'pointerover': true,\n  'pointerenter': true,\n  'pointerdown': true,\n  'pointermove': true,\n  'pointerup': true,\n  'pointercancel': true,\n  'pointerout': true,\n  'pointerleave': true,\n  'gotpointercapture': true,\n  'lostpointercapture': true,\n  'dragstart': true,\n  'drag': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'drop': true,\n  'dragend': true,\n  'DOMActivate': true,\n  'DOMFocusIn': true,\n  'DOMFocusOut': true,\n  'keypress': true\n};\nvar unpatchedEvents = {\n  'DOMAttrModified': true,\n  'DOMAttributeNameChanged': true,\n  'DOMCharacterDataModified': true,\n  'DOMElementNameChanged': true,\n  'DOMNodeInserted': true,\n  'DOMNodeInsertedIntoDocument': true,\n  'DOMNodeRemoved': true,\n  'DOMNodeRemovedFromDocument': true,\n  'DOMSubtreeModified': true\n  /**\n   * Some EventTarget subclasses are not Node subclasses, and you cannot call\n   * `getRootNode()` on them.\n   *\n   * @param {!(Node|EventTarget)} eventTarget\n   * @return {!(Node|EventTarget)}\n   */\n\n};\n\nfunction getRootNodeWithFallback(eventTarget) {\n  if (eventTarget instanceof Node) {\n    return eventTarget[SHADY_PREFIX + 'getRootNode']();\n  } else {\n    return eventTarget;\n  }\n}\n\nfunction pathComposer(startNode, composed) {\n  var composedPath = [];\n  var current = startNode;\n  var startRoot = getRootNodeWithFallback(startNode);\n\n  while (current) {\n    composedPath.push(current);\n\n    if (current[SHADY_PREFIX + 'assignedSlot']) {\n      current = current[SHADY_PREFIX + 'assignedSlot'];\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n      current = current.host;\n    } else {\n      current = current[SHADY_PREFIX + 'parentNode'];\n    }\n  } // event composedPath includes window when startNode's ownerRoot is document\n\n\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n\n  return composedPath;\n}\n\nvar patch_events_composedPath = function composedPath(event) {\n  if (!event.__composedPath) {\n    event.__composedPath = pathComposer(event.target, true);\n  }\n\n  return event.__composedPath;\n};\n\nfunction retarget(refNode, path) {\n  if (!utils_isShadyRoot) {\n    return refNode;\n  } // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n\n\n  var refNodePath = pathComposer(refNode, true);\n  var p$ = path;\n\n  for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = getRootNodeWithFallback(ancestor);\n\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n\n    if (!utils_isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nvar EventPatches = {\n  /**\n   * @this {Event}\n   */\n  get composed() {\n    if (this.__composed === undefined) {\n      // if there's an original `composed` getter on the Event prototype, use that\n      if (composedGetter) {\n        // TODO(web-padawan): see https://github.com/webcomponents/shadydom/issues/275\n        this.__composed = this.type === 'focusin' || this.type === 'focusout' || composedGetter(this); // If the event is trusted, or `isTrusted` is not supported, check the list of always composed events\n      } else if (this.isTrusted !== false) {\n        this.__composed = alwaysComposed[this.type];\n      }\n    }\n\n    return (\n      /** @type {!Event} */\n      this.__composed || false\n    );\n  },\n\n  /**\n   * @this {Event}\n   */\n  composedPath: function composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this['__target'], this.composed);\n    }\n\n    return (\n      /** @type {!Event} */\n      this.__composedPath\n    );\n  },\n\n  /**\n   * @this {Event}\n   */\n  get target() {\n    return retarget(this.currentTarget || this['__previousCurrentTarget'], this.composedPath());\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\n  /**\n   * @this {Event}\n   */\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n    } // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\n\n    return retarget(this.currentTarget || this['__previousCurrentTarget'],\n    /** @type {!Event} */\n    this.__relatedTargetComposedPath);\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopPropagation: function stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  }\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  var klazz = function klazz(type, options) {\n    var event = new Base(type, options);\n    event.__composed = options && Boolean(options['composed']);\n    return event;\n  }; // put constructor properties on subclass\n\n\n  klazz.__proto__ = Base;\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nvar nonBubblingEventsToRetarget = {\n  'focus': true,\n  'blur': true\n};\n/**\n * Check if the event has been retargeted by comparing original `target`, and calculated `target`\n * @param {Event} event\n * @return {boolean} True if the original target and calculated target are the same\n */\n\nfunction hasRetargeted(event) {\n  return event['__target'] !== event.target || event.__relatedTarget !== event.relatedTarget;\n}\n/**\n *\n * @param {Event} event\n * @param {Node} node\n * @param {string} phase\n */\n\n\nfunction fireHandlers(event, node, phase) {\n  var hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];\n\n  if (hs) {\n    for (var i = 0, fn; fn = hs[i]; i++) {\n      if (hasRetargeted(event) && event.target === event.relatedTarget) {\n        return;\n      }\n\n      fn.call(node, event);\n\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction retargetNonBubblingEvent(e) {\n  var path = e.composedPath();\n  var node; // override `currentTarget` to let patched `target` calculate correctly\n\n  Object.defineProperty(e, 'currentTarget', {\n    get: function get() {\n      return node;\n    },\n    configurable: true\n  });\n\n  for (var i = path.length - 1; i >= 0; i--) {\n    node = path[i]; // capture phase fires all capture handlers\n\n    fireHandlers(e, node, 'capture');\n\n    if (e.__propagationStopped) {\n      return;\n    }\n  } // set the event phase to `AT_TARGET` as in spec\n\n\n  Object.defineProperty(e, 'eventPhase', {\n    get: function get() {\n      return Event.AT_TARGET;\n    }\n  }); // the event only needs to be fired when owner roots change when iterating the event path\n  // keep track of the last seen owner root\n\n  var lastFiredRoot;\n\n  for (var _i = 0; _i < path.length; _i++) {\n    node = path[_i];\n    var nodeData = shadyDataForNode(node);\n    var root = nodeData && nodeData.root;\n\n    if (_i === 0 || root && root === lastFiredRoot) {\n      fireHandlers(e, node, 'bubble'); // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\n      if (node !== window) {\n        lastFiredRoot = node[SHADY_PREFIX + 'getRootNode']();\n      }\n\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction listenerSettingsEqual(savedListener, node, type, capture, once, passive) {\n  var savedNode = savedListener.node,\n      savedType = savedListener.type,\n      savedCapture = savedListener.capture,\n      savedOnce = savedListener.once,\n      savedPassive = savedListener.passive;\n  return node === savedNode && type === savedType && capture === savedCapture && once === savedOnce && passive === savedPassive;\n}\n\nfunction findListener(wrappers, node, type, capture, once, passive) {\n  for (var i = 0; i < wrappers.length; i++) {\n    if (listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run\n * Try/Catch accessing eventWrappers to work around\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074\n */\n\nfunction getEventWrappers(eventLike) {\n  var wrappers = null;\n\n  try {\n    wrappers = eventLike[eventWrappersName];\n  } catch (e) {} // eslint-disable-line no-empty\n\n\n  return wrappers;\n}\n/**\n * @this {EventTarget}\n */\n\n\nfunction patch_events_addEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  var handlerType = _typeof(fnOrObj); // bail if `fnOrObj` is not a function, not an object\n\n\n  if (handlerType !== 'function' && handlerType !== 'object') {\n    return;\n  } // bail if `fnOrObj` is an object without a `handleEvent` method\n\n\n  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {\n    return;\n  }\n\n  if (unpatchedEvents[type]) {\n    return this[NATIVE_PREFIX + 'addEventListener'](type, fnOrObj, optionsOrCapture);\n  } // The callback `fn` might be used for multiple nodes/events. Since we generate\n  // a wrapper function, we need to keep track of it when we remove the listener.\n  // It's more efficient to store the node/type/options information as Array in\n  // `fn` itself rather than the node (we assume that the same callback is used\n  // for few nodes at most, whereas a node will likely have many event listeners).\n  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\n\n  var capture, once, passive;\n\n  if (optionsOrCapture && _typeof(optionsOrCapture) === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  } // hack to let ShadyRoots have event listeners\n  // event listener will be on host, but `currentTarget`\n  // will be set to shadyroot for event listener\n\n\n  var target = optionsOrCapture && optionsOrCapture.__shadyTarget || this;\n  var wrappers = fnOrObj[eventWrappersName];\n\n  if (wrappers) {\n    // Stop if the wrapper function has already been created.\n    if (findListener(wrappers, target, type, capture, once, passive) > -1) {\n      return;\n    }\n  } else {\n    fnOrObj[eventWrappersName] = [];\n  }\n  /**\n   * @this {HTMLElement}\n   * @param {Event} e\n   */\n\n\n  var wrapperFn = function wrapperFn(e) {\n    // Support `once` option.\n    if (once) {\n      this[SHADY_PREFIX + 'removeEventListener'](type, fnOrObj, optionsOrCapture);\n    }\n\n    if (!e['__target']) {\n      patchEvent(e);\n    }\n\n    var lastCurrentTargetDesc;\n\n    if (target !== this) {\n      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot\n      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(e, 'currentTarget');\n      Object.defineProperty(e, 'currentTarget', {\n        get: function get() {\n          return target;\n        },\n        configurable: true\n      });\n    }\n\n    e['__previousCurrentTarget'] = e['currentTarget']; // Always check if a shadowRoot is in the current event path.\n    // If it is not, the event was generated on either the host of the shadowRoot\n    // or a children of the host.\n\n    if (utils_isShadyRoot(target) && e.composedPath().indexOf(target) == -1) {\n      return;\n    } // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\n\n    if (e.composed || e.composedPath().indexOf(target) > -1) {\n      if (hasRetargeted(e) && e.target === e.relatedTarget) {\n        if (e.eventPhase === Event.BUBBLING_PHASE) {\n          e.stopImmediatePropagation();\n        }\n\n        return;\n      } // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase\n\n\n      if (e.eventPhase !== Event.CAPTURING_PHASE && !e.bubbles && e.target !== target && !(target instanceof Window)) {\n        return;\n      }\n\n      var ret = handlerType === 'function' ? fnOrObj.call(target, e) : fnOrObj.handleEvent && fnOrObj.handleEvent(e);\n\n      if (target !== this) {\n        // replace the \"correct\" `currentTarget`\n        if (lastCurrentTargetDesc) {\n          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);\n          lastCurrentTargetDesc = null;\n        } else {\n          delete e['currentTarget'];\n        }\n      }\n\n      return ret;\n    }\n  }; // Store the wrapper information.\n\n\n  fnOrObj[eventWrappersName].push({\n    // note: use target here which is either a shadowRoot\n    // (when the host element is proxy'ing the event) or this element\n    node: target,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn\n  });\n\n  if (nonBubblingEventsToRetarget[type]) {\n    this.__handlers = this.__handlers || {};\n    this.__handlers[type] = this.__handlers[type] || {\n      'capture': [],\n      'bubble': []\n    };\n\n    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n  } else {\n    this[NATIVE_PREFIX + 'addEventListener'](type, wrapperFn, optionsOrCapture);\n  }\n}\n/**\n * @this {EventTarget}\n */\n\nfunction patch_events_removeEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  if (unpatchedEvents[type]) {\n    return this[NATIVE_PREFIX + 'removeEventListener'](type, fnOrObj, optionsOrCapture);\n  } // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\n\n  var capture, once, passive;\n\n  if (optionsOrCapture && _typeof(optionsOrCapture) === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n\n  var target = optionsOrCapture && optionsOrCapture.__shadyTarget || this; // Search the wrapped function.\n\n  var wrapperFn = undefined;\n  var wrappers = getEventWrappers(fnOrObj);\n\n  if (wrappers) {\n    var idx = findListener(wrappers, target, type, capture, once, passive);\n\n    if (idx > -1) {\n      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn; // Cleanup.\n\n      if (!wrappers.length) {\n        fnOrObj[eventWrappersName] = undefined;\n      }\n    }\n  }\n\n  this[NATIVE_PREFIX + 'removeEventListener'](type, wrapperFn || fnOrObj, optionsOrCapture);\n\n  if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {\n    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\n    var _idx = arr.indexOf(wrapperFn);\n\n    if (_idx > -1) {\n      arr.splice(_idx, 1);\n    }\n  }\n}\n\nfunction activateFocusEventOverrides() {\n  for (var ev in nonBubblingEventsToRetarget) {\n    window[NATIVE_PREFIX + 'addEventListener'](ev, function (e) {\n      if (!e['__target']) {\n        patchEvent(e);\n        retargetNonBubblingEvent(e);\n      }\n    }, true);\n  }\n}\n\nvar EventPatchesDescriptors = getOwnPropertyDescriptors(EventPatches);\nvar SHADY_PROTO = '__shady_patchedProto';\nvar SHADY_SOURCE_PROTO = '__shady_sourceProto';\n\nfunction patchEvent(event) {\n  event['__target'] = event.target;\n  event.__relatedTarget = event.relatedTarget; // attempt to patch prototype (via cache)\n\n  if (settings.hasDescriptors) {\n    var proto = Object.getPrototypeOf(event);\n\n    if (!Object.hasOwnProperty(proto, SHADY_PROTO)) {\n      var patchedProto = Object.create(proto);\n      patchedProto[SHADY_SOURCE_PROTO] = proto;\n      patchProperties(patchedProto, EventPatchesDescriptors);\n      proto[SHADY_PROTO] = patchedProto;\n    }\n\n    event.__proto__ = proto[SHADY_PROTO]; // and fallback to patching instance\n  } else {\n    patchProperties(event, EventPatchesDescriptors);\n  }\n}\n\nvar PatchedEvent = mixinComposedFlag(Event);\nvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\nvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\nfunction patchEvents() {\n  activateFocusEventOverrides();\n  window.Event = PatchedEvent;\n  window.CustomEvent = PatchedCustomEvent;\n  window.MouseEvent = PatchedMouseEvent;\n}\nfunction patchClick() {\n  // Fix up `Element.prototype.click()` if `isTrusted` is supported, but `composed` isn't\n  if (!composedGetter && Object.getOwnPropertyDescriptor(Event.prototype, 'isTrusted')) {\n    /** @this {Element} */\n    var composedClickFn = function composedClickFn() {\n      var ev = new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      this[SHADY_PREFIX + 'dispatchEvent'](ev);\n    };\n\n    if (Element.prototype.click) {\n      Element.prototype.click = composedClickFn;\n    } else if (HTMLElement.prototype.click) {\n      HTMLElement.prototype.click = composedClickFn;\n    }\n  }\n}\nvar eventPropertyNames = Object.getOwnPropertyNames(Document.prototype).filter(function (name) {\n  return name.substring(0, 2) === 'on';\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/array-splice.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  var rowCount = oldEnd - oldStart + 1;\n  var columnCount = currentEnd - currentStart + 1;\n  var distances = new Array(rowCount); // \"Addition\" rows. Initialize null column.\n\n  for (var i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (var j = 0; j < columnCount; j++) {\n    distances[0][j] = j;\n  }\n\n  for (var _i = 1; _i < rowCount; _i++) {\n    for (var _j = 1; _j < columnCount; _j++) {\n      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {\n        var north = distances[_i - 1][_j] + 1;\n        var west = distances[_i][_j - 1] + 1;\n        distances[_i][_j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  var i = distances.length - 1;\n  var j = distances[0].length - 1;\n  var current = distances[i][j];\n  var edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    var northWest = distances[i - 1][j - 1];\n    var west = distances[i - 1][j];\n    var north = distances[i][j - 1];\n    var min = void 0;\n    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\n\n\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  var prefixCount = 0;\n  var suffixCount = 0;\n  var splice;\n  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n\n  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  splice = undefined;\n  var splices = [];\n  var index = currentStart;\n  var oldIndex = oldStart;\n\n  for (var i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (var i = 0; i < searchLength; i++) {\n    if (!equals(current[i], old[i])) return i;\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  var index1 = current.length;\n  var index2 = old.length;\n  var count = 0;\n\n  while (count < searchLength && equals(current[--index1], old[--index2])) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\nfunction calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/link-nodes.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\nfunction linkNode(node, container, ref_node) {\n  patchOutsideElementAccessors(node);\n  ref_node = ref_node || null;\n  var nodeData = ensureShadyDataForNode(node);\n  var containerData = ensureShadyDataForNode(container);\n  var ref_nodeData = ref_node ? ensureShadyDataForNode(ref_node) : null; // update ref_node.previousSibling <-> node\n\n  nodeData.previousSibling = ref_node ? ref_nodeData.previousSibling : container[SHADY_PREFIX + 'lastChild'];\n  var psd = shadyDataForNode(nodeData.previousSibling);\n\n  if (psd) {\n    psd.nextSibling = node;\n  } // update node <-> ref_node\n\n\n  var nsd = shadyDataForNode(nodeData.nextSibling = ref_node);\n\n  if (nsd) {\n    nsd.previousSibling = node;\n  } // update node <-> container\n\n\n  nodeData.parentNode = container;\n\n  if (ref_node) {\n    if (ref_node === containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } else {\n    containerData.lastChild = node;\n\n    if (!containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } // remove caching of childNodes\n\n\n  containerData.childNodes = null;\n}\n\nvar link_nodes_recordInsertBefore = function recordInsertBefore(node, container, ref_node) {\n  patchInsideElementAccessors(container);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (containerData.firstChild !== undefined) {\n    containerData.childNodes = null;\n  } // handle document fragments\n\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    var c$ = node[SHADY_PREFIX + 'childNodes'];\n\n    for (var i = 0; i < c$.length; i++) {\n      linkNode(c$[i], container, ref_node);\n    } // cleanup logical dom in doc fragment.\n\n\n    var nodeData = ensureShadyDataForNode(node);\n    var resetTo = nodeData.firstChild !== undefined ? null : undefined;\n    nodeData.firstChild = nodeData.lastChild = resetTo;\n    nodeData.childNodes = resetTo;\n  } else {\n    linkNode(node, container, ref_node);\n  }\n};\nvar link_nodes_recordRemoveChild = function recordRemoveChild(node, container) {\n  var nodeData = ensureShadyDataForNode(node);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (node === containerData.firstChild) {\n    containerData.firstChild = nodeData.nextSibling;\n  }\n\n  if (node === containerData.lastChild) {\n    containerData.lastChild = nodeData.previousSibling;\n  }\n\n  var p = nodeData.previousSibling;\n  var n = nodeData.nextSibling;\n\n  if (p) {\n    ensureShadyDataForNode(p).nextSibling = n;\n  }\n\n  if (n) {\n    ensureShadyDataForNode(n).previousSibling = p;\n  } // When an element is removed, logical data is no longer tracked.\n  // Explicitly set `undefined` here to indicate this. This is disginguished\n  // from `null` which is set if info is null.\n\n\n  nodeData.parentNode = nodeData.previousSibling = nodeData.nextSibling = undefined;\n\n  if (containerData.childNodes !== undefined) {\n    // remove caching of childNodes\n    containerData.childNodes = null;\n  }\n};\n/**\n * @param  {!Node} node\n */\n\nvar link_nodes_recordChildNodes = function recordChildNodes(node) {\n  var nodeData = ensureShadyDataForNode(node);\n\n  if (nodeData.firstChild === undefined) {\n    // remove caching of childNodes\n    nodeData.childNodes = null;\n    var first = nodeData.firstChild = node[NATIVE_PREFIX + 'firstChild'] || null;\n    nodeData.lastChild = node[NATIVE_PREFIX + 'lastChild'] || null;\n    patchInsideElementAccessors(node);\n\n    for (var n = first, previous; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n      var sd = ensureShadyDataForNode(n);\n      sd.parentNode = node;\n      sd.nextSibling = n[NATIVE_PREFIX + 'nextSibling'] || null;\n      sd.previousSibling = previous || null;\n      previous = n;\n      patchOutsideElementAccessors(n);\n    }\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/style-scoping.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar style_scoping_scopingShim = null;\nfunction getScopingShim() {\n  if (!style_scoping_scopingShim) {\n    style_scoping_scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];\n  }\n\n  return style_scoping_scopingShim || null;\n}\n/**\n * @param {!Node} node\n * @param {string} attr\n * @param {string} value\n */\n\nfunction scopeClassAttribute(node, attr, value) {\n  var scopingShim = getScopingShim();\n\n  if (scopingShim && attr === 'class') {\n    scopingShim['setElementClass'](node, value);\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n */\n\nfunction addShadyScoping(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['scopeNode'](node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} currentScopeName\n */\n\nfunction removeShadyScoping(node, currentScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['unscopeNode'](node, currentScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @param {string} oldScopeName\n */\n\nfunction replaceShadyScoping(node, newScopeName, oldScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  if (oldScopeName) {\n    removeShadyScoping(node, oldScopeName);\n  }\n\n  addShadyScoping(node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @return {boolean}\n */\n\nfunction currentScopeIsCorrect(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return true;\n  }\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // NOTE: as an optimization, only check that all the top-level children\n    // have the correct scope.\n    var correctScope = true;\n    var childNodes = node[SHADY_PREFIX + 'childNodes'];\n\n    for (var idx = 0; correctScope && idx < childNodes.length; idx++) {\n      correctScope = correctScope && currentScopeIsCorrect(childNodes[idx], newScopeName);\n    }\n\n    return correctScope;\n  }\n\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n\n  var currentScope = scopingShim['currentScopeForNode'](node);\n  return currentScope === newScopeName;\n}\n/**\n * @param {!Node} node\n * @return {string}\n */\n\nfunction currentScopeForNode(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return '';\n  }\n\n  return scopingShim['currentScopeForNode'](node);\n}\n/**\n * Walk over a node's tree and apply visitorFn to each element node\n *\n * @param {Node} node\n * @param {function(!Node):void} visitorFn\n */\n\nfunction treeVisitor(node, visitorFn) {\n  if (!node) {\n    return;\n  } // this check is necessary if `node` is a Document Fragment\n\n\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    visitorFn(node);\n  }\n\n  var childNodes = node[SHADY_PREFIX + 'childNodes'];\n\n  for (var idx = 0, n; idx < childNodes.length; idx++) {\n    n = childNodes[idx];\n\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      treeVisitor(n, visitorFn);\n    }\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Node.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\nvar doc = window.document;\nvar preferPerformance = settings.preferPerformance;\nvar nativeIsConnectedAccessors =\n/** @type {ObjectPropertyDescriptor} */\nObject.getOwnPropertyDescriptor(Node.prototype, 'isConnected');\nvar nativeIsConnected = nativeIsConnectedAccessors && nativeIsConnectedAccessors.get;\nfunction Node_clearNode(node) {\n  var firstChild;\n\n  while (firstChild = node[SHADY_PREFIX + 'firstChild']) {\n    node[SHADY_PREFIX + 'removeChild'](firstChild);\n  }\n}\n\nfunction removeOwnerShadyRoot(node) {\n  // optimization: only reset the tree if node is actually in a root\n  if (hasCachedOwnerRoot(node)) {\n    var c$ = node[SHADY_PREFIX + 'childNodes'];\n\n    for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {\n      removeOwnerShadyRoot(n);\n    }\n  }\n\n  var nodeData = shadyDataForNode(node);\n\n  if (nodeData) {\n    nodeData.ownerShadyRoot = undefined;\n  }\n}\n\nfunction hasCachedOwnerRoot(node) {\n  var nodeData = shadyDataForNode(node);\n  return Boolean(nodeData && nodeData.ownerShadyRoot !== undefined);\n}\n/**\n * Finds the first flattened node that is composed in the node's parent.\n * If the given node is a slot, then the first flattened node is returned\n * if it exists, otherwise advance to the node's nextSibling.\n * @param {Node} node within which to find first composed node\n * @returns {Node} first composed node\n */\n\n\nfunction firstComposedNode(node) {\n  var composed = node;\n\n  if (node && node.localName === 'slot') {\n    var nodeData = shadyDataForNode(node);\n    var flattened = nodeData && nodeData.flattenedNodes;\n    composed = flattened && flattened.length ? flattened[0] : firstComposedNode(node[SHADY_PREFIX + 'nextSibling']);\n  }\n\n  return composed;\n}\n/**\n * @param {Node} node\n * @param {Node=} addedNode\n * @param {Node=} removedNode\n */\n\n\nfunction scheduleObserver(node, addedNode, removedNode) {\n  var nodeData = shadyDataForNode(node);\n  var observer = nodeData && nodeData.observer;\n\n  if (observer) {\n    if (addedNode) {\n      observer.addedNodes.push(addedNode);\n    }\n\n    if (removedNode) {\n      observer.removedNodes.push(removedNode);\n    }\n\n    observer.schedule();\n  }\n}\n\nvar NodePatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentNode() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.parentNode;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.firstChild;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.lastChild;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.nextSibling;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.previousSibling;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get childNodes() {\n    var childNodes;\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var nodeData = shadyDataForNode(this);\n\n      if (!nodeData.childNodes) {\n        nodeData.childNodes = [];\n\n        for (var n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n          nodeData.childNodes.push(n);\n        }\n      }\n\n      childNodes = nodeData.childNodes;\n    } else {\n      childNodes = this[NATIVE_PREFIX + 'childNodes'];\n    }\n\n    childNodes.item = function (index) {\n      return childNodes[index];\n    };\n\n    return childNodes;\n  },\n\n  /** @this {Node} */\n  get parentElement() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.parentNode;\n\n    if (l && l.nodeType !== Node.ELEMENT_NODE) {\n      l = null;\n    }\n\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get isConnected() {\n    if (nativeIsConnected && nativeIsConnected.call(this)) {\n      return true;\n    }\n\n    if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n      return false;\n    } // Fast path for distributed nodes.\n\n\n    var ownerDocument = this.ownerDocument;\n\n    if (hasDocumentContains) {\n      if (ownerDocument[NATIVE_PREFIX + 'contains'](this)) {\n        return true;\n      }\n    } else if (ownerDocument.documentElement && ownerDocument.documentElement[NATIVE_PREFIX + 'contains'](this)) {\n      return true;\n    } // Slow path for non-distributed nodes.\n\n\n    var node = this;\n\n    while (node && !(node instanceof Document)) {\n      node = node[SHADY_PREFIX + 'parentNode'] || (utils_isShadyRoot(node) ?\n      /** @type {ShadowRoot} */\n      node.host : undefined);\n    }\n\n    return !!(node && node instanceof Document);\n  },\n\n  /** @this {Node} */\n  get textContent() {\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var tc = [];\n\n      for (var i = 0, cn = this[SHADY_PREFIX + 'childNodes'], c; c = cn[i]; i++) {\n        if (c.nodeType !== Node.COMMENT_NODE) {\n          tc.push(c[SHADY_PREFIX + 'textContent']);\n        }\n      }\n\n      return tc.join('');\n    } else {\n      return this[NATIVE_PREFIX + 'textContent'];\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {string} value\n   */\n  set textContent(value) {\n    if (typeof value === 'undefined' || value === null) {\n      value = '';\n    }\n\n    switch (this.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        if (!utils_isTrackingLogicalChildNodes(this) && settings.hasDescriptors) {\n          // may be removing a nested slot but fast path if we know we are not.\n          var firstChild = this[SHADY_PREFIX + 'firstChild'];\n\n          if (firstChild != this[SHADY_PREFIX + 'lastChild'] || firstChild && firstChild.nodeType != Node.TEXT_NODE) {\n            Node_clearNode(this);\n          }\n\n          this[NATIVE_PREFIX + 'textContent'] = value;\n        } else {\n          Node_clearNode(this); // Document fragments must have no childNodes if setting a blank string\n\n          if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n            this[SHADY_PREFIX + 'insertBefore'](document.createTextNode(value));\n          }\n        }\n\n        break;\n\n      default:\n        // Note, be wary of patching `nodeValue`.\n        this.nodeValue = value;\n        break;\n    }\n  },\n\n  // Patched `insertBefore`. Note that all mutations that add nodes are routed\n  // here. When a <slot> is added or a node is added to a host with a shadowRoot\n  // with a slot, a standard dom `insert` call is aborted and `_asyncRender`\n  // is called on the relevant shadowRoot. In all other cases, a standard dom\n  // `insert` can be made, but the location and ref_node may need to be changed.\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  insertBefore: function insertBefore(node, ref_node) {\n    // optimization: assume native insertBefore is ok if the nodes are not in the document.\n    if (this.ownerDocument !== doc && node.ownerDocument !== doc) {\n      this[NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      return node;\n    }\n\n    if (node === this) {\n      throw Error(\"Failed to execute 'appendChild' on 'Node': The new child element contains the parent.\");\n    }\n\n    if (ref_node) {\n      var refData = shadyDataForNode(ref_node);\n      var p = refData && refData.parentNode;\n\n      if (p !== undefined && p !== this || p === undefined && ref_node[NATIVE_PREFIX + 'parentNode'] !== this) {\n        throw Error(\"Failed to execute 'insertBefore' on 'Node': The node \" + \"before which the new node is to be inserted is not a child of this node.\");\n      }\n    }\n\n    if (ref_node === node) {\n      return node;\n    }\n    /** @type {!Array<!HTMLSlotElement>} */\n\n\n    var slotsAdded = [];\n    var ownerRoot = attach_shadow_ownerShadyRootForNode(this);\n    /** @type {string} */\n\n    var newScopeName = ownerRoot ? ownerRoot.host.localName : currentScopeForNode(this);\n    /** @type {string} */\n\n    var oldScopeName; // remove from existing location\n\n    var parentNode = node[SHADY_PREFIX + 'parentNode'];\n\n    if (parentNode) {\n      oldScopeName = currentScopeForNode(node);\n      parentNode[SHADY_PREFIX + 'removeChild'](node, Boolean(ownerRoot) || !attach_shadow_ownerShadyRootForNode(node));\n    } // add to new parent\n\n\n    var allowNativeInsert = true;\n    var needsScoping = (!preferPerformance || node['__noInsertionPoint'] === undefined) && !currentScopeIsCorrect(node, newScopeName);\n    var needsSlotFinding = ownerRoot && !node['__noInsertionPoint'] && (!preferPerformance || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\n    if (needsSlotFinding || needsScoping) {\n      // NOTE: avoid node.removeChild as this *can* trigger another patched\n      // method (e.g. custom elements) and we want only the shady method to run.\n      // The following table describes what style scoping actions should happen as a result of this insertion.\n      // document -> shadowRoot: replace\n      // shadowRoot -> shadowRoot: replace\n      // shadowRoot -> shadowRoot of same type: do nothing\n      // shadowRoot -> document: allow unscoping\n      // document -> document: do nothing\n      // The \"same type of shadowRoot\" and \"document to document cases rely on `currentScopeIsCorrect` returning true\n      if (needsScoping) {\n        // in a document or disconnected tree, replace scoping if necessary\n        oldScopeName = oldScopeName || currentScopeForNode(node);\n      }\n\n      treeVisitor(node, function (node) {\n        if (needsSlotFinding && node.localName === 'slot') {\n          slotsAdded.push(\n          /** @type {!HTMLSlotElement} */\n          node);\n        }\n\n        if (needsScoping) {\n          replaceShadyScoping(node, newScopeName, oldScopeName);\n        }\n      });\n    } // if a slot is added, must render containing root.\n\n\n    if (this.localName === 'slot' || slotsAdded.length) {\n      if (slotsAdded.length) {\n        ownerRoot._addSlots(slotsAdded);\n      }\n\n      if (ownerRoot) {\n        ownerRoot._asyncRender();\n      }\n    }\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      link_nodes_recordInsertBefore(node, this, ref_node); // when inserting into a host with a shadowRoot with slot, use\n      // `shadowRoot._asyncRender()` via `attach-shadow` module\n\n      var parentData = shadyDataForNode(this);\n\n      if (utils_hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n\n        allowNativeInsert = false; // when inserting into a host with shadowRoot with NO slot, do nothing\n        // as the node should not be added to composed dome anywhere.\n      } else if (parentData.root) {\n        allowNativeInsert = false;\n      }\n    }\n\n    if (allowNativeInsert) {\n      // if adding to a shadyRoot, add to host instead\n      var container = utils_isShadyRoot(this) ?\n      /** @type {ShadowRoot} */\n      this.host : this; // if ref_node, get the ref_node that's actually in composed dom.\n\n      if (ref_node) {\n        ref_node = firstComposedNode(ref_node);\n        container[NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      } else {\n        container[NATIVE_PREFIX + 'appendChild'](node);\n      } // Since ownerDocument is not patched, it can be incorrect after this call\n      // if the node is physically appended via distribution. This can result\n      // in the custom elements polyfill not upgrading the node if it's in an inert doc.\n      // We correct this by calling `adoptNode`.\n\n    } else if (node.ownerDocument !== this.ownerDocument) {\n      this.ownerDocument.adoptNode(node);\n    }\n\n    scheduleObserver(this, node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   */\n  appendChild: function appendChild(node) {\n    return this[SHADY_PREFIX + 'insertBefore'](node);\n  },\n\n  /**\n   * Patched `removeChild`. Note that all dom \"removals\" are routed here.\n   * Removes the given `node` from the element's `children`.\n   * This method also performs dom composition.\n   * @this {Node}\n   * @param {Node} node\n   * @param {boolean=} skipUnscoping\n   */\n  removeChild: function removeChild(node) {\n    var skipUnscoping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.ownerDocument !== doc) {\n      return this[NATIVE_PREFIX + 'removeChild'](node);\n    }\n\n    if (node[SHADY_PREFIX + 'parentNode'] !== this) {\n      throw Error('The node to be removed is not a child of this node: ' + node);\n    }\n\n    var preventNativeRemove;\n    var ownerRoot = attach_shadow_ownerShadyRootForNode(node);\n    var removingInsertionPoint;\n    var parentData = shadyDataForNode(this);\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      link_nodes_recordRemoveChild(node, this);\n\n      if (utils_hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n\n        preventNativeRemove = true;\n      }\n    } // unscope a node leaving a ShadowRoot if ShadyCSS is present, and this node\n    // is not going to be rescoped in `insertBefore`\n\n\n    if (getScopingShim() && !skipUnscoping && ownerRoot) {\n      var oldScopeName = currentScopeForNode(node);\n      treeVisitor(node, function (node) {\n        removeShadyScoping(node, oldScopeName);\n      });\n    }\n\n    removeOwnerShadyRoot(node); // if removing slot, must render containing root\n\n    if (ownerRoot) {\n      var changeSlotContent = this && this.localName === 'slot';\n\n      if (changeSlotContent) {\n        preventNativeRemove = true;\n      }\n\n      removingInsertionPoint = ownerRoot._removeContainedSlots(node);\n\n      if (removingInsertionPoint || changeSlotContent) {\n        ownerRoot._asyncRender();\n      }\n    }\n\n    if (!preventNativeRemove) {\n      // if removing from a shadyRoot, remove from host instead\n      var container = utils_isShadyRoot(this) ?\n      /** @type {ShadowRoot} */\n      this.host : this; // not guaranteed to physically be in container; e.g.\n      // (1) if parent has a shadyRoot, element may or may not at distributed\n      // location (could be undistributed)\n      // (2) if parent is a slot, element may not ben in composed dom\n\n      if (!(parentData.root || node.localName === 'slot') || container === node[NATIVE_PREFIX + 'parentNode']) {\n        container[NATIVE_PREFIX + 'removeChild'](node);\n      }\n    }\n\n    scheduleObserver(this, null, node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  replaceChild: function replaceChild(node, ref_node) {\n    this[SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    this[SHADY_PREFIX + 'removeChild'](ref_node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {boolean=} deep\n   */\n  cloneNode: function cloneNode(deep) {\n    if (this.localName == 'template') {\n      return this[NATIVE_PREFIX + 'cloneNode'](deep);\n    } else {\n      var n = this[NATIVE_PREFIX + 'cloneNode'](false); // Attribute nodes historically had childNodes, but they have later\n      // been removed from the spec.\n      // Make sure we do not do a deep clone on them for old browsers (IE11)\n\n      if (deep && n.nodeType !== Node.ATTRIBUTE_NODE) {\n        var c$ = this[SHADY_PREFIX + 'childNodes'];\n\n        for (var i = 0, nc; i < c$.length; i++) {\n          nc = c$[i][SHADY_PREFIX + 'cloneNode'](true);\n          n[SHADY_PREFIX + 'appendChild'](nc);\n        }\n      }\n\n      return n;\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {Object=} options\n   */\n  // TODO(sorvell): implement `options` e.g. `{ composed: boolean }`\n  getRootNode: function getRootNode(options) {\n    // eslint-disable-line no-unused-vars\n    if (!this || !this.nodeType) {\n      return;\n    }\n\n    var nodeData = ensureShadyDataForNode(this);\n    var root = nodeData.ownerShadyRoot;\n\n    if (root === undefined) {\n      if (utils_isShadyRoot(this)) {\n        root = this;\n        nodeData.ownerShadyRoot = root;\n      } else {\n        var parent = this[SHADY_PREFIX + 'parentNode'];\n        root = parent ? parent[SHADY_PREFIX + 'getRootNode'](options) : this; // memo-ize result for performance but only memo-ize\n        // result if node is in the document. This avoids a problem where a root\n        // can be cached while an element is inside a fragment.\n        // If this happens and we cache the result, the value can become stale\n        // because for perf we avoid processing the subtree of added fragments.\n\n        if (document.documentElement[NATIVE_PREFIX + 'contains'](this)) {\n          nodeData.ownerShadyRoot = root;\n        }\n      }\n    }\n\n    return root;\n  },\n\n  /** @this {Node} */\n  contains: function contains(node) {\n    return utils_contains(this, node);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ParentNode.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * @param {Node} node\n * @param {Function} matcher\n * @param {Function=} halter\n */\n\nfunction query(node, matcher, halter) {\n  var list = [];\n  queryElements(node[SHADY_PREFIX + 'childNodes'], matcher, halter, list);\n  return list;\n}\n\nfunction queryElements(elements, matcher, halter, list) {\n  for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {\n    if (c.nodeType === Node.ELEMENT_NODE && queryElement(c, matcher, halter, list)) {\n      return true;\n    }\n  }\n}\n\nfunction queryElement(node, matcher, halter, list) {\n  var result = matcher(node);\n\n  if (result) {\n    list.push(node);\n  }\n\n  if (halter && halter(result)) {\n    return result;\n  }\n\n  queryElements(node[SHADY_PREFIX + 'childNodes'], matcher, halter, list);\n} // Needed on Element, DocumentFragment, Document\n\n\nvar ParentNodePatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get firstElementChild() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.firstChild !== undefined) {\n      var n = this[SHADY_PREFIX + 'firstChild'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'nextSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'firstElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get lastElementChild() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.lastChild !== undefined) {\n      var n = this[SHADY_PREFIX + 'lastChild'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'previousSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'lastElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get children() {\n    if (!utils_isTrackingLogicalChildNodes(this)) {\n      return this[NATIVE_PREFIX + 'children'];\n    }\n\n    return createPolyfilledHTMLCollection(Array.prototype.filter.call(this[SHADY_PREFIX + 'childNodes'], function (n) {\n      return n.nodeType === Node.ELEMENT_NODE;\n    }));\n  },\n\n  /** @this {Element} */\n  get childElementCount() {\n    var children = this[SHADY_PREFIX + 'children'];\n\n    if (children) {\n      return children.length;\n    }\n\n    return 0;\n  }\n\n});\nvar QueryPatches = getOwnPropertyDescriptors({\n  // TODO(sorvell): consider doing native QSA and filtering results.\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   */\n  querySelector: function querySelector(selector) {\n    // match selector and halt on first result.\n    var result = query(this, function (n) {\n      return matchesSelector(n, selector);\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  },\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   * @param  {boolean} useNative\n   */\n  // TODO(sorvell): `useNative` option relies on native querySelectorAll and\n  // misses distributed nodes, see\n  // https://github.com/webcomponents/shadydom/pull/210#issuecomment-361435503\n  querySelectorAll: function querySelectorAll(selector, useNative) {\n    if (useNative) {\n      var o = Array.prototype.slice.call(this[NATIVE_PREFIX + 'querySelectorAll'](selector));\n      var root = this[SHADY_PREFIX + 'getRootNode']();\n      return o.filter(function (e) {\n        return e[SHADY_PREFIX + 'getRootNode']() == root;\n      });\n    }\n\n    return query(this, function (n) {\n      return matchesSelector(n, selector);\n    });\n  }\n}); // Create a custom `ParentNodeDocumentOrFragment` that optionally does not\n// mixin querySelector/All; this is a performance optimization.\n\nvar ParentNodeDocumentOrFragmentPatches = settings.preferPerformance ? Object.assign({}, ParentNodePatches) : ParentNodePatches;\nObject.assign(ParentNodePatches, QueryPatches);\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrFragment.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar DocumentOrFragmentPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {Element}\n   * @param {string} id\n   */\n  getElementById: function getElementById(id) {\n    if (id === '') {\n      return null;\n    }\n\n    var result = query(this, function (n) {\n      return n.id == id;\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrShadowRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nfunction getDocumentActiveElement() {\n  if (settings.hasDescriptors) {\n    return document[NATIVE_PREFIX + 'activeElement'];\n  } else {\n    return document.activeElement;\n  }\n}\n\nvar DocumentOrShadowRootPatches = getOwnPropertyDescriptors({\n  /** @this {Document|ShadowRoot} */\n  get activeElement() {\n    var active = getDocumentActiveElement(); // In IE11, activeElement might be an empty object if the document is\n    // contained in an iframe.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/\n\n    if (!active || !active.nodeType) {\n      return null;\n    }\n\n    var isShadyRoot = !!utils_isShadyRoot(this);\n\n    if (this !== document) {\n      // If this node isn't a document or shady root, then it doesn't have\n      // an active element.\n      if (!isShadyRoot) {\n        return null;\n      } // If this shady root's host is the active element or the active\n      // element is not a descendant of the host (in the composed tree),\n      // then it doesn't have an active element.\n\n\n      if (this.host === active || !this.host[NATIVE_PREFIX + 'contains'](active)) {\n        return null;\n      }\n    } // This node is either the document or a shady root of which the active\n    // element is a (composed) descendant of its host; iterate upwards to\n    // find the active element's most shallow host within it.\n\n\n    var activeRoot = attach_shadow_ownerShadyRootForNode(active);\n\n    while (activeRoot && activeRoot !== this) {\n      active = activeRoot.host;\n      activeRoot = attach_shadow_ownerShadyRootForNode(active);\n    }\n\n    if (this === document) {\n      // This node is the document, so activeRoot should be null.\n      return activeRoot ? null : active;\n    } else {\n      // This node is a non-document shady root, and it should be\n      // activeRoot.\n      return activeRoot === this ? active : null;\n    }\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ElementOrShadowRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/** @type {!Document} */\n\nvar ElementOrShadowRoot_inertDoc = document.implementation.createHTMLDocument('inert');\nvar ElementOrShadowRootPatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get innerHTML() {\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var content = this.localName === 'template' ?\n      /** @type {HTMLTemplateElement} */\n      this.content : this;\n      return getInnerHTML(content, function (e) {\n        return e[SHADY_PREFIX + 'childNodes'];\n      });\n    } else {\n      return this[NATIVE_PREFIX + 'innerHTML'];\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set innerHTML(value) {\n    if (this.localName === 'template') {\n      this[NATIVE_PREFIX + 'innerHTML'] = value;\n    } else {\n      Node_clearNode(this);\n      var containerName = this.localName || 'div';\n      var htmlContainer;\n\n      if (!this.namespaceURI || this.namespaceURI === ElementOrShadowRoot_inertDoc.namespaceURI) {\n        htmlContainer = ElementOrShadowRoot_inertDoc.createElement(containerName);\n      } else {\n        htmlContainer = ElementOrShadowRoot_inertDoc.createElementNS(this.namespaceURI, containerName);\n      }\n\n      if (settings.hasDescriptors) {\n        htmlContainer[NATIVE_PREFIX + 'innerHTML'] = value;\n      } else {\n        htmlContainer.innerHTML = value;\n      }\n\n      var firstChild;\n\n      while (firstChild = htmlContainer[SHADY_PREFIX + 'firstChild']) {\n        this[SHADY_PREFIX + 'insertBefore'](firstChild);\n      }\n    }\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ShadowRoot.js\nfunction ShadowRoot_typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { ShadowRoot_typeof = function _typeof(obj) { return typeof obj; }; } else { ShadowRoot_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return ShadowRoot_typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar ShadowRootPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener: function addEventListener(type, fn, optionsOrCapture) {\n    if (ShadowRoot_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    }\n\n    optionsOrCapture.__shadyTarget = this;\n    this.host[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);\n  },\n\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener: function removeEventListener(type, fn, optionsOrCapture) {\n    if (ShadowRoot_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    }\n\n    optionsOrCapture.__shadyTarget = this;\n    this.host[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-shadyRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n/**\n * @param {!Object} proto\n * @param {string=} prefix\n */\n\nvar patch_shadyRoot_patchShadyAccessors = function patchShadyAccessors(proto, prefix) {\n  patchProperties(proto, ShadowRootPatches, prefix);\n  patchProperties(proto, DocumentOrShadowRootPatches, prefix);\n  patchProperties(proto, ElementOrShadowRootPatches, prefix); // We ensure ParentNode accessors since these do not exist in Edge/IE on DocumentFragments.\n\n  patchProperties(proto, ParentNodePatches, prefix); // Ensure `shadowRoot` has basic descriptors when we cannot rely\n  // on them coming from DocumentFragment.\n  //\n  // Case 1, noPatching: Because we want noPatch ShadyRoots to have native property\n  // names so that they do not have to be wrapped...\n  // When we do *not* patch Node/DocumentFragment.prototype\n  // we must manually install those properties on ShadyRoot's prototype.\n  // Note, it's important to only install these in this mode so as not to stomp\n  // over CustomElements polyfill's patches on Node/DocumentFragment methods.\n\n  if (settings.noPatch && !prefix) {\n    patchProperties(proto, NodePatches, prefix);\n    patchProperties(proto, DocumentOrFragmentPatches, prefix); // Case 2, bad descriptors: Ensure accessors are on ShadowRoot.\n    // These descriptors are normally used for instance patching but because\n    // ShadyRoot can always be patched, just do it to the prototype.\n  } else if (!settings.hasDescriptors) {\n    patchProperties(proto, OutsideDescriptors);\n    patchProperties(proto, InsideDescriptors);\n  }\n};\n\nvar patch_shadyRoot_patchShadyRoot = function patchShadyRoot(proto) {\n  proto.__proto__ = DocumentFragment.prototype; // patch both prefixed and not, even when noPatch == true.\n\n  patch_shadyRoot_patchShadyAccessors(proto, SHADY_PREFIX);\n  patch_shadyRoot_patchShadyAccessors(proto); // Ensure native properties are all safely wrapped since ShadowRoot is not an\n  // actual DocumentFragment instance.\n\n  Object.defineProperties(proto, {\n    nodeType: {\n      value: Node.DOCUMENT_FRAGMENT_NODE,\n      configurable: true\n    },\n    nodeName: {\n      value: '#document-fragment',\n      configurable: true\n    },\n    nodeValue: {\n      value: null,\n      configurable: true\n    }\n  }); // make undefined\n\n  ['localName', 'namespaceURI', 'prefix'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      value: undefined,\n      configurable: true\n    });\n  }); // defer properties to host\n\n  ['ownerDocument', 'baseURI', 'isConnected'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      /** @this {ShadowRoot} */\n      get: function get() {\n        return this.host[prop];\n      },\n      configurable: true\n    });\n  });\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/attach-shadow.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction attach_shadow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction attach_shadow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction attach_shadow_createClass(Constructor, protoProps, staticProps) { if (protoProps) attach_shadow_defineProperties(Constructor.prototype, protoProps); if (staticProps) attach_shadow_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n // Do not export this object. It must be passed as the first argument to the\n// ShadyRoot constructor in `attachShadow` to prevent the constructor from\n// throwing. This prevents the user from being able to manually construct a\n// ShadyRoot (i.e. `new ShadowRoot()`).\n\nvar ShadyRootConstructionToken = {};\nvar CATCHALL_NAME = '__catchall';\nvar SHADYROOT_NAME = 'ShadyRoot';\nvar MODE_CLOSED = 'closed';\nvar isRendering = settings['deferConnectionCallbacks'] && document.readyState === 'loading';\nvar rootRendered;\n\nfunction ancestorList(node) {\n  var ancestors = [];\n\n  do {\n    ancestors.unshift(node);\n  } while (node = node[SHADY_PREFIX + 'parentNode']);\n\n  return ancestors;\n}\n/**\n * @extends {ShadowRoot}\n */\n\n\nvar attach_shadow_ShadyRoot =\n/*#__PURE__*/\nfunction () {\n  function ShadyRoot(token, host, options) {\n    attach_shadow_classCallCheck(this, ShadyRoot);\n\n    if (token !== ShadyRootConstructionToken) {\n      throw new TypeError('Illegal constructor');\n    } // NOTE: set a fake local name so this element can be\n    // distinguished from a DocumentFragment when patching.\n    // FF doesn't allow this to be `localName`\n\n\n    this._localName = SHADYROOT_NAME; // root <=> host\n\n    this.host = host;\n    /** @type {!string|undefined} */\n\n    this.mode = options && options.mode;\n    link_nodes_recordChildNodes(host);\n    var hostData = ensureShadyDataForNode(host);\n    /** @type {!ShadyRoot} */\n\n    hostData.root = this;\n    hostData.publicRoot = this.mode !== MODE_CLOSED ? this : null; // setup root\n\n    var rootData = ensureShadyDataForNode(this);\n    rootData.firstChild = rootData.lastChild = rootData.parentNode = rootData.nextSibling = rootData.previousSibling = null;\n    rootData.childNodes = []; // state flags\n\n    this._renderPending = false;\n    this._hasRendered = false; // marsalled lazily\n\n    this._slotList = null;\n    /** @type {Object<string, Array<HTMLSlotElement>>} */\n\n    this._slotMap = null;\n    this._pendingSlots = null; // NOTE: optimization flag, only require an asynchronous render\n    // to record parsed children if flag is not set.\n\n    if (settings['preferPerformance']) {\n      var n;\n\n      while (n = host[NATIVE_PREFIX + 'firstChild']) {\n        host[NATIVE_PREFIX + 'removeChild'](n);\n      }\n    } else {\n      this._asyncRender();\n    }\n  }\n\n  attach_shadow_createClass(ShadyRoot, [{\n    key: \"_asyncRender\",\n    value: function _asyncRender() {\n      var _this = this;\n\n      if (!this._renderPending) {\n        this._renderPending = true;\n        enqueue(function () {\n          return _this._render();\n        });\n      }\n    } // returns the oldest renderPending ancestor root.\n\n  }, {\n    key: \"_getRenderRoot\",\n    value: function _getRenderRoot() {\n      var renderRoot;\n      var root = this;\n\n      while (root) {\n        if (root._renderPending) {\n          renderRoot = root;\n        }\n\n        root = root._rendererForHost();\n      }\n\n      return renderRoot;\n    } // Returns the shadyRoot `this.host` if `this.host`\n    // has children that require distribution.\n\n  }, {\n    key: \"_rendererForHost\",\n    value: function _rendererForHost() {\n      var root = this.host[SHADY_PREFIX + 'getRootNode']();\n\n      if (utils_isShadyRoot(root)) {\n        var c$ = this.host[SHADY_PREFIX + 'childNodes'];\n\n        for (var i = 0, c; i < c$.length; i++) {\n          c = c$[i];\n\n          if (this._isInsertionPoint(c)) {\n            return root;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      var root = this._getRenderRoot();\n\n      if (root) {\n        root._renderRoot();\n      }\n    } // renders if render is pending.\n\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      var root = this._getRenderRoot();\n\n      if (root && root._renderPending) {\n        root._renderRoot();\n      }\n    }\n    /** @override */\n\n  }, {\n    key: \"_renderRoot\",\n    value: function _renderRoot() {\n      // track rendering state.\n      var wasRendering = isRendering;\n      isRendering = true;\n      this._renderPending = false;\n\n      if (this._slotList) {\n        this._distribute();\n\n        this._compose();\n      } // NOTE: optimization flag, only process parsed children\n      // if optimization flag is not set.\n      // on initial render remove any undistributed children.\n\n\n      if (!settings['preferPerformance'] && !this._hasRendered) {\n        var c$ = this.host[SHADY_PREFIX + 'childNodes'];\n\n        for (var i = 0, l = c$.length; i < l; i++) {\n          var child = c$[i];\n          var data = shadyDataForNode(child);\n\n          if (child[NATIVE_PREFIX + 'parentNode'] === this.host && (child.localName === 'slot' || !data.assignedSlot)) {\n            this.host[NATIVE_PREFIX + 'removeChild'](child);\n          }\n        }\n      }\n\n      this._hasRendered = true;\n      isRendering = wasRendering;\n\n      if (rootRendered) {\n        rootRendered();\n      }\n    }\n  }, {\n    key: \"_distribute\",\n    value: function _distribute() {\n      this._validateSlots(); // capture # of previously assigned nodes to help determine if dirty.\n\n\n      for (var i = 0, slot; i < this._slotList.length; i++) {\n        slot = this._slotList[i];\n\n        this._clearSlotAssignedNodes(slot);\n      } // distribute host children.\n\n\n      for (var n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        this._distributeNodeToSlot(n);\n      } // fallback content, slotchange, and dirty roots\n\n\n      for (var _i = 0; _i < this._slotList.length; _i++) {\n        var _slot = this._slotList[_i];\n        var slotData = shadyDataForNode(_slot); // distribute fallback content\n\n        if (!slotData.assignedNodes.length) {\n          for (var _n = _slot[SHADY_PREFIX + 'firstChild']; _n; _n = _n[SHADY_PREFIX + 'nextSibling']) {\n            this._distributeNodeToSlot(_n, _slot);\n          }\n        }\n\n        var slotParentData = shadyDataForNode(_slot[SHADY_PREFIX + 'parentNode']);\n        var slotParentRoot = slotParentData && slotParentData.root;\n\n        if (slotParentRoot && (slotParentRoot._hasInsertionPoint() || slotParentRoot._renderPending)) {\n          slotParentRoot._renderRoot();\n        }\n\n        this._addAssignedToFlattenedNodes(slotData.flattenedNodes, slotData.assignedNodes);\n\n        var prevAssignedNodes = slotData._previouslyAssignedNodes;\n\n        if (prevAssignedNodes) {\n          for (var _i2 = 0; _i2 < prevAssignedNodes.length; _i2++) {\n            shadyDataForNode(prevAssignedNodes[_i2])._prevAssignedSlot = null;\n          }\n\n          slotData._previouslyAssignedNodes = null; // dirty if previously less assigned nodes than previously assigned.\n\n          if (prevAssignedNodes.length > slotData.assignedNodes.length) {\n            slotData.dirty = true;\n          }\n        }\n        /* Note: A slot is marked dirty whenever a node is newly assigned to it\n        or a node is assigned to a different slot (done in `_distributeNodeToSlot`)\n        or if the number of nodes assigned to the slot has decreased (done above);\n        */\n\n\n        if (slotData.dirty) {\n          slotData.dirty = false;\n\n          this._fireSlotChange(_slot);\n        }\n      }\n    }\n    /**\n     * Distributes given `node` to the appropriate slot based on its `slot`\n     * attribute. If `forcedSlot` is given, then the node is distributed to the\n     * `forcedSlot`.\n     * Note: slot to which the node is assigned will be marked dirty for firing\n     * `slotchange`.\n     * @param {Node} node\n     * @param {Node=} forcedSlot\n     *\n     */\n\n  }, {\n    key: \"_distributeNodeToSlot\",\n    value: function _distributeNodeToSlot(node, forcedSlot) {\n      var nodeData = ensureShadyDataForNode(node);\n      var oldSlot = nodeData._prevAssignedSlot;\n      nodeData._prevAssignedSlot = null;\n      var slot = forcedSlot;\n\n      if (!slot) {\n        var name = node[SHADY_PREFIX + 'slot'] || CATCHALL_NAME;\n        var list = this._slotMap[name];\n        slot = list && list[0];\n      }\n\n      if (slot) {\n        var slotData = ensureShadyDataForNode(slot);\n        slotData.assignedNodes.push(node);\n        nodeData.assignedSlot = slot;\n      } else {\n        nodeData.assignedSlot = undefined;\n      }\n\n      if (oldSlot !== nodeData.assignedSlot) {\n        if (nodeData.assignedSlot) {\n          ensureShadyDataForNode(nodeData.assignedSlot).dirty = true;\n        }\n      }\n    }\n    /**\n     * Clears the assignedNodes tracking data for a given `slot`. Note, the current\n     * assigned node data is tracked (via _previouslyAssignedNodes and\n     * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out\n     *  of date at this time because the assigned nodes may have already been\n     * distributed to another root. This is ok since this data is only used to\n     * track changes.\n     * @param {HTMLSlotElement} slot\n     */\n\n  }, {\n    key: \"_clearSlotAssignedNodes\",\n    value: function _clearSlotAssignedNodes(slot) {\n      var slotData = shadyDataForNode(slot);\n      var n$ = slotData.assignedNodes;\n      slotData.assignedNodes = [];\n      slotData.flattenedNodes = [];\n      slotData._previouslyAssignedNodes = n$;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var n = shadyDataForNode(n$[i]);\n          n._prevAssignedSlot = n.assignedSlot; // only clear if it was previously set to this slot;\n          // this helps ensure that if the node has otherwise been distributed\n          // ignore it.\n\n          if (n.assignedSlot === slot) {\n            n.assignedSlot = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addAssignedToFlattenedNodes\",\n    value: function _addAssignedToFlattenedNodes(flattened, assigned) {\n      for (var i = 0, n; i < assigned.length && (n = assigned[i]); i++) {\n        if (n.localName == 'slot') {\n          var nestedAssigned = shadyDataForNode(n).assignedNodes;\n\n          if (nestedAssigned && nestedAssigned.length) {\n            this._addAssignedToFlattenedNodes(flattened, nestedAssigned);\n          }\n        } else {\n          flattened.push(assigned[i]);\n        }\n      }\n    }\n  }, {\n    key: \"_fireSlotChange\",\n    value: function _fireSlotChange(slot) {\n      // NOTE: cannot bubble correctly here so not setting bubbles: true\n      // Safari tech preview does not bubble but chrome does\n      // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n      slot[NATIVE_PREFIX + 'dispatchEvent'](new Event('slotchange'));\n      var slotData = shadyDataForNode(slot);\n\n      if (slotData.assignedSlot) {\n        this._fireSlotChange(slotData.assignedSlot);\n      }\n    } // Reify dom such that it is at its correct rendering position\n    // based on logical distribution.\n    // NOTE: here we only compose parents of <slot> elements and not the\n    // shadowRoot into the host. The latter is performend via a fast path\n    // in the `logical-mutation`.insertBefore.\n\n  }, {\n    key: \"_compose\",\n    value: function _compose() {\n      var slots = this._slotList;\n      var composeList = [];\n\n      for (var i = 0; i < slots.length; i++) {\n        var parent = slots[i][SHADY_PREFIX + 'parentNode'];\n        /* compose node only if:\n          (1) parent does not have a shadowRoot since shadowRoot has already\n          composed into the host\n          (2) we're not already composing it\n          [consider (n^2) but rare better than Set]\n        */\n\n        var parentData = shadyDataForNode(parent);\n\n        if (!(parentData && parentData.root) && composeList.indexOf(parent) < 0) {\n          composeList.push(parent);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < composeList.length; _i3++) {\n        var node = composeList[_i3];\n        var targetNode = node === this ? this.host : node;\n\n        this._updateChildNodes(targetNode, this._composeNode(node));\n      }\n    } // Returns the list of nodes which should be rendered inside `node`.\n\n  }, {\n    key: \"_composeNode\",\n    value: function _composeNode(node) {\n      var children = [];\n      var c$ = node[SHADY_PREFIX + 'childNodes'];\n\n      for (var i = 0; i < c$.length; i++) {\n        var child = c$[i]; // Note: if we see a slot here, the nodes are guaranteed to need to be\n        // composed here. This is because if there is redistribution, it has\n        // already been handled by this point.\n\n        if (this._isInsertionPoint(child)) {\n          var flattenedNodes = shadyDataForNode(child).flattenedNodes;\n\n          for (var j = 0; j < flattenedNodes.length; j++) {\n            var distributedNode = flattenedNodes[j];\n            children.push(distributedNode);\n          }\n        } else {\n          children.push(child);\n        }\n      }\n\n      return children;\n    }\n  }, {\n    key: \"_isInsertionPoint\",\n    value: function _isInsertionPoint(node) {\n      return node.localName == 'slot';\n    } // Ensures that the rendered node list inside `container` is `children`.\n\n  }, {\n    key: \"_updateChildNodes\",\n    value: function _updateChildNodes(container, children) {\n      var composed = Array.prototype.slice.call(container[NATIVE_PREFIX + 'childNodes']);\n      var splices = calculateSplices(children, composed); // process removals\n\n      for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\n        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n          // check if the node is still where we expect it is before trying\n          // to remove it; this can happen if we move a node and\n          // then schedule its previous host for distribution resulting in\n          // the node being removed here.\n          if (n[NATIVE_PREFIX + 'parentNode'] === container) {\n            container[NATIVE_PREFIX + 'removeChild'](n);\n          } // TODO(sorvell): avoid the need for splicing here.\n\n\n          composed.splice(s.index + d, 1);\n        }\n\n        d -= s.addedCount;\n      } // process adds\n\n\n      for (var _i4 = 0, _s, next; _i4 < splices.length && (_s = splices[_i4]); _i4++) {\n        //eslint-disable-line no-redeclare\n        next = composed[_s.index];\n\n        for (var _j = _s.index, _n2; _j < _s.index + _s.addedCount; _j++) {\n          _n2 = children[_j];\n          container[NATIVE_PREFIX + 'insertBefore'](_n2, next);\n          composed.splice(_j, 0, _n2);\n        }\n      }\n    }\n  }, {\n    key: \"_ensureSlotData\",\n    value: function _ensureSlotData() {\n      this._pendingSlots = this._pendingSlots || [];\n      this._slotList = this._slotList || [];\n      this._slotMap = this._slotMap || {};\n    }\n  }, {\n    key: \"_addSlots\",\n    value: function _addSlots(slots) {\n      var _this$_pendingSlots;\n\n      this._ensureSlotData();\n\n      (_this$_pendingSlots = this._pendingSlots).push.apply(_this$_pendingSlots, _toConsumableArray(slots));\n    }\n  }, {\n    key: \"_validateSlots\",\n    value: function _validateSlots() {\n      if (this._pendingSlots && this._pendingSlots.length) {\n        this._mapSlots(this._pendingSlots);\n\n        this._pendingSlots = [];\n      }\n    }\n    /**\n     * Adds the given slots. Slots are maintained in an dom-ordered list.\n     * In addition a map of name to slot is updated.\n     */\n\n  }, {\n    key: \"_mapSlots\",\n    value: function _mapSlots(slots) {\n      var slotNamesToSort;\n\n      for (var i = 0; i < slots.length; i++) {\n        var slot = slots[i]; // ensure insertionPoints's and their parents have logical dom info.\n        // save logical tree info\n        // a. for shadyRoot\n        // b. for insertion points (fallback)\n        // c. for parents of insertion points\n\n        link_nodes_recordChildNodes(slot);\n        link_nodes_recordChildNodes(slot[SHADY_PREFIX + 'parentNode']);\n\n        var name = this._nameForSlot(slot);\n\n        if (this._slotMap[name]) {\n          slotNamesToSort = slotNamesToSort || {};\n          slotNamesToSort[name] = true;\n\n          this._slotMap[name].push(slot);\n        } else {\n          this._slotMap[name] = [slot];\n        }\n\n        this._slotList.push(slot);\n      }\n\n      if (slotNamesToSort) {\n        for (var n in slotNamesToSort) {\n          this._slotMap[n] = this._sortSlots(this._slotMap[n]);\n        }\n      }\n    }\n  }, {\n    key: \"_nameForSlot\",\n    value: function _nameForSlot(slot) {\n      var name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;\n      slot.__slotName = name;\n      return name;\n    }\n    /**\n     * Slots are kept in an ordered list. Slots with the same name\n     * are sorted here by tree order.\n     */\n\n  }, {\n    key: \"_sortSlots\",\n    value: function _sortSlots(slots) {\n      // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,\n      // but the code here could be used to polyfill the preceeding/following info\n      // in `compareDocumentPosition`.\n      return slots.sort(function (a, b) {\n        var listA = ancestorList(a);\n        var listB = ancestorList(b);\n\n        for (var i = 0; i < listA.length; i++) {\n          var nA = listA[i];\n          var nB = listB[i];\n\n          if (nA !== nB) {\n            var c$ = Array.from(nA[SHADY_PREFIX + 'parentNode'][SHADY_PREFIX + 'childNodes']);\n            return c$.indexOf(nA) - c$.indexOf(nB);\n          }\n        }\n      });\n    }\n    /**\n     * Removes from tracked slot data any slots contained within `container` and\n     * then updates the tracked data (_slotList and _slotMap).\n     * Any removed slots also have their `assignedNodes` removed from comopsed dom.\n     */\n\n  }, {\n    key: \"_removeContainedSlots\",\n    value: function _removeContainedSlots(container) {\n      if (!this._slotList) {\n        return;\n      }\n\n      this._validateSlots();\n\n      var didRemove;\n      var map = this._slotMap;\n\n      for (var n in map) {\n        var slots = map[n];\n\n        for (var i = 0; i < slots.length; i++) {\n          var slot = slots[i];\n\n          if (utils_contains(container, slot)) {\n            slots.splice(i, 1);\n\n            var x = this._slotList.indexOf(slot);\n\n            if (x >= 0) {\n              this._slotList.splice(x, 1);\n            }\n\n            i--;\n\n            this._removeFlattenedNodes(slot);\n\n            didRemove = true;\n          }\n        }\n      }\n\n      return didRemove;\n    }\n  }, {\n    key: \"_updateSlotName\",\n    value: function _updateSlotName(slot) {\n      if (!this._slotList) {\n        return;\n      } // make sure slotMap is initialized with this slot\n\n\n      this._validateSlots();\n\n      var oldName = slot.__slotName;\n\n      var name = this._nameForSlot(slot);\n\n      if (name === oldName) {\n        return;\n      } // remove from existing tracking\n\n\n      var slots = this._slotMap[oldName];\n      var i = slots.indexOf(slot);\n\n      if (i >= 0) {\n        slots.splice(i, 1);\n      } // add to new location and sort if nedessary\n\n\n      var list = this._slotMap[name] || (this._slotMap[name] = []);\n      list.push(slot);\n\n      if (list.length > 1) {\n        this._slotMap[name] = this._sortSlots(list);\n      }\n    }\n  }, {\n    key: \"_removeFlattenedNodes\",\n    value: function _removeFlattenedNodes(slot) {\n      var data = shadyDataForNode(slot);\n      var n$ = data.flattenedNodes;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var node = n$[i];\n          var parent = node[NATIVE_PREFIX + 'parentNode'];\n\n          if (parent) {\n            parent[NATIVE_PREFIX + 'removeChild'](node);\n          }\n        }\n      }\n\n      data.flattenedNodes = [];\n      data.assignedNodes = [];\n    }\n  }, {\n    key: \"_hasInsertionPoint\",\n    value: function _hasInsertionPoint() {\n      this._validateSlots();\n\n      return Boolean(this._slotList && this._slotList.length);\n    }\n  }]);\n\n  return ShadyRoot;\n}();\n\npatch_shadyRoot_patchShadyRoot(attach_shadow_ShadyRoot.prototype);\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\n\nvar attach_shadow_attachShadow = function attachShadow(host, options) {\n  if (!host) {\n    throw new Error('Must provide a host.');\n  }\n\n  if (!options) {\n    throw new Error('Not enough arguments.');\n  }\n\n  return new attach_shadow_ShadyRoot(ShadyRootConstructionToken, host, options);\n}; // Mitigate connect/disconnect spam by wrapping custom element classes.\n\nif (window['customElements'] && settings.inUse && !settings['preferPerformance']) {\n  // process connect/disconnect after roots have rendered to avoid\n  // issues with reaction stack.\n  var connectMap = new Map();\n\n  rootRendered = function rootRendered() {\n    // allow elements to connect\n    // save map state (without needing polyfills on IE11)\n    var r = [];\n    connectMap.forEach(function (v, k) {\n      r.push([k, v]);\n    });\n    connectMap.clear();\n\n    for (var i = 0; i < r.length; i++) {\n      var e = r[i][0],\n          value = r[i][1];\n\n      if (value) {\n        e.__shadydom_connectedCallback();\n      } else {\n        e.__shadydom_disconnectedCallback();\n      }\n    }\n  }; // Document is in loading state and flag is set (deferConnectionCallbacks)\n  // so process connection stack when `readystatechange` fires.\n\n\n  if (isRendering) {\n    document.addEventListener('readystatechange', function () {\n      isRendering = false;\n      rootRendered();\n    }, {\n      once: true\n    });\n  }\n  /*\n   * (1) elements can only be connected/disconnected if they are in the expected\n   * state.\n   * (2) never run connect/disconnect during rendering to avoid reaction stack issues.\n   */\n\n\n  var ManageConnect = function ManageConnect(base, connected, disconnected) {\n    var counter = 0;\n    var connectFlag = \"__isConnected\".concat(counter++);\n\n    if (connected || disconnected) {\n      /** @this {!HTMLElement} */\n      base.prototype.connectedCallback = base.prototype.__shadydom_connectedCallback = function () {\n        // if rendering defer connected\n        // otherwise connect only if we haven't already\n        if (isRendering) {\n          connectMap.set(this, true);\n        } else if (!this[connectFlag]) {\n          this[connectFlag] = true;\n\n          if (connected) {\n            connected.call(this);\n          }\n        }\n      };\n      /** @this {!HTMLElement} */\n\n\n      base.prototype.disconnectedCallback = base.prototype.__shadydom_disconnectedCallback = function () {\n        // if rendering, cancel a pending connection and queue disconnect,\n        // otherwise disconnect only if a connection has been allowed\n        if (isRendering) {\n          // This is necessary only because calling removeChild\n          // on a node that requires distribution leaves it in the DOM tree\n          // until distribution.\n          // NOTE: remember this is checking the patched isConnected to determine\n          // if the node is in the logical tree.\n          if (!this.isConnected) {\n            connectMap.set(this, false);\n          }\n        } else if (this[connectFlag]) {\n          this[connectFlag] = false;\n\n          if (disconnected) {\n            disconnected.call(this);\n          }\n        }\n      };\n    }\n\n    return base;\n  };\n\n  var define = window['customElements']['define']; // NOTE: Instead of patching customElements.define,\n  // re-define on the CustomElementRegistry.prototype.define\n  // for Safari 10 compatibility (it's flakey otherwise).\n\n  Object.defineProperty(window['CustomElementRegistry'].prototype, 'define', {\n    value: function value(name, constructor) {\n      var connected = constructor.prototype.connectedCallback;\n      var disconnected = constructor.prototype.disconnectedCallback;\n      define.call(window['customElements'], name, ManageConnect(constructor, connected, disconnected)); // unpatch connected/disconnected on class; custom elements tears this off\n      // so the patch is maintained, but if the user calls these methods for\n      // e.g. testing, they will be as expected.\n\n      constructor.prototype.connectedCallback = connected;\n      constructor.prototype.disconnectedCallback = disconnected;\n    }\n  });\n}\n/** @return {!ShadyRoot|undefined} */\n\n\nvar attach_shadow_ownerShadyRootForNode = function ownerShadyRootForNode(node) {\n  var root = node[SHADY_PREFIX + 'getRootNode']();\n\n  if (utils_isShadyRoot(root)) {\n    return root;\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/wrapper.js\nfunction wrapper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction wrapper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction wrapper_createClass(Constructor, protoProps, staticProps) { if (protoProps) wrapper_defineProperties(Constructor.prototype, protoProps); if (staticProps) wrapper_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/** @implements {IWrapper} */\n\nvar wrapper_Wrapper =\n/*#__PURE__*/\nfunction () {\n  /** @param {!Node} node */\n  function Wrapper(node) {\n    wrapper_classCallCheck(this, Wrapper);\n\n    this.node = node;\n  } // node\n\n\n  wrapper_createClass(Wrapper, [{\n    key: \"addEventListener\",\n    value: function addEventListener(name, fn, options) {\n      return this.node[SHADY_PREFIX + 'addEventListener'](name, fn, options);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name, fn, options) {\n      return this.node[SHADY_PREFIX + 'removeEventListener'](name, fn, options);\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.node[SHADY_PREFIX + 'appendChild'](node);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref_node) {\n      return this.node[SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      return this.node[SHADY_PREFIX + 'removeChild'](node);\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(node, ref_node) {\n      return this.node[SHADY_PREFIX + 'replaceChild'](node, ref_node);\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      return this.node[SHADY_PREFIX + 'cloneNode'](deep);\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode(options) {\n      return this.node[SHADY_PREFIX + 'getRootNode'](options);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      return this.node[SHADY_PREFIX + 'contains'](node);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      return this.node[SHADY_PREFIX + 'dispatchEvent'](event);\n    } // element\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      this.node[SHADY_PREFIX + 'setAttribute'](name, value);\n    } // NOTE: not needed, just here for balance\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      return this.node[NATIVE_PREFIX + 'getAttribute'](name);\n    } // NOTE: not needed, just here for balance\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(name) {\n      return this.node[NATIVE_PREFIX + 'hasAttribute'](name);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      this.node[SHADY_PREFIX + 'removeAttribute'](name);\n    }\n  }, {\n    key: \"attachShadow\",\n    value: function attachShadow(options) {\n      return this.node[SHADY_PREFIX + 'attachShadow'](options);\n    }\n    /** @return {!Node|undefined} */\n\n  }, {\n    key: \"focus\",\n    // NOTE: not needed, just here for balance\n\n    /** @override */\n    value: function focus() {\n      this.node[NATIVE_PREFIX + 'focus']();\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.node[SHADY_PREFIX + 'blur']();\n    } // document\n\n  }, {\n    key: \"importNode\",\n    value: function importNode(node, deep) {\n      if (this.node.nodeType === Node.DOCUMENT_NODE) {\n        return this.node[SHADY_PREFIX + 'importNode'](node, deep);\n      }\n    }\n  }, {\n    key: \"getElementById\",\n    value: function getElementById(id) {\n      if (this.node.nodeType === Node.DOCUMENT_NODE) {\n        return this.node[SHADY_PREFIX + 'getElementById'](id);\n      }\n    } // query\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return this.node[SHADY_PREFIX + 'querySelector'](selector);\n    }\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector, useNative) {\n      return this.node[SHADY_PREFIX + 'querySelectorAll'](selector, useNative);\n    } // slot\n\n  }, {\n    key: \"assignedNodes\",\n    value: function assignedNodes(options) {\n      if (this.node.localName === 'slot') {\n        return this.node[SHADY_PREFIX + 'assignedNodes'](options);\n      }\n    }\n  }, {\n    key: \"activeElement\",\n    get: function get() {\n      if (utils_isShadyRoot(this.node) || this.node.nodeType === Node.DOCUMENT_NODE) {\n        var e = this.node[SHADY_PREFIX + 'activeElement'];\n        return e;\n      }\n    }\n    /**\n     * Installed for compatibility with browsers (older Chrome/Safari) that do\n     * not have a configurable `activeElement` accessor. Enables noPatch and\n     * patch mode both to consistently use ShadyDOM.wrap(document)._activeElement.\n     * @override\n     * @return {!Node|undefined}\n     */\n\n  }, {\n    key: \"_activeElement\",\n    get: function get() {\n      return this.activeElement;\n    }\n  }, {\n    key: \"host\",\n    get: function get() {\n      if (utils_isShadyRoot(this.node)) {\n        return (\n          /** @type {!ShadowRoot} */\n          this.node.host\n        );\n      }\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'parentNode'];\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'firstChild'];\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'lastChild'];\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'nextSibling'];\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'previousSibling'];\n    }\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'childNodes'];\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'parentElement'];\n    }\n  }, {\n    key: \"firstElementChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'firstElementChild'];\n    }\n  }, {\n    key: \"lastElementChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'lastElementChild'];\n    }\n  }, {\n    key: \"nextElementSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'nextElementSibling'];\n    }\n  }, {\n    key: \"previousElementSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'previousElementSibling'];\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'children'];\n    }\n  }, {\n    key: \"childElementCount\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'childElementCount'];\n    }\n  }, {\n    key: \"shadowRoot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'shadowRoot'];\n    }\n  }, {\n    key: \"assignedSlot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'assignedSlot'];\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'isConnected'];\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'innerHTML'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'innerHTML'] = value;\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'textContent'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'textContent'] = value;\n    }\n  }, {\n    key: \"slot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'slot'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'slot'] = value;\n    }\n  }]);\n\n  return Wrapper;\n}();\n\neventPropertyNames.forEach(function (name) {\n  Object.defineProperty(wrapper_Wrapper.prototype, name, {\n    /** @this {Wrapper} */\n    get: function get() {\n      return this.node[SHADY_PREFIX + name];\n    },\n\n    /** @this {Wrapper} */\n    set: function set(value) {\n      this.node[SHADY_PREFIX + name] = value;\n    },\n    configurable: true\n  });\n});\n\nvar wrapperMap = new WeakMap();\nfunction wrap(obj) {\n  if (utils_isShadyRoot(obj) || obj instanceof wrapper_Wrapper) {\n    return obj;\n  }\n\n  var wrapper = wrapperMap.get(obj);\n\n  if (!wrapper) {\n    wrapper = new wrapper_Wrapper(obj);\n    wrapperMap.set(obj, wrapper);\n  }\n\n  return wrapper;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/EventTarget.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar EventTargetPatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  dispatchEvent: function dispatchEvent(event) {\n    flush();\n    return this[NATIVE_PREFIX + 'dispatchEvent'](event);\n  },\n  addEventListener: patch_events_addEventListener,\n  removeEventListener: patch_events_removeEventListener\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slotable.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar SlotablePatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get assignedSlot() {\n    // Force any parent's shadowRoot to flush so that distribution occurs\n    // and this node has an assignedSlot.\n    var parent = this[SHADY_PREFIX + 'parentNode'];\n    var ownerRoot = parent && parent[SHADY_PREFIX + 'shadowRoot'];\n\n    if (ownerRoot) {\n      ownerRoot._flush();\n    }\n\n    var nodeData = shadyDataForNode(this);\n    return nodeData && nodeData.assignedSlot || null;\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Element.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\nvar Element_doc = window.document;\n/**\n * Should be called whenever an attribute changes. If the `slot` attribute\n * changes, provokes rendering if necessary. If a `<slot>` element's `name`\n * attribute changes, updates the root's slot map and renders.\n * @param {Node} node\n * @param {string} name\n */\n\nfunction distributeAttributeChange(node, name) {\n  if (name === 'slot') {\n    var parent = node[SHADY_PREFIX + 'parentNode'];\n\n    if (utils_hasShadowRootWithSlot(parent)) {\n      shadyDataForNode(parent).root._asyncRender();\n    }\n  } else if (node.localName === 'slot' && name === 'name') {\n    var root = attach_shadow_ownerShadyRootForNode(node);\n\n    if (root) {\n      root._updateSlotName(node);\n\n      root._asyncRender();\n    }\n  }\n}\n\nvar ElementPatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get previousElementSibling() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.previousSibling !== undefined) {\n      var n = this[SHADY_PREFIX + 'previousSibling'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'previousSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'previousElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get nextElementSibling() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.nextSibling !== undefined) {\n      var n = this[SHADY_PREFIX + 'nextSibling'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'nextSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'nextElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get slot() {\n    return this.getAttribute('slot');\n  },\n\n  /** @this {Element} */\n  set slot(value) {\n    this[SHADY_PREFIX + 'setAttribute']('slot', value);\n  },\n\n  // Note: Can be patched on element prototype on all browsers.\n  // Must be patched on instance on browsers that support native Shadow DOM\n  // but do not have builtin accessors (old Chrome).\n\n  /** @this {Element} */\n  get shadowRoot() {\n    var nodeData = shadyDataForNode(this);\n    return nodeData && nodeData.publicRoot || null;\n  },\n\n  /** @this {Element} */\n  get className() {\n    return this.getAttribute('class') || '';\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set className(value) {\n    this[SHADY_PREFIX + 'setAttribute']('class', value);\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   * @param {string} value\n   */\n  setAttribute: function setAttribute(attr, value) {\n    if (this.ownerDocument !== Element_doc) {\n      this[NATIVE_PREFIX + 'setAttribute'](attr, value);\n    } else if (!scopeClassAttribute(this, attr, value)) {\n      this[NATIVE_PREFIX + 'setAttribute'](attr, value);\n      distributeAttributeChange(this, attr);\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   */\n  removeAttribute: function removeAttribute(attr) {\n    this[NATIVE_PREFIX + 'removeAttribute'](attr);\n    distributeAttributeChange(this, attr);\n  },\n\n  /**\n   * @this {Element}\n   * @param {!{mode: string}} options\n   */\n  attachShadow: function attachShadow(options) {\n    return attach_shadow_attachShadow(this, options);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/HTMLElement.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar HTMLElementPatches = getOwnPropertyDescriptors({\n  /** @this {HTMLElement} */\n  blur: function blur() {\n    var nodeData = shadyDataForNode(this);\n    var root = nodeData && nodeData.root;\n    var shadowActive = root && root.activeElement;\n\n    if (shadowActive) {\n      shadowActive[SHADY_PREFIX + 'blur']();\n    } else {\n      this[NATIVE_PREFIX + 'blur']();\n    }\n  }\n});\neventPropertyNames.forEach(function (property) {\n  HTMLElementPatches[property] = {\n    /** @this {HTMLElement} */\n    set: function set(fn) {\n      var shadyData = ensureShadyDataForNode(this);\n      var eventName = property.substring(2);\n      shadyData.__onCallbackListeners[property] && this.removeEventListener(eventName, shadyData.__onCallbackListeners[property]);\n      this[SHADY_PREFIX + 'addEventListener'](eventName, fn);\n      shadyData.__onCallbackListeners[property] = fn;\n    },\n\n    /** @this {HTMLElement} */\n    get: function get() {\n      var shadyData = shadyDataForNode(this);\n      return shadyData && shadyData.__onCallbackListeners[property];\n    },\n    configurable: true\n  };\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar SlotPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {HTMLSlotElement}\n   * @param {Object=} options\n   */\n  assignedNodes: function assignedNodes(options) {\n    if (this.localName === 'slot') {\n      // Force any containing shadowRoot to flush so that distribution occurs\n      // and this node has assignedNodes.\n      var root = this[SHADY_PREFIX + 'getRootNode']();\n\n      if (root && utils_isShadyRoot(root)) {\n        root._flush();\n      }\n\n      var nodeData = shadyDataForNode(this);\n      return nodeData ? (options && options.flatten ? nodeData.flattenedNodes : nodeData.assignedNodes) || [] : [];\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Document.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar Document_doc = window.document;\nvar DocumentPatches = getOwnPropertyDescriptors({\n  // note: Though not technically correct, we fast path `importNode`\n  // when called on a node not owned by the main document.\n  // This allows, for example, elements that cannot\n  // contain custom elements and are therefore not likely to contain shadowRoots\n  // to cloned natively. This is a fairly significant performance win.\n\n  /**\n   * @this {Document}\n   * @param {Node} node\n   * @param {boolean} deep\n   */\n  importNode: function importNode(node, deep) {\n    // A template element normally has no children with shadowRoots, so make\n    // sure we always make a deep copy to correctly construct the template.content\n    if (node.ownerDocument !== Document_doc || node.localName === 'template') {\n      return this[NATIVE_PREFIX + 'importNode'](node, deep);\n    }\n\n    var n = this[NATIVE_PREFIX + 'importNode'](node, false);\n\n    if (deep) {\n      var c$ = node[SHADY_PREFIX + 'childNodes'];\n\n      for (var i = 0, nc; i < c$.length; i++) {\n        nc = this[SHADY_PREFIX + 'importNode'](c$[i], true);\n        n[SHADY_PREFIX + 'appendChild'](nc);\n      }\n    }\n\n    return n;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Window.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar WindowPatches = getOwnPropertyDescriptors({\n  // NOTE: ensure these methods are bound to `window` so that `this` is correct\n  // when called directly from global context without a receiver; e.g.\n  // `addEventListener(...)`.\n  addEventListener: patch_events_addEventListener.bind(window),\n  removeEventListener: patch_events_removeEventListener.bind(window)\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-prototypes.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n // Some browsers (IE/Edge) have non-standard HTMLElement accessors.\n\nvar NonStandardHTMLElement = {};\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement')) {\n  NonStandardHTMLElement.parentElement = NodePatches.parentElement;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'contains')) {\n  NonStandardHTMLElement.contains = NodePatches.contains;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'children')) {\n  NonStandardHTMLElement.children = ParentNodePatches.children;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML')) {\n  NonStandardHTMLElement.innerHTML = ElementOrShadowRootPatches.innerHTML;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'className')) {\n  NonStandardHTMLElement.className = ElementPatches.className;\n} // Avoid patching `innerHTML` if it does not exist on Element (IE)\n// and we can patch accessors (hasDescriptors).\n\n\nvar ElementShouldHaveInnerHTML = !settings.hasDescriptors || 'innerHTML' in Element.prototype; // setup patching\n\nvar patchMap = {\n  EventTarget: [EventTargetPatches],\n  Node: [NodePatches, !window.EventTarget ? EventTargetPatches : null],\n  Text: [SlotablePatches],\n  Element: [ElementPatches, ParentNodePatches, SlotablePatches, ElementShouldHaveInnerHTML ? ElementOrShadowRootPatches : null, !window.HTMLSlotElement ? SlotPatches : null],\n  HTMLElement: [HTMLElementPatches, NonStandardHTMLElement],\n  HTMLSlotElement: [SlotPatches],\n  DocumentFragment: [ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches],\n  Document: [DocumentPatches, ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches, DocumentOrShadowRootPatches],\n  Window: [WindowPatches]\n};\n\nvar getPatchPrototype = function getPatchPrototype(name) {\n  return window[name] && window[name].prototype;\n}; // Note, must avoid patching accessors on prototypes when descriptors are not correct\n// because the CustomElements polyfill checks if these exist before patching instances.\n// CustomElements polyfill *only* cares about these accessors.\n\n\nvar disallowedNativePatches = settings.hasDescriptors ? null : ['innerHTML', 'textContent'];\n/** @param {string=} prefix */\n\nvar patch_prototypes_applyPatches = function applyPatches(prefix) {\n  var disallowed = prefix ? null : disallowedNativePatches;\n\n  var _loop = function _loop(p) {\n    var proto = getPatchPrototype(p);\n    patchMap[p].forEach(function (patch) {\n      return proto && patch && patchProperties(proto, patch, prefix, disallowed);\n    });\n  };\n\n  for (var p in patchMap) {\n    _loop(p);\n  }\n};\nvar patch_prototypes_addShadyPrefixedProperties = function addShadyPrefixedProperties() {\n  // perform shady patches\n  patch_prototypes_applyPatches(SHADY_PREFIX); // install `_activeElement` because some browsers (older Chrome/Safari) do not have\n  // a 'configurable' `activeElement` accesssor.\n\n  var descriptor = DocumentOrShadowRootPatches.activeElement;\n  Object.defineProperty(document, '_activeElement', descriptor); // On Window, we're patching `addEventListener` which is a weird auto-bound\n  // property that is not directly on the Window prototype.\n\n  patchProperties(Window.prototype, WindowPatches, SHADY_PREFIX);\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shadydom.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\n\n\n\n\n\n\n\n\n\nif (settings.inUse) {\n  var ShadyDOM = {\n    // TODO(sorvell): remove when Polymer does not depend on this.\n    'inUse': settings.inUse,\n    // NOTE: old browsers without prototype accessors (very old Chrome\n    // and Safari) need manually patched accessors to properly set\n    // `innerHTML` and `textContent` when an element is:\n    // (1) inside a shadowRoot\n    // (2) does not have special (slot) children itself\n    // (3) and setting the property needs to provoke distribution (because\n    // a nested slot is added/removed)\n    'patch': function patch(node) {\n      patchInsideElementAccessors(node);\n      patchOutsideElementAccessors(node);\n      return node;\n    },\n    'isShadyRoot': utils_isShadyRoot,\n    'enqueue': enqueue,\n    'flush': flush,\n    'settings': settings,\n    'filterMutations': filterMutations,\n    'observeChildren': observe_changes_observeChildren,\n    'unobserveChildren': observe_changes_unobserveChildren,\n    // Set to true to defer native custom elements connection until the\n    // document has fully parsed. This enables custom elements that create\n    // shadowRoots to be defined while the document is loading. Elements\n    // customized as they are created by the parser will successfully\n    // render with this flag on.\n    'deferConnectionCallbacks': settings['deferConnectionCallbacks'],\n    // Set to true to speed up the polyfill slightly at the cost of correctness\n    // * does not patch querySelector/All on Document or DocumentFragment\n    // * does not wrap connected/disconnected callbacks to de-dup these\n    // when using native customElements\n    // * does not wait to process children of elements with shadowRoots\n    // meaning shadowRoots should not be created while an element is parsing\n    // (e.g. if a custom element that creates a shadowRoot is defined before\n    // a candidate element in the document below it.\n    'preferPerformance': settings['preferPerformance'],\n    // Integration point with ShadyCSS to disable styling MutationObserver,\n    // as ShadyDOM will now handle dynamic scoping.\n    'handlesDynamicScoping': true,\n    'wrap': settings.noPatch ? wrap : function (n) {\n      return n;\n    },\n    'Wrapper': wrapper_Wrapper,\n    'composedPath': patch_events_composedPath,\n    // Set to true to avoid patching regular platform property names. When set,\n    // Shadow DOM compatible behavior is only available when accessing DOM\n    // API using `ShadyDOM.wrap`, e.g. `ShadyDOM.wrap(element).shadowRoot`.\n    // This setting provides a small performance boost, but requires all DOM API\n    // access that requires Shadow DOM behavior to be proxied via `ShadyDOM.wrap`.\n    'noPatch': settings.noPatch,\n    'nativeMethods': nativeMethods,\n    'nativeTree': nativeTree\n  };\n  window['ShadyDOM'] = ShadyDOM; // Modifies native prototypes for Node, Element, etc. to\n  // make native platform behavior available at prefixed names, e.g.\n  // `utils.NATIVE_PREFIX + 'firstChild'` or `__shady_native_firstChild`.\n  // This allows the standard names to be safely patched while retaining the\n  // ability for native behavior to be used. This polyfill manipulates DOM\n  // by using this saved native behavior.\n  // Note, some browsers do not have proper element descriptors for\n  // accessors; in this case, native behavior for these accessors is simulated\n  // via a TreeWalker.\n\n  patch_native_addNativePrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to make ShadowDOM\n  // behavior available at prefixed names, e.g.\n  // `utils.SHADY_PREFIX + 'firstChild` or `__shady_firstChild`. This is done\n  // so this polyfill can perform Shadow DOM style DOM manipulation.\n  // Because patching normal platform property names is optional, these prefixed\n  // names are used internally.\n\n  patch_prototypes_addShadyPrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to patch\n  // regular platform property names to have Shadow DOM compatible API behavior.\n  // This applies the utils.SHADY_PREFIX behavior to normal names. For example,\n  // if `noPatch` is not set, then `el.__shady_firstChild` is equivalent to\n  // `el.firstChild`.\n  // NOTE, on older browsers (old Chrome/Safari) native accessors cannot be\n  // patched on prototypes (e.g. Node.prototype.firstChild cannot be modified).\n  // On these browsers, instance level patching is performed where needed; this\n  // instance patching is only done when `noPatch` is *not* set.\n\n  if (!settings.noPatch) {\n    patch_prototypes_applyPatches(); // Patch click event behavior only if we're patching\n\n    patchClick();\n  } // For simplicity, patch events unconditionally.\n  // Patches the event system to have Shadow DOM compatible behavior (e.g.\n  // event retargeting). When `noPatch` is set, retargeting is only available\n  // when adding event listeners and dispatching events via `ShadyDOM.wrap`\n  // (e.g. `ShadyDOM.wrap(element).addEventListener(...)`).\n\n\n  patchEvents();\n  window.ShadowRoot =\n  /** @type {function(new:ShadowRoot)} */\n  attach_shadow_ShadyRoot;\n}\n\n//# sourceURL=webpack:///./node_modules/@webcomponents/shadydom/src/shadydom.js_+_28_modules?");

/***/ })

}]);