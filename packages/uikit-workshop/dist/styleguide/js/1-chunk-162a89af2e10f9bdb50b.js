(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/document-register-element/build/document-register-element.node.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/document-register-element/build/document-register-element.node.js ***!
  \****************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\nISC License\n\nCopyright (c) 2014-2018, Andrea Giammarchi, @WebReflection\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\nOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n\n*/\n// global window Object\n// optional polyfill info\n//    'auto' used by default, everything is feature detected\n//    'force' use the polyfill even if not fully needed\nfunction installCustomElements(window, polyfill) {\n  'use strict'; // DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK\n  // THIS IS A PROJECT BASED ON A BUILD SYSTEM\n  // THIS FILE IS JUST WRAPPED UP RESULTING IN\n  // build/document-register-element.node.js\n\n  var document = window.document,\n      Object = window.Object;\n\n  var htmlClass = function (info) {\n    // (C) Andrea Giammarchi - @WebReflection - MIT Style\n    var catchClass = /^[A-Z]+[a-z]/,\n        filterBy = function filterBy(re) {\n      var arr = [],\n          tag;\n\n      for (tag in register) {\n        if (re.test(tag)) arr.push(tag);\n      }\n\n      return arr;\n    },\n        add = function add(Class, tag) {\n      tag = tag.toLowerCase();\n\n      if (!(tag in register)) {\n        register[Class] = (register[Class] || []).concat(tag);\n        register[tag] = register[tag.toUpperCase()] = Class;\n      }\n    },\n        register = (Object.create || Object)(null),\n        htmlClass = {},\n        i,\n        section,\n        tags,\n        Class;\n\n    for (section in info) {\n      for (Class in info[section]) {\n        tags = info[section][Class];\n        register[Class] = tags;\n\n        for (i = 0; i < tags.length; i++) {\n          register[tags[i].toLowerCase()] = register[tags[i].toUpperCase()] = Class;\n        }\n      }\n    }\n\n    htmlClass.get = function get(tagOrClass) {\n      return typeof tagOrClass === 'string' ? register[tagOrClass] || (catchClass.test(tagOrClass) ? [] : '') : filterBy(tagOrClass);\n    };\n\n    htmlClass.set = function set(tag, Class) {\n      return catchClass.test(tag) ? add(tag, Class) : add(Class, tag), htmlClass;\n    };\n\n    return htmlClass;\n  }({\n    \"collections\": {\n      \"HTMLAllCollection\": [\"all\"],\n      \"HTMLCollection\": [\"forms\"],\n      \"HTMLFormControlsCollection\": [\"elements\"],\n      \"HTMLOptionsCollection\": [\"options\"]\n    },\n    \"elements\": {\n      \"Element\": [\"element\"],\n      \"HTMLAnchorElement\": [\"a\"],\n      \"HTMLAppletElement\": [\"applet\"],\n      \"HTMLAreaElement\": [\"area\"],\n      \"HTMLAttachmentElement\": [\"attachment\"],\n      \"HTMLAudioElement\": [\"audio\"],\n      \"HTMLBRElement\": [\"br\"],\n      \"HTMLBaseElement\": [\"base\"],\n      \"HTMLBodyElement\": [\"body\"],\n      \"HTMLButtonElement\": [\"button\"],\n      \"HTMLCanvasElement\": [\"canvas\"],\n      \"HTMLContentElement\": [\"content\"],\n      \"HTMLDListElement\": [\"dl\"],\n      \"HTMLDataElement\": [\"data\"],\n      \"HTMLDataListElement\": [\"datalist\"],\n      \"HTMLDetailsElement\": [\"details\"],\n      \"HTMLDialogElement\": [\"dialog\"],\n      \"HTMLDirectoryElement\": [\"dir\"],\n      \"HTMLDivElement\": [\"div\"],\n      \"HTMLDocument\": [\"document\"],\n      \"HTMLElement\": [\"element\", \"abbr\", \"address\", \"article\", \"aside\", \"b\", \"bdi\", \"bdo\", \"cite\", \"code\", \"command\", \"dd\", \"dfn\", \"dt\", \"em\", \"figcaption\", \"figure\", \"footer\", \"header\", \"i\", \"kbd\", \"mark\", \"nav\", \"noscript\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"section\", \"small\", \"strong\", \"sub\", \"summary\", \"sup\", \"u\", \"var\", \"wbr\"],\n      \"HTMLEmbedElement\": [\"embed\"],\n      \"HTMLFieldSetElement\": [\"fieldset\"],\n      \"HTMLFontElement\": [\"font\"],\n      \"HTMLFormElement\": [\"form\"],\n      \"HTMLFrameElement\": [\"frame\"],\n      \"HTMLFrameSetElement\": [\"frameset\"],\n      \"HTMLHRElement\": [\"hr\"],\n      \"HTMLHeadElement\": [\"head\"],\n      \"HTMLHeadingElement\": [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],\n      \"HTMLHtmlElement\": [\"html\"],\n      \"HTMLIFrameElement\": [\"iframe\"],\n      \"HTMLImageElement\": [\"img\"],\n      \"HTMLInputElement\": [\"input\"],\n      \"HTMLKeygenElement\": [\"keygen\"],\n      \"HTMLLIElement\": [\"li\"],\n      \"HTMLLabelElement\": [\"label\"],\n      \"HTMLLegendElement\": [\"legend\"],\n      \"HTMLLinkElement\": [\"link\"],\n      \"HTMLMapElement\": [\"map\"],\n      \"HTMLMarqueeElement\": [\"marquee\"],\n      \"HTMLMediaElement\": [\"media\"],\n      \"HTMLMenuElement\": [\"menu\"],\n      \"HTMLMenuItemElement\": [\"menuitem\"],\n      \"HTMLMetaElement\": [\"meta\"],\n      \"HTMLMeterElement\": [\"meter\"],\n      \"HTMLModElement\": [\"del\", \"ins\"],\n      \"HTMLOListElement\": [\"ol\"],\n      \"HTMLObjectElement\": [\"object\"],\n      \"HTMLOptGroupElement\": [\"optgroup\"],\n      \"HTMLOptionElement\": [\"option\"],\n      \"HTMLOutputElement\": [\"output\"],\n      \"HTMLParagraphElement\": [\"p\"],\n      \"HTMLParamElement\": [\"param\"],\n      \"HTMLPictureElement\": [\"picture\"],\n      \"HTMLPreElement\": [\"pre\"],\n      \"HTMLProgressElement\": [\"progress\"],\n      \"HTMLQuoteElement\": [\"blockquote\", \"q\", \"quote\"],\n      \"HTMLScriptElement\": [\"script\"],\n      \"HTMLSelectElement\": [\"select\"],\n      \"HTMLShadowElement\": [\"shadow\"],\n      \"HTMLSlotElement\": [\"slot\"],\n      \"HTMLSourceElement\": [\"source\"],\n      \"HTMLSpanElement\": [\"span\"],\n      \"HTMLStyleElement\": [\"style\"],\n      \"HTMLTableCaptionElement\": [\"caption\"],\n      \"HTMLTableCellElement\": [\"td\", \"th\"],\n      \"HTMLTableColElement\": [\"col\", \"colgroup\"],\n      \"HTMLTableElement\": [\"table\"],\n      \"HTMLTableRowElement\": [\"tr\"],\n      \"HTMLTableSectionElement\": [\"thead\", \"tbody\", \"tfoot\"],\n      \"HTMLTemplateElement\": [\"template\"],\n      \"HTMLTextAreaElement\": [\"textarea\"],\n      \"HTMLTimeElement\": [\"time\"],\n      \"HTMLTitleElement\": [\"title\"],\n      \"HTMLTrackElement\": [\"track\"],\n      \"HTMLUListElement\": [\"ul\"],\n      \"HTMLUnknownElement\": [\"unknown\", \"vhgroupv\", \"vkeygen\"],\n      \"HTMLVideoElement\": [\"video\"]\n    },\n    \"nodes\": {\n      \"Attr\": [\"node\"],\n      \"Audio\": [\"audio\"],\n      \"CDATASection\": [\"node\"],\n      \"CharacterData\": [\"node\"],\n      \"Comment\": [\"#comment\"],\n      \"Document\": [\"#document\"],\n      \"DocumentFragment\": [\"#document-fragment\"],\n      \"DocumentType\": [\"node\"],\n      \"HTMLDocument\": [\"#document\"],\n      \"Image\": [\"img\"],\n      \"Option\": [\"option\"],\n      \"ProcessingInstruction\": [\"node\"],\n      \"ShadowRoot\": [\"#shadow-root\"],\n      \"Text\": [\"#text\"],\n      \"XMLDocument\": [\"xml\"]\n    }\n  }); // passed at runtime, configurable via nodejs module\n\n\n  if (_typeof(polyfill) !== 'object') polyfill = {\n    type: polyfill || 'auto'\n  };\n\n  var // V0 polyfill entry\n  REGISTER_ELEMENT = 'registerElement',\n      // IE < 11 only + old WebKit for attributes + feature detection\n  EXPANDO_UID = '__' + REGISTER_ELEMENT + (window.Math.random() * 10e4 >> 0),\n      // shortcuts and costants\n  ADD_EVENT_LISTENER = 'addEventListener',\n      ATTACHED = 'attached',\n      CALLBACK = 'Callback',\n      DETACHED = 'detached',\n      EXTENDS = 'extends',\n      ATTRIBUTE_CHANGED_CALLBACK = 'attributeChanged' + CALLBACK,\n      ATTACHED_CALLBACK = ATTACHED + CALLBACK,\n      CONNECTED_CALLBACK = 'connected' + CALLBACK,\n      DISCONNECTED_CALLBACK = 'disconnected' + CALLBACK,\n      CREATED_CALLBACK = 'created' + CALLBACK,\n      DETACHED_CALLBACK = DETACHED + CALLBACK,\n      ADDITION = 'ADDITION',\n      MODIFICATION = 'MODIFICATION',\n      REMOVAL = 'REMOVAL',\n      DOM_ATTR_MODIFIED = 'DOMAttrModified',\n      DOM_CONTENT_LOADED = 'DOMContentLoaded',\n      DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',\n      PREFIX_TAG = '<',\n      PREFIX_IS = '=',\n      // valid and invalid node names\n  validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,\n      invalidNames = ['ANNOTATION-XML', 'COLOR-PROFILE', 'FONT-FACE', 'FONT-FACE-SRC', 'FONT-FACE-URI', 'FONT-FACE-FORMAT', 'FONT-FACE-NAME', 'MISSING-GLYPH'],\n      // registered types and their prototypes\n  types = [],\n      protos = [],\n      // to query subnodes\n  query = '',\n      // html shortcut used to feature detect\n  documentElement = document.documentElement,\n      // ES5 inline helpers || basic patches\n  indexOf = types.indexOf || function (v) {\n    for (var i = this.length; i-- && this[i] !== v;) {}\n\n    return i;\n  },\n      // other helpers / shortcuts\n  OP = Object.prototype,\n      hOP = OP.hasOwnProperty,\n      iPO = OP.isPrototypeOf,\n      defineProperty = Object.defineProperty,\n      empty = [],\n      gOPD = Object.getOwnPropertyDescriptor,\n      gOPN = Object.getOwnPropertyNames,\n      gPO = Object.getPrototypeOf,\n      sPO = Object.setPrototypeOf,\n      // jshint proto: true\n  hasProto = !!Object.__proto__,\n      // V1 helpers\n  fixGetClass = false,\n      DRECEV1 = '__dreCEv1',\n      customElements = window.customElements,\n      usableCustomElements = !/^force/.test(polyfill.type) && !!(customElements && customElements.define && customElements.get && customElements.whenDefined),\n      Dict = Object.create || Object,\n      Map = window.Map || function Map() {\n    var K = [],\n        V = [],\n        i;\n    return {\n      get: function get(k) {\n        return V[indexOf.call(K, k)];\n      },\n      set: function set(k, v) {\n        i = indexOf.call(K, k);\n        if (i < 0) V[K.push(k) - 1] = v;else V[i] = v;\n      }\n    };\n  },\n      Promise = window.Promise || function (fn) {\n    var notify = [],\n        done = false,\n        p = {\n      'catch': function _catch() {\n        return p;\n      },\n      'then': function then(cb) {\n        notify.push(cb);\n        if (done) setTimeout(resolve, 1);\n        return p;\n      }\n    };\n\n    function resolve(value) {\n      done = true;\n\n      while (notify.length) {\n        notify.shift()(value);\n      }\n    }\n\n    fn(resolve);\n    return p;\n  },\n      justCreated = false,\n      constructors = Dict(null),\n      waitingList = Dict(null),\n      nodeNames = new Map(),\n      secondArgument = function secondArgument(is) {\n    return is.toLowerCase();\n  },\n      // used to create unique instances\n  create = Object.create || function Bridge(proto) {\n    // silly broken polyfill probably ever used but short enough to work\n    return proto ? (Bridge.prototype = proto, new Bridge()) : this;\n  },\n      // will set the prototype if possible\n  // or copy over all properties\n  setPrototype = sPO || (hasProto ? function (o, p) {\n    o.__proto__ = p;\n    return o;\n  } : gOPN && gOPD ? function () {\n    function setProperties(o, p) {\n      for (var key, names = gOPN(p), i = 0, length = names.length; i < length; i++) {\n        key = names[i];\n\n        if (!hOP.call(o, key)) {\n          defineProperty(o, key, gOPD(p, key));\n        }\n      }\n    }\n\n    return function (o, p) {\n      do {\n        setProperties(o, p);\n      } while ((p = gPO(p)) && !iPO.call(p, o));\n\n      return o;\n    };\n  }() : function (o, p) {\n    for (var key in p) {\n      o[key] = p[key];\n    }\n\n    return o;\n  }),\n      // DOM shortcuts and helpers, if any\n  MutationObserver = window.MutationObserver || window.WebKitMutationObserver,\n      HTMLAnchorElement = window.HTMLAnchorElement,\n      HTMLElementPrototype = (window.HTMLElement || window.Element || window.Node).prototype,\n      IE8 = !iPO.call(HTMLElementPrototype, documentElement),\n      safeProperty = IE8 ? function (o, k, d) {\n    o[k] = d.value;\n    return o;\n  } : defineProperty,\n      isValidNode = IE8 ? function (node) {\n    return node.nodeType === 1;\n  } : function (node) {\n    return iPO.call(HTMLElementPrototype, node);\n  },\n      targets = IE8 && [],\n      attachShadow = HTMLElementPrototype.attachShadow,\n      cloneNode = HTMLElementPrototype.cloneNode,\n      dispatchEvent = HTMLElementPrototype.dispatchEvent,\n      getAttribute = HTMLElementPrototype.getAttribute,\n      hasAttribute = HTMLElementPrototype.hasAttribute,\n      removeAttribute = HTMLElementPrototype.removeAttribute,\n      setAttribute = HTMLElementPrototype.setAttribute,\n      // replaced later on\n  createElement = document.createElement,\n      importNode = document.importNode,\n      patchedCreateElement = createElement,\n      // shared observer for all attributes\n  attributesObserver = MutationObserver && {\n    attributes: true,\n    characterData: true,\n    attributeOldValue: true\n  },\n      // useful to detect only if there's no MutationObserver\n  DOMAttrModified = MutationObserver || function (e) {\n    doesNotSupportDOMAttrModified = false;\n    documentElement.removeEventListener(DOM_ATTR_MODIFIED, DOMAttrModified);\n  },\n      // will both be used to make DOMNodeInserted asynchronous\n  asapQueue,\n      asapTimer = 0,\n      // internal flags\n  V0 = REGISTER_ELEMENT in document && !/^force-all/.test(polyfill.type),\n      setListener = true,\n      justSetup = false,\n      doesNotSupportDOMAttrModified = true,\n      dropDomContentLoaded = true,\n      // needed for the innerHTML helper\n  notFromInnerHTMLHelper = true,\n      // optionally defined later on\n  onSubtreeModified,\n      callDOMAttrModified,\n      getAttributesMirror,\n      observer,\n      observe,\n      // based on setting prototype capability\n  // will check proto or the expando attribute\n  // in order to setup the node once\n  patchIfNotAlready,\n      patch,\n      // used for tests\n  tmp; // IE11 disconnectedCallback issue #\n  // to be tested before any createElement patch\n\n\n  if (MutationObserver) {\n    // original fix:\n    // https://github.com/javan/mutation-observer-inner-html-shim\n    tmp = document.createElement('div');\n    tmp.innerHTML = '<div><div></div></div>';\n    new MutationObserver(function (mutations, observer) {\n      if (mutations[0] && mutations[0].type == 'childList' && !mutations[0].removedNodes[0].childNodes.length) {\n        tmp = gOPD(HTMLElementPrototype, 'innerHTML');\n\n        var _set = tmp && tmp.set;\n\n        if (_set) defineProperty(HTMLElementPrototype, 'innerHTML', {\n          set: function set(value) {\n            while (this.lastChild) {\n              this.removeChild(this.lastChild);\n            }\n\n            _set.call(this, value);\n          }\n        });\n      }\n\n      observer.disconnect();\n      tmp = null;\n    }).observe(tmp, {\n      childList: true,\n      subtree: true\n    });\n    tmp.innerHTML = \"\";\n  } // only if needed\n\n\n  if (!V0) {\n    if (sPO || hasProto) {\n      patchIfNotAlready = function patchIfNotAlready(node, proto) {\n        if (!iPO.call(proto, node)) {\n          setupNode(node, proto);\n        }\n      };\n\n      patch = setupNode;\n    } else {\n      patchIfNotAlready = function patchIfNotAlready(node, proto) {\n        if (!node[EXPANDO_UID]) {\n          node[EXPANDO_UID] = Object(true);\n          setupNode(node, proto);\n        }\n      };\n\n      patch = patchIfNotAlready;\n    }\n\n    if (IE8) {\n      doesNotSupportDOMAttrModified = false;\n\n      (function () {\n        var descriptor = gOPD(HTMLElementPrototype, ADD_EVENT_LISTENER),\n            addEventListener = descriptor.value,\n            patchedRemoveAttribute = function patchedRemoveAttribute(name) {\n          var e = new CustomEvent(DOM_ATTR_MODIFIED, {\n            bubbles: true\n          });\n          e.attrName = name;\n          e.prevValue = getAttribute.call(this, name);\n          e.newValue = null;\n          e[REMOVAL] = e.attrChange = 2;\n          removeAttribute.call(this, name);\n          dispatchEvent.call(this, e);\n        },\n            patchedSetAttribute = function patchedSetAttribute(name, value) {\n          var had = hasAttribute.call(this, name),\n              old = had && getAttribute.call(this, name),\n              e = new CustomEvent(DOM_ATTR_MODIFIED, {\n            bubbles: true\n          });\n          setAttribute.call(this, name, value);\n          e.attrName = name;\n          e.prevValue = had ? old : null;\n          e.newValue = value;\n\n          if (had) {\n            e[MODIFICATION] = e.attrChange = 1;\n          } else {\n            e[ADDITION] = e.attrChange = 0;\n          }\n\n          dispatchEvent.call(this, e);\n        },\n            onPropertyChange = function onPropertyChange(e) {\n          // jshint eqnull:true\n          var node = e.currentTarget,\n              superSecret = node[EXPANDO_UID],\n              propertyName = e.propertyName,\n              event;\n\n          if (superSecret.hasOwnProperty(propertyName)) {\n            superSecret = superSecret[propertyName];\n            event = new CustomEvent(DOM_ATTR_MODIFIED, {\n              bubbles: true\n            });\n            event.attrName = superSecret.name;\n            event.prevValue = superSecret.value || null;\n            event.newValue = superSecret.value = node[propertyName] || null;\n\n            if (event.prevValue == null) {\n              event[ADDITION] = event.attrChange = 0;\n            } else {\n              event[MODIFICATION] = event.attrChange = 1;\n            }\n\n            dispatchEvent.call(node, event);\n          }\n        };\n\n        descriptor.value = function (type, handler, capture) {\n          if (type === DOM_ATTR_MODIFIED && this[ATTRIBUTE_CHANGED_CALLBACK] && this.setAttribute !== patchedSetAttribute) {\n            this[EXPANDO_UID] = {\n              className: {\n                name: 'class',\n                value: this.className\n              }\n            };\n            this.setAttribute = patchedSetAttribute;\n            this.removeAttribute = patchedRemoveAttribute;\n            addEventListener.call(this, 'propertychange', onPropertyChange);\n          }\n\n          addEventListener.call(this, type, handler, capture);\n        };\n\n        defineProperty(HTMLElementPrototype, ADD_EVENT_LISTENER, descriptor);\n      })();\n    } else if (!MutationObserver) {\n      documentElement[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, DOMAttrModified);\n      documentElement.setAttribute(EXPANDO_UID, 1);\n      documentElement.removeAttribute(EXPANDO_UID);\n\n      if (doesNotSupportDOMAttrModified) {\n        onSubtreeModified = function onSubtreeModified(e) {\n          var node = this,\n              oldAttributes,\n              newAttributes,\n              key;\n\n          if (node === e.target) {\n            oldAttributes = node[EXPANDO_UID];\n            node[EXPANDO_UID] = newAttributes = getAttributesMirror(node);\n\n            for (key in newAttributes) {\n              if (!(key in oldAttributes)) {\n                // attribute was added\n                return callDOMAttrModified(0, node, key, oldAttributes[key], newAttributes[key], ADDITION);\n              } else if (newAttributes[key] !== oldAttributes[key]) {\n                // attribute was changed\n                return callDOMAttrModified(1, node, key, oldAttributes[key], newAttributes[key], MODIFICATION);\n              }\n            } // checking if it has been removed\n\n\n            for (key in oldAttributes) {\n              if (!(key in newAttributes)) {\n                // attribute removed\n                return callDOMAttrModified(2, node, key, oldAttributes[key], newAttributes[key], REMOVAL);\n              }\n            }\n          }\n        };\n\n        callDOMAttrModified = function callDOMAttrModified(attrChange, currentTarget, attrName, prevValue, newValue, action) {\n          var e = {\n            attrChange: attrChange,\n            currentTarget: currentTarget,\n            attrName: attrName,\n            prevValue: prevValue,\n            newValue: newValue\n          };\n          e[action] = attrChange;\n          onDOMAttrModified(e);\n        };\n\n        getAttributesMirror = function getAttributesMirror(node) {\n          for (var attr, name, result = {}, attributes = node.attributes, i = 0, length = attributes.length; i < length; i++) {\n            attr = attributes[i];\n            name = attr.name;\n\n            if (name !== 'setAttribute') {\n              result[name] = attr.value;\n            }\n          }\n\n          return result;\n        };\n      }\n    } // set as enumerable, writable and configurable\n\n\n    document[REGISTER_ELEMENT] = function registerElement(type, options) {\n      upperType = type.toUpperCase();\n\n      if (setListener) {\n        // only first time document.registerElement is used\n        // we need to set this listener\n        // setting it by default might slow down for no reason\n        setListener = false;\n\n        if (MutationObserver) {\n          observer = function (attached, detached) {\n            function checkEmAll(list, callback) {\n              for (var i = 0, length = list.length; i < length; callback(list[i++])) {}\n            }\n\n            return new MutationObserver(function (records) {\n              for (var current, node, newValue, i = 0, length = records.length; i < length; i++) {\n                current = records[i];\n\n                if (current.type === 'childList') {\n                  checkEmAll(current.addedNodes, attached);\n                  checkEmAll(current.removedNodes, detached);\n                } else {\n                  node = current.target;\n\n                  if (notFromInnerHTMLHelper && node[ATTRIBUTE_CHANGED_CALLBACK] && current.attributeName !== 'style') {\n                    newValue = getAttribute.call(node, current.attributeName);\n\n                    if (newValue !== current.oldValue) {\n                      node[ATTRIBUTE_CHANGED_CALLBACK](current.attributeName, current.oldValue, newValue);\n                    }\n                  }\n                }\n              }\n            });\n          }(executeAction(ATTACHED), executeAction(DETACHED));\n\n          observe = function observe(node) {\n            observer.observe(node, {\n              childList: true,\n              subtree: true\n            });\n            return node;\n          };\n\n          observe(document);\n\n          if (attachShadow) {\n            HTMLElementPrototype.attachShadow = function () {\n              return observe(attachShadow.apply(this, arguments));\n            };\n          }\n        } else {\n          asapQueue = [];\n          document[ADD_EVENT_LISTENER]('DOMNodeInserted', onDOMNode(ATTACHED));\n          document[ADD_EVENT_LISTENER]('DOMNodeRemoved', onDOMNode(DETACHED));\n        }\n\n        document[ADD_EVENT_LISTENER](DOM_CONTENT_LOADED, onReadyStateChange);\n        document[ADD_EVENT_LISTENER]('readystatechange', onReadyStateChange);\n\n        document.importNode = function (node, deep) {\n          switch (node.nodeType) {\n            case 1:\n              return setupAll(document, importNode, [node, !!deep]);\n\n            case 11:\n              for (var fragment = document.createDocumentFragment(), childNodes = node.childNodes, length = childNodes.length, i = 0; i < length; i++) {\n                fragment.appendChild(document.importNode(childNodes[i], !!deep));\n              }\n\n              return fragment;\n\n            default:\n              return cloneNode.call(node, !!deep);\n          }\n        };\n\n        HTMLElementPrototype.cloneNode = function (deep) {\n          return setupAll(this, cloneNode, [!!deep]);\n        };\n      }\n\n      if (justSetup) return justSetup = false;\n\n      if (-2 < indexOf.call(types, PREFIX_IS + upperType) + indexOf.call(types, PREFIX_TAG + upperType)) {\n        throwTypeError(type);\n      }\n\n      if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {\n        throw new Error('The type ' + type + ' is invalid');\n      }\n\n      var constructor = function constructor() {\n        return extending ? document.createElement(nodeName, upperType) : document.createElement(nodeName);\n      },\n          opt = options || OP,\n          extending = hOP.call(opt, EXTENDS),\n          nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,\n          upperType,\n          i;\n\n      if (extending && -1 < indexOf.call(types, PREFIX_TAG + nodeName)) {\n        throwTypeError(nodeName);\n      }\n\n      i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1;\n      query = query.concat(query.length ? ',' : '', extending ? nodeName + '[is=\"' + type.toLowerCase() + '\"]' : nodeName);\n      constructor.prototype = protos[i] = hOP.call(opt, 'prototype') ? opt.prototype : create(HTMLElementPrototype);\n      if (query.length) loopAndVerify(document.querySelectorAll(query), ATTACHED);\n      return constructor;\n    };\n\n    document.createElement = patchedCreateElement = function patchedCreateElement(localName, typeExtension) {\n      var is = getIs(typeExtension),\n          node = is ? createElement.call(document, localName, secondArgument(is)) : createElement.call(document, localName),\n          name = '' + localName,\n          i = indexOf.call(types, (is ? PREFIX_IS : PREFIX_TAG) + (is || name).toUpperCase()),\n          setup = -1 < i;\n\n      if (is) {\n        node.setAttribute('is', is = is.toLowerCase());\n\n        if (setup) {\n          setup = isInQSA(name.toUpperCase(), is);\n        }\n      }\n\n      notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;\n      if (setup) patch(node, protos[i]);\n      return node;\n    };\n  }\n\n  function ASAP() {\n    var queue = asapQueue.splice(0, asapQueue.length);\n    asapTimer = 0;\n\n    while (queue.length) {\n      queue.shift().call(null, queue.shift());\n    }\n  }\n\n  function loopAndVerify(list, action) {\n    for (var i = 0, length = list.length; i < length; i++) {\n      verifyAndSetupAndAction(list[i], action);\n    }\n  }\n\n  function loopAndSetup(list) {\n    for (var i = 0, length = list.length, node; i < length; i++) {\n      node = list[i];\n      patch(node, protos[getTypeIndex(node)]);\n    }\n  }\n\n  function executeAction(action) {\n    return function (node) {\n      if (isValidNode(node)) {\n        verifyAndSetupAndAction(node, action);\n        if (query.length) loopAndVerify(node.querySelectorAll(query), action);\n      }\n    };\n  }\n\n  function getTypeIndex(target) {\n    var is = getAttribute.call(target, 'is'),\n        nodeName = target.nodeName.toUpperCase(),\n        i = indexOf.call(types, is ? PREFIX_IS + is.toUpperCase() : PREFIX_TAG + nodeName);\n    return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;\n  }\n\n  function isInQSA(name, type) {\n    return -1 < query.indexOf(name + '[is=\"' + type + '\"]');\n  }\n\n  function onDOMAttrModified(e) {\n    var node = e.currentTarget,\n        attrChange = e.attrChange,\n        attrName = e.attrName,\n        target = e.target,\n        addition = e[ADDITION] || 2,\n        removal = e[REMOVAL] || 3;\n\n    if (notFromInnerHTMLHelper && (!target || target === node) && node[ATTRIBUTE_CHANGED_CALLBACK] && attrName !== 'style' && (e.prevValue !== e.newValue || // IE9, IE10, and Opera 12 gotcha\n    e.newValue === '' && (attrChange === addition || attrChange === removal))) {\n      node[ATTRIBUTE_CHANGED_CALLBACK](attrName, attrChange === addition ? null : e.prevValue, attrChange === removal ? null : e.newValue);\n    }\n  }\n\n  function onDOMNode(action) {\n    var executor = executeAction(action);\n    return function (e) {\n      asapQueue.push(executor, e.target);\n      if (asapTimer) clearTimeout(asapTimer);\n      asapTimer = setTimeout(ASAP, 1);\n    };\n  }\n\n  function onReadyStateChange(e) {\n    if (dropDomContentLoaded) {\n      dropDomContentLoaded = false;\n      e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);\n    }\n\n    if (query.length) loopAndVerify((e.target || document).querySelectorAll(query), e.detail === DETACHED ? DETACHED : ATTACHED);\n    if (IE8) purge();\n  }\n\n  function patchedSetAttribute(name, value) {\n    // jshint validthis:true\n    var self = this;\n    setAttribute.call(self, name, value);\n    onSubtreeModified.call(self, {\n      target: self\n    });\n  }\n\n  function setupAll(context, callback, args) {\n    var node = callback.apply(context, args),\n        i = getTypeIndex(node);\n    if (-1 < i) patch(node, protos[i]);\n    if (args.pop() && query.length) loopAndSetup(node.querySelectorAll(query));\n    return node;\n  }\n\n  function setupNode(node, proto) {\n    setPrototype(node, proto);\n\n    if (observer) {\n      observer.observe(node, attributesObserver);\n    } else {\n      if (doesNotSupportDOMAttrModified) {\n        node.setAttribute = patchedSetAttribute;\n        node[EXPANDO_UID] = getAttributesMirror(node);\n        node[ADD_EVENT_LISTENER](DOM_SUBTREE_MODIFIED, onSubtreeModified);\n      }\n\n      node[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, onDOMAttrModified);\n    }\n\n    if (node[CREATED_CALLBACK] && notFromInnerHTMLHelper) {\n      node.created = true;\n      node[CREATED_CALLBACK]();\n      node.created = false;\n    }\n  }\n\n  function purge() {\n    for (var node, i = 0, length = targets.length; i < length; i++) {\n      node = targets[i];\n\n      if (!documentElement.contains(node)) {\n        length--;\n        targets.splice(i--, 1);\n        verifyAndSetupAndAction(node, DETACHED);\n      }\n    }\n  }\n\n  function throwTypeError(type) {\n    throw new Error('A ' + type + ' type is already registered');\n  }\n\n  function verifyAndSetupAndAction(node, action) {\n    var fn,\n        i = getTypeIndex(node),\n        counterAction;\n\n    if (-1 < i) {\n      patchIfNotAlready(node, protos[i]);\n      i = 0;\n\n      if (action === ATTACHED && !node[ATTACHED]) {\n        node[DETACHED] = false;\n        node[ATTACHED] = true;\n        counterAction = 'connected';\n        i = 1;\n\n        if (IE8 && indexOf.call(targets, node) < 0) {\n          targets.push(node);\n        }\n      } else if (action === DETACHED && !node[DETACHED]) {\n        node[ATTACHED] = false;\n        node[DETACHED] = true;\n        counterAction = 'disconnected';\n        i = 1;\n      }\n\n      if (i && (fn = node[action + CALLBACK] || node[counterAction + CALLBACK])) fn.call(node);\n    }\n  } // V1 in da House!\n\n\n  function CustomElementRegistry() {}\n\n  CustomElementRegistry.prototype = {\n    constructor: CustomElementRegistry,\n    // a workaround for the stubborn WebKit\n    define: usableCustomElements ? function (name, Class, options) {\n      if (options) {\n        CERDefine(name, Class, options);\n      } else {\n        var NAME = name.toUpperCase();\n        constructors[NAME] = {\n          constructor: Class,\n          create: [NAME]\n        };\n        nodeNames.set(Class, NAME);\n        customElements.define(name, Class);\n      }\n    } : CERDefine,\n    get: usableCustomElements ? function (name) {\n      return customElements.get(name) || get(name);\n    } : get,\n    whenDefined: usableCustomElements ? function (name) {\n      return Promise.race([customElements.whenDefined(name), whenDefined(name)]);\n    } : whenDefined\n  };\n\n  function CERDefine(name, Class, options) {\n    var is = options && options[EXTENDS] || '',\n        CProto = Class.prototype,\n        proto = create(CProto),\n        attributes = Class.observedAttributes || empty,\n        definition = {\n      prototype: proto\n    }; // TODO: is this needed at all since it's inherited?\n    // defineProperty(proto, 'constructor', {value: Class});\n\n    safeProperty(proto, CREATED_CALLBACK, {\n      value: function value() {\n        if (justCreated) justCreated = false;else if (!this[DRECEV1]) {\n          this[DRECEV1] = true;\n          new Class(this);\n          if (CProto[CREATED_CALLBACK]) CProto[CREATED_CALLBACK].call(this);\n          var info = constructors[nodeNames.get(Class)];\n\n          if (!usableCustomElements || info.create.length > 1) {\n            notifyAttributes(this);\n          }\n        }\n      }\n    });\n    safeProperty(proto, ATTRIBUTE_CHANGED_CALLBACK, {\n      value: function value(name) {\n        if (-1 < indexOf.call(attributes, name)) {\n          if (CProto[ATTRIBUTE_CHANGED_CALLBACK]) CProto[ATTRIBUTE_CHANGED_CALLBACK].apply(this, arguments);\n        }\n      }\n    });\n\n    if (CProto[CONNECTED_CALLBACK]) {\n      safeProperty(proto, ATTACHED_CALLBACK, {\n        value: CProto[CONNECTED_CALLBACK]\n      });\n    }\n\n    if (CProto[DISCONNECTED_CALLBACK]) {\n      safeProperty(proto, DETACHED_CALLBACK, {\n        value: CProto[DISCONNECTED_CALLBACK]\n      });\n    }\n\n    if (is) definition[EXTENDS] = is;\n    name = name.toUpperCase();\n    constructors[name] = {\n      constructor: Class,\n      create: is ? [is, secondArgument(name)] : [name]\n    };\n    nodeNames.set(Class, name);\n    document[REGISTER_ELEMENT](name.toLowerCase(), definition);\n    whenDefined(name);\n    waitingList[name].r();\n  }\n\n  function get(name) {\n    var info = constructors[name.toUpperCase()];\n    return info && info.constructor;\n  }\n\n  function getIs(options) {\n    return typeof options === 'string' ? options : options && options.is || '';\n  }\n\n  function notifyAttributes(self) {\n    var callback = self[ATTRIBUTE_CHANGED_CALLBACK],\n        attributes = callback ? self.attributes : empty,\n        i = attributes.length,\n        attribute;\n\n    while (i--) {\n      attribute = attributes[i]; // || attributes.item(i);\n\n      callback.call(self, attribute.name || attribute.nodeName, null, attribute.value || attribute.nodeValue);\n    }\n  }\n\n  function whenDefined(name) {\n    name = name.toUpperCase();\n\n    if (!(name in waitingList)) {\n      waitingList[name] = {};\n      waitingList[name].p = new Promise(function (resolve) {\n        waitingList[name].r = resolve;\n      });\n    }\n\n    return waitingList[name].p;\n  }\n\n  function polyfillV1() {\n    if (customElements) delete window.customElements;\n    defineProperty(window, 'customElements', {\n      configurable: true,\n      value: new CustomElementRegistry()\n    });\n    defineProperty(window, 'CustomElementRegistry', {\n      configurable: true,\n      value: CustomElementRegistry\n    });\n\n    for (var patchClass = function patchClass(name) {\n      var Class = window[name];\n\n      if (Class) {\n        window[name] = function CustomElementsV1(self) {\n          var info, isNative;\n          if (!self) self = this;\n\n          if (!self[DRECEV1]) {\n            justCreated = true;\n            info = constructors[nodeNames.get(self.constructor)];\n            isNative = usableCustomElements && info.create.length === 1;\n            self = isNative ? Reflect.construct(Class, empty, info.constructor) : document.createElement.apply(document, info.create);\n            self[DRECEV1] = true;\n            justCreated = false;\n            if (!isNative) notifyAttributes(self);\n          }\n\n          return self;\n        };\n\n        window[name].prototype = Class.prototype;\n\n        try {\n          Class.prototype.constructor = window[name];\n        } catch (WebKit) {\n          fixGetClass = true;\n          defineProperty(Class, DRECEV1, {\n            value: window[name]\n          });\n        }\n      }\n    }, Classes = htmlClass.get(/^HTML[A-Z]*[a-z]/), i = Classes.length; i--; patchClass(Classes[i])) {}\n\n    document.createElement = function (name, options) {\n      var is = getIs(options);\n      return is ? patchedCreateElement.call(this, name, secondArgument(is)) : patchedCreateElement.call(this, name);\n    };\n\n    if (!V0) {\n      justSetup = true;\n      document[REGISTER_ELEMENT]('');\n    }\n  } // if customElements is not there at all\n\n\n  if (!customElements || /^force/.test(polyfill.type)) polyfillV1();else if (!polyfill.noBuiltIn) {\n    // if available test extends work as expected\n    try {\n      (function (DRE, options, name) {\n        var re = new RegExp('^<a\\\\s+is=(\\'|\")' + name + '\\\\1></a>$');\n        options[EXTENDS] = 'a';\n        DRE.prototype = create(HTMLAnchorElement.prototype);\n        DRE.prototype.constructor = DRE;\n        window.customElements.define(name, DRE, options);\n\n        if (!re.test(document.createElement('a', {\n          is: name\n        }).outerHTML) || !re.test(new DRE().outerHTML)) {\n          throw options;\n        }\n      })(function DRE() {\n        return Reflect.construct(HTMLAnchorElement, [], DRE);\n      }, {}, 'document-register-element-a');\n    } catch (o_O) {\n      // or force the polyfill if not\n      // and keep internal original reference\n      polyfillV1();\n    }\n  } // FireFox only issue\n\n  if (!polyfill.noBuiltIn) {\n    try {\n      createElement.call(document, 'a', 'a');\n    } catch (FireFox) {\n      secondArgument = function secondArgument(is) {\n        return {\n          is: is.toLowerCase()\n        };\n      };\n    }\n  }\n}\n\nmodule.exports = installCustomElements;\ninstallCustomElements(global);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/document-register-element/build/document-register-element.node.js?");

/***/ })

}]);