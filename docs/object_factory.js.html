<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: object_factory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: object_factory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
const patternEngines = require('./pattern_engines');
const path = require('path');
const extend = require('util')._extend;

// patternPrefixMatcher is intended to match the leading maybe-underscore,
// zero or more digits, and maybe-dash at the beginning of a pattern file name we can hack them
// off and get at the good part.
const patternPrefixMatcher = /^_?(\d+-)?/;

// Pattern properties
/**
 * Pattern constructor
 * @constructor
 */
const Pattern = function (relPath, data, patternlab) {
  /**
  * We expect relPath to be the path of the pattern template, relative to the
  * root of the pattern tree. Parse out the path parts and save the useful ones.
  * @param {relPath} relative directory
  * @param {data} The JSON used to render values in the pattern.
  * @param {patternlab} rendered html files for the pattern
  */
  const pathObj = path.parse(path.normalize(relPath));
  this.relPath = path.normalize(relPath); // '00-atoms/00-global/00-colors.mustache'
  this.fileName = pathObj.name;     // '00-colors'
  this.subdir = pathObj.dir;        // '00-atoms/00-global'
  this.fileExtension = pathObj.ext; // '.mustache'

  // this is the unique name, subDir + fileName (sans extension)
  this.name = this.subdir.replace(path.sep, '-') + '-' + this.fileName.replace('~', '-'); // '00-atoms-00-global-00-colors'

  // the JSON used to render values in the pattern
  this.jsonFileData = data || {};

  // strip leading "00-" from the file name and flip tildes to dashes
  this.patternBaseName = this.fileName.replace(patternPrefixMatcher, '').replace('~', '-'); // 'colors'

  // Fancy name. No idea how this works. 'Colors'
  this.patternName = this.patternBaseName.split('-').reduce(function (val, working) {
    return val.charAt(0).toUpperCase() + val.slice(1) + ' ' + working.charAt(0).toUpperCase() + working.slice(1);
  }, '').trim(); //this is the display name for the ui. strip numeric + hyphen prefixes

  // the top-level pattern group this pattern belongs to. 'atoms'
  this.patternGroup = this.subdir.split(path.sep)[0].replace(patternPrefixMatcher, '');

  //00-atoms if needed
  this.patternType = this.subdir.split(path.sep)[0];

  // the sub-group this pattern belongs to.
  this.patternSubGroup = path.basename(this.subdir).replace(patternPrefixMatcher, ''); // 'global'

  //00-colors if needed
  this.patternSubType = path.basename(this.subdir);

  // the joined pattern group and subgroup directory
  this.flatPatternPath = this.subdir.replace(/[\/\\]/g, '-'); // '00-atoms-00-global'

  // calculated path from the root of the public directory to the generated
  // (rendered!) html file for this pattern, to be shown in the iframe
  this.patternLink = patternlab ? this.getPatternLink(patternlab, 'rendered') : null;

  // The canonical "key" by which this pattern is known. This is the callable
  // name of the pattern. UPDATE: this.key is now known as this.patternPartial
  this.patternPartial = this.patternGroup + '-' + this.patternBaseName;

  // Let's calculate the verbose name ahead of time! We don't use path.sep here
  // on purpose. This isn't a file name!
  this.verbosePartial = this.subdir.split(path.sep).join('/') + '/' + this.fileName;

  this.isPattern = true;
  this.isFlatPattern = this.patternGroup === this.patternSubGroup;
  this.patternState = '';
  this.template = '';
  this.patternPartialCode = '';
  this.lineage = [];
  this.lineageIndex = [];
  this.lineageR = [];
  this.lineageRIndex = [];
  this.isPseudoPattern = false;
  this.order = Number.MAX_SAFE_INTEGER;
  this.engine = patternEngines.getEngineForPattern(this);

  /**
   * Determines if this pattern needs to be recompiled.
   *
   * @ee {@link CompileState}*/
  this.compileState = null;

  /**
   * Timestamp in milliseconds when the pattern template or auxilary file (e.g. json) were modified.
   * If multiple files are affected, this is the timestamp of the most recent change.
   *
   * @see {@link pattern}
   */
  this.lastModified = null;

};

// Pattern methods

Pattern.prototype = {

  // render method on oPatterns; this acts as a proxy for the PatternEngine's
  // render function
  render: function (data, partials) {
    if (this.engine) {
      return this.engine.renderPattern(this, data || this.jsonFileData, partials);
    }
    return null;
  },

  registerPartial: function () {
    if (this.engine &amp;&amp; typeof this.engine.registerPartial === 'function') {
      this.engine.registerPartial(this);
    }
  },

  // calculated path from the root of the public directory to the generated html
  // file for this pattern.
  // Should look something like '00-atoms-00-global-00-colors/00-atoms-00-global-00-colors.html'
  getPatternLink: function (patternlab, suffixType, customfileExtension) {
    // if no suffixType is provided, we default to rendered
    const suffixConfig = patternlab.config.outputFileSuffixes;
    const suffix = suffixType ? suffixConfig[suffixType] : suffixConfig.rendered;

    if (suffixType === 'rawTemplate') {
      return this.name + path.sep + this.name + suffix + this.fileExtension;
    }

    if (suffixType === 'custom') {
      return this.name + path.sep + this.name + customfileExtension;
    }

    return this.name + path.sep + this.name + suffix + '.html';
  },

  // the finders all delegate to the PatternEngine, which also encapsulates all
  // appropriate regexes
  findPartials: function () {
    return this.engine.findPartials(this);
  },

  findPartialsWithStyleModifiers: function () {
    return this.engine.findPartialsWithStyleModifiers(this);
  },

  findPartialsWithPatternParameters: function () {
    return this.engine.findPartialsWithPatternParameters(this);
  },

  findListItems: function () {
    return this.engine.findListItems(this);
  },

  findPartial: function (partialString) {
    return this.engine.findPartial(partialString);
  }
};

// Pattern static methods

// factory: creates an empty Pattern for miscellaneous internal use, such as
// by list_item_hunter
Pattern.createEmpty = function (customProps, patternlab) {
  let relPath = '';
  if (customProps) {
    if (customProps.relPath) {
      relPath = customProps.relPath;
    } else if (customProps.subdir &amp;&amp; customProps.filename) {
      relPath = customProps.subdir + path.sep + customProps.filename;
    }
  }

  const pattern = new Pattern(relPath, null, patternlab);
  return extend(pattern, customProps);
};

// factory: creates an Pattern object on-demand from a hash; the hash accepts
// parameters that replace the positional parameters that the Pattern
// constructor takes.
Pattern.create = function (relPath, data, customProps, patternlab) {
  const newPattern = new Pattern(relPath || '', data || null, patternlab);
  return extend(newPattern, customProps);
};

const CompileState = {
  NEEDS_REBUILD: "needs rebuild",
  BUILDING: "building",
  CLEAN: "clean"
};

module.exports = {
  Pattern: Pattern,
  CompileState: CompileState
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Annotations%2520Exporter.html">Annotations Exporter</a></li></ul><h3>Classes</h3><ul><li><a href="ChangesHunter.html">ChangesHunter</a></li><li><a href="Constructs%2520a%2520new%2520PatternGraph%2520from%2520a%2520JSON-style%2520JavaScript%2520object%2520or%2520an%2520empty%2520graph%250Dif%2520no%2520argument%2520is%2520given..html">Constructs a new PatternGraph from a JSON-style JavaScript object or an empty graphif no argument is given.</a></li><li><a href="Pattern.html">Pattern</a></li><li><a href="PatternRegistry.html">PatternRegistry</a></li><li><a href="VersionMismatch.html">VersionMismatch</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addEdge">addEdge</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#buildPatternData">buildPatternData</a></li><li><a href="global.html#debug">debug</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#header">header</a></li><li><a href="global.html#initializePlugins">initializePlugins</a></li><li><a href="global.html#installPlugin">installPlugin</a></li><li><a href="global.html#loadDataFromFolder">loadDataFromFolder</a></li><li><a href="global.html#loadFile">loadFile</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#niceKey">niceKey</a></li><li><a href="global.html#PATTERN_GRAPH_VERSION">PATTERN_GRAPH_VERSION</a></li><li><a href="global.html#reportError">reportError</a></li><li><a href="global.html#subGraph">subGraph</a></li><li><a href="global.html#warning">warning</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Oct 17 2017 09:51:21 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
